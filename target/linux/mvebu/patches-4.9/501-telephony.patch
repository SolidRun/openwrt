diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
new file mode 100644
index 0000000..368165e
--- /dev/null
+++ b/arch/arm/include/asm/system.h
@@ -0,0 +1,7 @@
+/* FILE TO BE DELETED. DO NOT ADD STUFF HERE! */
+#include <asm/barrier.h>
+#include <asm/compiler.h>
+#include <asm/cmpxchg.h>
+#include <asm/switch_to.h>
+#include <asm/system_info.h>
+#include <asm/system_misc.h>
diff --git a/arch/arm/include/mvCommon.h b/arch/arm/include/mvCommon.h
new file mode 120000
index 0000000..1718f09
--- /dev/null
+++ b/arch/arm/include/mvCommon.h
@@ -0,0 +1 @@
+../../../drivers/telephony/mvebu_phone/mvCommon.h
\ No newline at end of file
diff --git a/arch/arm/include/mvOs.h b/arch/arm/include/mvOs.h
new file mode 120000
index 0000000..35717d8
--- /dev/null
+++ b/arch/arm/include/mvOs.h
@@ -0,0 +1 @@
+../../../drivers/telephony/mvebu_phone/mvOs.h
\ No newline at end of file
diff --git a/arch/arm/include/mvSysTdmConfig.h b/arch/arm/include/mvSysTdmConfig.h
new file mode 120000
index 0000000..c3db9e9
--- /dev/null
+++ b/arch/arm/include/mvSysTdmConfig.h
@@ -0,0 +1 @@
+../../../drivers/telephony/mvebu_phone/mvSysTdmConfig.h
\ No newline at end of file
diff --git a/arch/arm/include/mvTypes.h b/arch/arm/include/mvTypes.h
new file mode 120000
index 0000000..6f376c5
--- /dev/null
+++ b/arch/arm/include/mvTypes.h
@@ -0,0 +1 @@
+../../../drivers/telephony/mvebu_phone/mvTypes.h
\ No newline at end of file
diff --git a/arch/arm/include/plat b/arch/arm/include/plat
new file mode 120000
index 0000000..ea4405d
--- /dev/null
+++ b/arch/arm/include/plat
@@ -0,0 +1 @@
+../../../drivers/telephony/mvebu_phone/plat/
\ No newline at end of file
diff --git a/arch/arm/include/slic b/arch/arm/include/slic
new file mode 120000
index 0000000..ea4405d
--- /dev/null
+++ b/arch/arm/include/slic
@@ -0,0 +1 @@
+../../../drivers/telephony/mvebu_phone/plat/
\ No newline at end of file
diff --git a/arch/arm/include/voiceband b/arch/arm/include/voiceband
new file mode 120000
index 0000000..c122c90
--- /dev/null
+++ b/arch/arm/include/voiceband
@@ -0,0 +1 @@
+../../../drivers/telephony/mvebu_phone/voiceband/
\ No newline at end of file
diff --git a/drivers/telephony/Kconfig b/drivers/telephony/Kconfig
new file mode 100644
index 0000000..f776970
--- /dev/null
+++ b/drivers/telephony/Kconfig
@@ -0,0 +1,32 @@
+#
+# Telephony device configuration
+#
+
+menuconfig PHONE
+	bool "Telephony devices support"
+	default n
+	---help---
+	  Say Y here to get to see options for hardware telephony devices.
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and disabled.
+
+if PHONE
+
+config MV_INCLUDE_TDM
+	bool "Mvebu TDM Telephony"
+	depends on ARCH_MVEBU
+	default y
+	---help---
+	  This driver supports the TDM-based telephony interface
+	  units in the following Marvell SoC families:
+	  1. ARMADA-370.
+	  2. ARMADA-375.
+	  3. ARMADA-38x.
+	  4. ARMADA-XP.
+
+if MV_INCLUDE_TDM
+	source "drivers/telephony/mvebu_phone/Kconfig"
+endif
+
+endif # PHONE
diff --git a/drivers/telephony/Makefile b/drivers/telephony/Makefile
new file mode 100644
index 0000000..1a7a260
--- /dev/null
+++ b/drivers/telephony/Makefile
@@ -0,0 +1,5 @@
+#
+# linux/drivers/telephony/Makefile
+#
+
+obj-$(CONFIG_MV_INCLUDE_TDM)		+= mvebu_phone/
diff --git a/drivers/telephony/mvebu_phone/Kconfig b/drivers/telephony/mvebu_phone/Kconfig
new file mode 100644
index 0000000..d6063c8
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/Kconfig
@@ -0,0 +1,14 @@
+menu "Marvell Telephony options"
+	depends on MV_INCLUDE_TDM
+
+config MV_TDM2C_SUPPORT
+	bool "Support legacy TDM(2 channels)"
+	depends on MACH_ARMADA_38X
+	default y
+	---help---
+	Choosing this option enables Marvell
+	2CH TDM voice interface.
+	The TDM bus may be used for transferring
+	voice samples through analog phone interface.
+
+endmenu
diff --git a/drivers/telephony/mvebu_phone/Makefile b/drivers/telephony/mvebu_phone/Makefile
new file mode 100644
index 0000000..444d745
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/Makefile
@@ -0,0 +1,24 @@
+#
+# Makefile for mvebu_phone Marvell telephony driver
+#
+
+CPU_ARCH    = ARM
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+MVEBU_PHONE_FLAGS	:= -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
+export MVEBU_PHONE_FLAGS
+
+ccflags-y		+= $(MVEBU_PHONE_FLAGS)
+
+INCLUDE_DIRS		+= -I$(srctree)/drivers/telephony/mvebu_phone
+INCLUDE_DIRS		+= -I$(srctree)/arch/arm/mach-mvebu/linux_oss
+INCLUDE_DIRS		+= -I$(srctree)/arch/arm/mach-mvebu/include/mach
+export INCLUDE_DIRS
+
+ccflags-y		+= $(INCLUDE_DIRS)
+
+obj-y			+= mv_phone/ mvOs.o
diff --git a/drivers/telephony/mvebu_phone/mvCommon.h b/drivers/telephony/mvebu_phone/mvCommon.h
new file mode 100644
index 0000000..62ab77c
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mvCommon.h
@@ -0,0 +1,404 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCommonh
+#define __INCmvCommonh
+
+#ifdef __cplusplus
+extern "C" {
+#endif	/* __cplusplus */
+
+#include "mvTypes.h"
+#ifndef MV_ASMLANGUAGE
+
+/* The golden ration: an arbitrary value */
+#define MV_JHASH_GOLDEN_RATIO           0x9e3779b9
+
+#define MV_JHASH_MIX(a, b, c)        \
+{                                   \
+	a -= b; a -= c; a ^= (c>>13);   \
+	b -= c; b -= a; b ^= (a<<8);    \
+	c -= a; c -= b; c ^= (b>>13);   \
+	a -= b; a -= c; a ^= (c>>12);   \
+	b -= c; b -= a; b ^= (a<<16);   \
+	c -= a; c -= b; c ^= (b>>5);    \
+	a -= b; a -= c; a ^= (c>>3);    \
+	b -= c; b -= a; b ^= (a<<10);   \
+	c -= a; c -= b; c ^= (b>>15);   \
+}
+
+#ifdef MV_VXWORKS
+static __inline__ MV_U32 mv_jhash_3words(MV_U32 a, MV_U32 b, MV_U32 c, MV_U32 initval)
+#else
+static inline MV_U32 mv_jhash_3words(MV_U32 a, MV_U32 b, MV_U32 c, MV_U32 initval)
+
+#endif
+{
+	a += MV_JHASH_GOLDEN_RATIO;
+	b += MV_JHASH_GOLDEN_RATIO;
+	c += initval;
+	MV_JHASH_MIX(a, b, c);
+
+	return c;
+}
+#endif
+
+
+/* Swap tool */
+
+/* 16bit nibble swap. For example 0x1234 -> 0x2143                          */
+#define MV_NIBBLE_SWAP_16BIT(X)        (((X&0xf) << 4) |     \
+					((X&0xf0) >> 4) |    \
+					((X&0xf00) << 4) |   \
+					((X&0xf000) >> 4))
+
+/* 32bit nibble swap. For example 0x12345678 -> 0x21436587                  */
+#define MV_NIBBLE_SWAP_32BIT(X)		(((X&0xf) << 4) |       \
+					((X&0xf0) >> 4) |      \
+					((X&0xf00) << 4) |     \
+					((X&0xf000) >> 4) |    \
+					((X&0xf0000) << 4) |   \
+					((X&0xf00000) >> 4) |  \
+					((X&0xf000000) << 4) | \
+					((X&0xf0000000) >> 4))
+
+/* 16bit byte swap. For example 0x1234->0x3412                             */
+#define MV_BYTE_SWAP_16BIT(X) ((((X)&0xff)<<8) | (((X)&0xff00)>>8))
+
+/* 32bit byte swap. For example 0x12345678->0x78563412                    */
+#define MV_BYTE_SWAP_32BIT(X)  ((((X)&0xff)<<24) |                       \
+				(((X)&0xff00)<<8) |                      \
+				(((X)&0xff0000)>>8) |                    \
+				(((X)&0xff000000)>>24))
+
+/* 64bit byte swap. For example 0x11223344.55667788 -> 0x88776655.44332211  */
+#define MV_BYTE_SWAP_64BIT(X) ((l64) ((((X)&0xffULL)<<56) |             \
+				      (((X)&0xff00ULL)<<40) |           \
+				      (((X)&0xff0000ULL)<<24) |         \
+				      (((X)&0xff000000ULL)<<8) |        \
+				      (((X)&0xff00000000ULL)>>8) |      \
+				      (((X)&0xff0000000000ULL)>>24) |   \
+				      (((X)&0xff000000000000ULL)>>40) | \
+				      (((X)&0xff00000000000000ULL)>>56)))
+
+/* Endianess macros.                                                        */
+#if 1
+#define MV_16BIT_LE(X)  (X)
+#define MV_32BIT_LE(X)  (X)
+#define MV_64BIT_LE(X)  (X)
+#define MV_16BIT_BE(X)  MV_BYTE_SWAP_16BIT(X)
+#define MV_32BIT_BE(X)  MV_BYTE_SWAP_32BIT(X)
+#define MV_64BIT_BE(X)  MV_BYTE_SWAP_64BIT(X)
+#elif defined(MV_CPU_BE)
+#define MV_16BIT_LE(X)  MV_BYTE_SWAP_16BIT(X)
+#define MV_32BIT_LE(X)  MV_BYTE_SWAP_32BIT(X)
+#define MV_64BIT_LE(X)  MV_BYTE_SWAP_64BIT(X)
+#define MV_16BIT_BE(X)  (X)
+#define MV_32BIT_BE(X)  (X)
+#define MV_64BIT_BE(X)  (X)
+#else
+#error "CPU endianess isn't defined!\n"
+#endif
+
+/* Bit field definitions */
+#define NO_BIT      0x00000000
+
+/* avoid redefinition of bits */
+#ifndef BIT0
+
+#define BIT0        0x00000001
+#define BIT1        0x00000002
+#define BIT2        0x00000004
+#define BIT3        0x00000008
+#define BIT4        0x00000010
+#define BIT5        0x00000020
+#define BIT6        0x00000040
+#define BIT7        0x00000080
+#define BIT8        0x00000100
+#define BIT9        0x00000200
+#define BIT10       0x00000400
+#define BIT11       0x00000800
+#define BIT12       0x00001000
+#define BIT13       0x00002000
+#define BIT14       0x00004000
+#define BIT15       0x00008000
+#define BIT16       0x00010000
+#define BIT17       0x00020000
+#define BIT18       0x00040000
+#define BIT19       0x00080000
+#define BIT20       0x00100000
+#define BIT21       0x00200000
+#define BIT22       0x00400000
+#define BIT23       0x00800000
+#define BIT24       0x01000000
+#define BIT25       0x02000000
+#define BIT26       0x04000000
+#define BIT27       0x08000000
+#define BIT28       0x10000000
+#define BIT29       0x20000000
+#define BIT30       0x40000000
+#define BIT31       0x80000000
+
+#endif /* BIT0 */
+/* Handy sizes */
+#define _1K         0x00000400
+#define _2K         0x00000800
+#define _4K         0x00001000
+#define _8K         0x00002000
+#define _16K        0x00004000
+#define _32K        0x00008000
+#define _64K        0x00010000
+#define _128K       0x00020000
+#define _256K       0x00040000
+#define _512K       0x00080000
+
+#define _1M         0x00100000
+#define _2M         0x00200000
+#define _4M         0x00400000
+#define _8M         0x00800000
+#define _16M        0x01000000
+#define _32M        0x02000000
+#define _64M        0x04000000
+#define _128M       0x08000000
+#define _256M       0x10000000
+#define _512M       0x20000000
+
+#define _1G         0x40000000
+#define _2G         0x80000000
+
+/* Tclock and Sys clock define */
+#define _100MHz     100000000
+#define _125MHz     125000000
+#define _133MHz     133333334
+#define _150MHz     150000000
+#define _160MHz     160000000
+#define _166MHz     166666667
+#define _175MHz     175000000
+#define _178MHz     178000000
+#define _183MHz     183333334
+#define _187MHz     187000000
+#define _192MHz     192000000
+#define _194MHz     194000000
+#define _200MHz     200000000
+#define _233MHz     233333334
+#define _250MHz     250000000
+#define _266MHz     266666667
+#define _300MHz     300000000
+#define _800MHz     800000000
+#define _1GHz       1000000000UL
+#define _2GHz       2000000000UL
+
+/* Supported clocks */
+#define MV_BOARD_TCLK_100MHZ	100000000
+#define MV_BOARD_TCLK_125MHZ	125000000
+#define MV_BOARD_TCLK_133MHZ	133333333
+#define MV_BOARD_TCLK_150MHZ	150000000
+#define MV_BOARD_TCLK_166MHZ	166666667
+#define MV_BOARD_TCLK_200MHZ	200000000
+#define MV_BOARD_TCLK_250MHZ	250000000
+
+#define MV_BOARD_SYSCLK_100MHZ	100000000
+#define MV_BOARD_SYSCLK_125MHZ	125000000
+#define MV_BOARD_SYSCLK_133MHZ	133333333
+#define MV_BOARD_SYSCLK_150MHZ	150000000
+#define MV_BOARD_SYSCLK_166MHZ	166666667
+#define MV_BOARD_SYSCLK_200MHZ	200000000
+#define MV_BOARD_SYSCLK_233MHZ	233333333
+#define MV_BOARD_SYSCLK_250MHZ	250000000
+#define MV_BOARD_SYSCLK_267MHZ	266666667
+#define MV_BOARD_SYSCLK_300MHZ	300000000
+#define MV_BOARD_SYSCLK_333MHZ	333333334
+#define MV_BOARD_SYSCLK_400MHZ	400000000
+
+#define MV_BOARD_REFCLK_25MHZ	 25000000
+
+/* For better address window table readability */
+#define EN			MV_TRUE
+#define DIS			MV_FALSE
+#define N_A			-1	/* Not applicable */
+
+/* Cache configuration options for memory (DRAM, SRAM, ... ) */
+
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED             0
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT    1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB    2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW       3
+
+/* Macro for testing aligment. Positive if number is NOT aligned   */
+#define MV_IS_NOT_ALIGN(number, align)      ((number) & ((align) - 1))
+
+/* Macro for alignment up. For example, MV_ALIGN_UP(0x0330, 0x20) = 0x0340   */
+#define MV_ALIGN_UP(number, align)                                          \
+(((number) & ((align) - 1)) ? (((number) + (align)) & ~((align)-1)) : (number))
+
+/* Macro for alignment down. For example, MV_ALIGN_UP(0x0330, 0x20) = 0x0320 */
+#define MV_ALIGN_DOWN(number, align) ((number) & ~((align)-1))
+
+/* This macro returns absolute value                                        */
+#define MV_ABS(number)  (((int)(number) < 0) ? -(int)(number) : (int)(number))
+
+/* Bit fields manipulation macros                                           */
+
+/* An integer word which its 'x' bit is set                                 */
+#define MV_BIT_MASK(bitNum)         (1 << (bitNum))
+
+/* Checks wheter bit 'x' in integer word is set                             */
+#define MV_BIT_CHECK(word, bitNum)  ((word) & MV_BIT_MASK(bitNum))
+
+/* Clear (reset) bit 'x' in integer word (RMW - Read-Modify-Write)          */
+#define MV_BIT_CLEAR(word, bitNum)  ((word) &= ~(MV_BIT_MASK(bitNum)))
+
+/* Set bit 'x' in integer word (RMW)                                        */
+#define MV_BIT_SET(word, bitNum)    ((word) |= MV_BIT_MASK(bitNum))
+
+/* Invert bit 'x' in integer word (RMW)                                     */
+#define MV_BIT_INV(word, bitNum)    ((word) ^= MV_BIT_MASK(bitNum))
+
+/* Get the min between 'a' or 'b'                                           */
+#define MV_MIN(a, b)    (((a) < (b)) ? (a) : (b))
+
+/* Get the max between 'a' or 'b'                                           */
+#define MV_MAX(a, b)    (((a) < (b)) ? (b) : (a))
+
+#define mvOsDivide(num, div)	\
+({				\
+	int i = 0, rem = (num);	\
+	while (rem >= (div)) {	\
+		rem -= (div);	\
+		i++;		\
+	}			\
+	(i);			\
+})
+
+#define mvOsReminder(num, div)	\
+({				\
+	int rem = (num);	\
+	while (rem >= (div))	\
+		rem -= (div);	\
+	(rem);			\
+})
+
+#define MV_MACQUAD_FMT "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x"
+
+#define MV_MACQUAD(addr) \
+	(((unsigned char *)addr)[0], \
+	((unsigned char *)addr)[1], \
+	((unsigned char *)addr)[2], \
+	((unsigned char *)addr)[3], \
+	((unsigned char *)addr)[4], \
+	((unsigned char *)addr)[5])
+
+#define MV_IPQUAD_FMT         "%u.%u.%u.%u"
+#define MV_IPQUAD(ip)         (ip[0], ip[1], ip[2], ip[3])
+
+#define MV_IP_QUAD(ipAddr)    (((ipAddr >> 24) & 0xFF), ((ipAddr >> 16) & 0xFF), \
+				((ipAddr >> 8) & 0xFF), ((ipAddr >> 0) & 0xFF))
+
+#define MV_IP6_FMT		"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x"
+#define MV_IP6_ARG(L3)		(L3[0], L3[1], L3[2], L3[3],	\
+				L3[4], L3[5], L3[6], L3[7],	\
+				L3[8], L3[9], L3[10], L3[11],	\
+				L3[12], L3[13], L3[14], L3[15])
+
+#define MV_IS_POWER_OF_2(num) ((num != 0) && ((num & (num - 1)) == 0))
+
+#define MV_GET_BIT(word, bitNum) (((word) & (1 << (bitNum))) >> (bitNum))
+
+#define MV_SET_BIT(word, bitNum, bitVal) (((word) & ~(1 << (bitNum))) | (bitVal << bitNum))
+
+#define MV_ARRAY_SIZE(a)                    ((sizeof(a)) / (sizeof(a[0])))
+
+#ifndef MV_ASMLANGUAGE
+/* mvCommon API list */
+
+int mvCharToHex(char ch);
+int mvCharToDigit(char ch);
+
+MV_VOID mvHexToBin(const char *pHexStr, MV_U8 *pBin, int size);
+void mvAsciiToHex(const char *asciiStr, char *hexStr);
+void mvBinToHex(const MV_U8 *bin, char *hexStr, int size);
+void mvBinToAscii(const MV_U8 *bin, char *asciiStr, int size);
+MV_U8 mvReverseBits(MV_U8 num);
+MV_U32 mvCountMaskBits(MV_U8 mask);
+
+MV_STATUS mvMacStrToHex(const char *macStr, MV_U8 *macHex);
+MV_STATUS mvMacHexToStr(MV_U8 *macHex, char *macStr);
+void mvSizePrint(MV_U64);
+
+MV_U32 mvLog2(MV_U32 num);
+
+MV_STATUS mvWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_STATUS mvWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif	/* __cplusplus */
+
+#endif /* __INCmvCommonh */
diff --git a/drivers/telephony/mvebu_phone/mvOs.c b/drivers/telephony/mvebu_phone/mvOs.c
new file mode 100644
index 0000000..a5c93e0
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mvOs.c
@@ -0,0 +1,286 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvOsCpuArchLib.c - Marvell CPU architecture library
+*
+* DESCRIPTION:
+*       This library introduce Marvell API for OS dependent CPU architecture
+*       APIs. This library introduce single CPU architecture services APKI
+*       cross OS.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvOs.h"
+
+static MV_U32 read_p15_c0(void);
+static MV_U32 read_p15_c1(void);
+
+/* defines  */
+#define ARM_ID_REVISION_OFFS	0
+#define ARM_ID_REVISION_MASK	(0xf << ARM_ID_REVISION_OFFS)
+
+#define ARM_ID_PART_NUM_OFFS	4
+#define ARM_ID_PART_NUM_MASK	(0xfff << ARM_ID_PART_NUM_OFFS)
+
+#define ARM_ID_ARCH_OFFS	16
+#define ARM_ID_ARCH_MASK	(0xf << ARM_ID_ARCH_OFFS)
+
+#define ARM_ID_VAR_OFFS		20
+#define ARM_ID_VAR_MASK		(0xf << ARM_ID_VAR_OFFS)
+
+#define ARM_ID_ASCII_OFFS	24
+#define ARM_ID_ASCII_MASK	(0xff << ARM_ID_ASCII_OFFS)
+
+#define ARM_FEATURE_THUMBEE_OFFS	12
+#define ARM_FEATURE_THUMBEE_MASK	(0xf << ARM_FEATURE_THUMBEE_OFFS)
+
+
+void *mvOsIoCachedMalloc(void *osHandle, MV_U32 size, MV_ULONG *pPhyAddr,
+			  MV_U32 *memHandle)
+{
+	void *p = kmalloc(size, GFP_ATOMIC);
+	dma_addr_t dma_addr;
+	dma_addr = dma_map_single(osHandle, p, 0, DMA_BIDIRECTIONAL);
+	*pPhyAddr = (MV_ULONG)(dma_addr & 0xFFFFFFFF);
+	return p;
+}
+void *mvOsIoUncachedMalloc(void *osHandle, MV_U32 size, MV_ULONG *pPhyAddr,
+			    MV_U32 *memHandle)
+{
+	dma_addr_t dma_addr;
+	void *ptr = dma_alloc_coherent(osHandle, size, &dma_addr, GFP_KERNEL);
+	*pPhyAddr = (MV_ULONG)(dma_addr & 0xFFFFFFFF);
+	return ptr;
+}
+
+void mvOsIoUncachedFree(void *osHandle, MV_U32 size, MV_ULONG phyAddr, void *pVirtAddr,
+			 MV_U32 memHandle)
+{
+	dma_free_coherent(osHandle, size, pVirtAddr, (dma_addr_t)phyAddr);
+}
+
+void mvOsIoCachedFree(void *osHandle, MV_U32 size, MV_ULONG phyAddr, void *pVirtAddr,
+		       MV_U32 memHandle)
+{
+	return kfree(pVirtAddr);
+}
+
+int mvOsRand(void)
+{
+	int rand;
+	get_random_bytes(&rand, sizeof(rand));
+	return rand;
+}
+
+/*******************************************************************************
+* mvOsCpuVerGet() -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit CPU Revision
+*
+*******************************************************************************/
+MV_U32 mvOsCpuRevGet(MV_VOID)
+{
+	return (read_p15_c0() & ARM_ID_REVISION_MASK) >> ARM_ID_REVISION_OFFS;
+}
+/*******************************************************************************
+* mvOsCpuPartGet() -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit CPU Part number
+*
+*******************************************************************************/
+MV_U32 mvOsCpuPartGet(MV_VOID)
+{
+	return (read_p15_c0() & ARM_ID_PART_NUM_MASK) >> ARM_ID_PART_NUM_OFFS;
+}
+/*******************************************************************************
+* mvOsCpuArchGet() -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit CPU Architicture number
+*
+*******************************************************************************/
+MV_U32 mvOsCpuArchGet(MV_VOID)
+{
+	return (read_p15_c0() & ARM_ID_ARCH_MASK) >> ARM_ID_ARCH_OFFS;
+}
+/*******************************************************************************
+* mvOsCpuVarGet() -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit CPU Variant number
+*
+*******************************************************************************/
+MV_U32 mvOsCpuVarGet(MV_VOID)
+{
+	return (read_p15_c0() & ARM_ID_VAR_MASK) >> ARM_ID_VAR_OFFS;
+}
+/*******************************************************************************
+* mvOsCpuAsciiGet() -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit CPU Variant number
+*
+*******************************************************************************/
+MV_U32 mvOsCpuAsciiGet(MV_VOID)
+{
+	return (read_p15_c0() & ARM_ID_ASCII_MASK) >> ARM_ID_ASCII_OFFS;
+}
+
+/*******************************************************************************
+* mvOsCpuThumbEEGet() -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit CPU Variant number
+*
+*******************************************************************************/
+MV_U32 mvOsCpuThumbEEGet(MV_VOID)
+{
+	return (read_p15_c1() & ARM_FEATURE_THUMBEE_MASK) >> ARM_FEATURE_THUMBEE_OFFS;
+}
+
+/*
+static unsigned long read_p15_c0 (void)
+*/
+/* read co-processor 15, register #0 (ID register) */
+static MV_U32 read_p15_c0 (void)
+{
+	MV_U32 value;
+
+	__asm__ __volatile__(
+		"mrc	p15, 0, %0, c0, c0, 0   @ read control reg\n"
+		: "=r" (value)
+		:
+		: "memory");
+
+	return value;
+}
+
+/* read co-processor 15, register #1 (Feature 0) */
+static MV_U32 read_p15_c1 (void)
+{
+	MV_U32 value;
+
+	__asm__ __volatile__(
+						 "mrc	p15, 0, %0, c0, c1, 0   @ read feature0 reg\n"
+	: "=r" (value)
+	:
+	: "memory");
+
+	return value;
+}
diff --git a/drivers/telephony/mvebu_phone/mvOs.h b/drivers/telephony/mvebu_phone/mvOs.h
new file mode 100644
index 0000000..35e80a4
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mvOs.h
@@ -0,0 +1,481 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _MV_OS_LNX_H_
+#define _MV_OS_LNX_H_
+
+#ifdef __KERNEL__
+/* for kernel space */
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/blkdev.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/hardirq.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <linux/module.h>
+
+#include <linux/random.h>
+
+#define arch_is_coherent()      true
+
+extern void mv_early_printk(char *fmt, ...);
+
+#define MV_ASM              (__asm__ __volatile__)
+#define INLINE              inline
+#define _INIT               __init
+#define MV_TRC_REC(...)
+#define mvOsPrintf          printk
+#define mvOsEarlyPrintf	    mv_early_printk
+#define mvOsOutput          printk
+#define mvOsSPrintf         sprintf
+#define mvOsSNPrintf        snprintf
+#define mvOsMalloc(_size_)  kmalloc(_size_, GFP_ATOMIC)
+#define mvOsFree            kfree
+#define mvOsMemcpy          memcpy
+#define mvOsMemset          memset
+#define mvOsSleep(_mils_)   mdelay(_mils_)
+#define mvOsTaskLock()
+#define mvOsTaskUnlock()
+#define strtol              simple_strtoul
+#define mvOsDelay(x)        mdelay(x)
+#define mvOsUDelay(x)       udelay(x)
+#define mvCopyFromOs        copy_from_user
+#define mvCopyToOs          copy_to_user
+#define mvOsWarning()       WARN_ON(1)
+#define mvOsGetTicks()      jiffies
+#define mvOsGetTicksFreq()  HZ
+
+#include "mvTypes.h"
+#include "mvCommon.h"
+//#include "../coherency.h"
+
+#ifdef MV_NDEBUG
+#define mvOsAssert(cond)
+#else
+#define mvOsAssert(cond) { do { if (!(cond)) { BUG(); } } while (0); }
+#endif /* MV_NDEBUG */
+
+#else /* __KERNEL__ */
+
+/* for user space applications */
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+
+#define INLINE inline
+#define mvOsPrintf printf
+#define mvOsOutput printf
+#define mvOsMalloc(_size_) malloc(_size_)
+#define mvOsFree free
+#define mvOsAssert(cond) assert(cond)
+
+#endif /* __KERNEL__ */
+
+#define mvOsIoVirtToPhy(pDev, pVirtAddr)        virt_to_dma((pDev), (pVirtAddr))
+
+#define mvOsIoVirtToPhys(pDev, pVirtAddr)       virt_to_dma((pDev), (pVirtAddr))
+
+#define mvOsCacheFlush(pDev, p, size)                              \
+	dma_map_single((pDev), (p), (size), DMA_TO_DEVICE)
+
+#define mvOsCacheInvalidate(pDev, p, size)                          \
+	dma_map_single((pDev), (p), (size), DMA_FROM_DEVICE)
+
+#define mvOsCacheUnmap(pDev, phys, size)                          \
+	dma_unmap_single((pDev), (dma_addr_t)(phys), (size), DMA_FROM_DEVICE)
+
+#define CPU_PHY_MEM(x)              ((MV_U32)x)
+#define CPU_MEMIO_CACHED_ADDR(x)    ((void *)x)
+#define CPU_MEMIO_UNCACHED_ADDR(x)  ((void *)x)
+
+
+/* CPU architecture dependent 32, 16, 8 bit read/write IO addresses */
+#define MV_MEMIO32_WRITE(addr, data)    \
+	((*((volatile unsigned int *)(addr))) = ((unsigned int)(data)))
+
+#define MV_MEMIO32_READ(addr)           \
+	((*((volatile unsigned int *)(addr))))
+
+#define MV_MEMIO16_WRITE(addr, data)    \
+	((*((volatile unsigned short *)(addr))) = ((unsigned short)(data)))
+
+#define MV_MEMIO16_READ(addr)           \
+	((*((volatile unsigned short *)(addr))))
+
+#define MV_MEMIO8_WRITE(addr, data)     \
+	((*((volatile unsigned char *)(addr))) = ((unsigned char)(data)))
+
+#define MV_MEMIO8_READ(addr)            \
+	((*((volatile unsigned char *)(addr))))
+
+
+/* No Fast Swap implementation (in assembler) for ARM */
+#define MV_32BIT_LE_FAST(val)            MV_32BIT_LE(val)
+#define MV_16BIT_LE_FAST(val)            MV_16BIT_LE(val)
+#define MV_32BIT_BE_FAST(val)            MV_32BIT_BE(val)
+#define MV_16BIT_BE_FAST(val)            MV_16BIT_BE(val)
+
+/* 32 and 16 bit read/write in big/little endian mode */
+
+/* 16bit write in little endian mode */
+#define MV_MEMIO_LE16_WRITE(addr, data) \
+	MV_MEMIO16_WRITE(addr, MV_16BIT_LE_FAST(data))
+
+/* 16bit read in little endian mode */
+static inline MV_U16 MV_MEMIO_LE16_READ(MV_U32 addr)
+{
+	MV_U16 data;
+
+	data = (MV_U16)MV_MEMIO16_READ(addr);
+
+	return (MV_U16)MV_16BIT_LE_FAST(data);
+}
+
+/* 32bit write in little endian mode */
+#define MV_MEMIO_LE32_WRITE(addr, data) \
+	MV_MEMIO32_WRITE(addr, MV_32BIT_LE_FAST(data))
+
+/* 32bit read in little endian mode */
+static inline MV_U32 MV_MEMIO_LE32_READ(MV_U32 addr)
+{
+	MV_U32 data;
+
+	data = (MV_U32)MV_MEMIO32_READ(addr);
+
+	return (MV_U32)MV_32BIT_LE_FAST(data);
+}
+
+static inline void mvOsBCopy(char *srcAddr, char *dstAddr, int byteCount)
+{
+	while (byteCount != 0) {
+		*dstAddr = *srcAddr;
+		dstAddr++;
+		srcAddr++;
+		byteCount--;
+	}
+}
+
+static INLINE MV_U64 mvOsDivMod64(MV_U64 divided, MV_U64 divisor, MV_U64 *modulu)
+{
+	MV_U64  division = 0;
+
+	if (divisor == 1)
+		return divided;
+
+	while (divided >= divisor) {
+		division++;
+		divided -= divisor;
+	}
+	if (modulu != NULL)
+		*modulu = divided;
+
+	return division;
+}
+
+/* Flash APIs */
+#define MV_FL_8_READ            MV_MEMIO8_READ
+#define MV_FL_16_READ           MV_MEMIO_LE16_READ
+#define MV_FL_32_READ           MV_MEMIO_LE32_READ
+#define MV_FL_8_DATA_READ       MV_MEMIO8_READ
+#define MV_FL_16_DATA_READ      MV_MEMIO16_READ
+#define MV_FL_32_DATA_READ      MV_MEMIO32_READ
+#define MV_FL_8_WRITE           MV_MEMIO8_WRITE
+#define MV_FL_16_WRITE          MV_MEMIO_LE16_WRITE
+#define MV_FL_32_WRITE          MV_MEMIO_LE32_WRITE
+#define MV_FL_8_DATA_WRITE      MV_MEMIO8_WRITE
+#define MV_FL_16_DATA_WRITE     MV_MEMIO16_WRITE
+#define MV_FL_32_DATA_WRITE     MV_MEMIO32_WRITE
+
+
+/* CPU cache information */
+#define CPU_I_CACHE_LINE_SIZE   32    /* 2do: replace 32 with linux core macro */
+#define CPU_D_CACHE_LINE_SIZE   32    /* 2do: replace 32 with linux core macro */
+
+#if defined(CONFIG_SHEEVA_ERRATA_ARM_CPU_4413)
+#define	 DSBWA_4413(x)	dmb() 		/* replaced dsb() for optimization */
+#else
+#define  DSBWA_4413(x)
+#endif
+
+#if defined(CONFIG_SHEEVA_ERRATA_ARM_CPU_4611)
+#define	 DSBWA_4611(x)	dmb()		/* replaced dsb() for optimization */
+#else
+#define  DSBWA_4611(x)
+#endif
+
+#define MV_OS_CACHE_MULTI_THRESH	256
+
+static inline void mvOsCacheIoSync(void *handle)
+{
+	if (likely(1/*COHERENCY_FABRIC_HARD_MODE()*/))
+		dma_sync_single_for_cpu(handle, (dma_addr_t) NULL,
+					CPU_D_CACHE_LINE_SIZE, DMA_FROM_DEVICE);
+}
+
+static inline void mvOsCacheLineFlush(void *handle, void *addr)
+{
+		dma_sync_single_for_device(handle, virt_to_dma(handle, addr), CPU_D_CACHE_LINE_SIZE, DMA_TO_DEVICE);
+}
+
+static inline void mvOsCacheLineInv(void *handle, void *addr)
+{
+		dma_sync_single_for_device(handle, virt_to_dma(handle, addr), CPU_D_CACHE_LINE_SIZE, DMA_FROM_DEVICE);
+}
+
+/* Flush multiple cache lines using mvOsCacheLineFlush to improve performance.              */
+/* addr is the pointer to start the flush operation from. It will be aligned to             */
+/* the beginning of the cache line automatically and the size will be adjusted accordingly. */
+static inline void mvOsCacheMultiLineFlush(void *handle, void *addr, int size)
+{
+		dma_map_single(handle, addr, size, DMA_TO_DEVICE);
+}
+
+/* Invalidate multiple cache lines using mvOsCacheLineInv to improve performance.           */
+/* addr is the pointer to start the invalidate operation from. It will be aligned to        */
+/* the beginning of the cache line automatically and the size will be adjusted accordingly. */
+/* IMPORTANT: this function assumes the invalidate operation on partial lines does not      */
+/* interfere with the data written there.                                                   */
+/* DO NOT USE this function unless you are certain of this!                                 */
+static inline void mvOsCacheMultiLineInv(void *handle, void *addr, int size)
+{
+		dma_map_single(handle, addr, size, DMA_FROM_DEVICE);
+}
+
+/* Flush and invalidate multiple cache lines using mvOsCacheLineFlushInv to improve performance. */
+/* addr is the pointer to start the flush and invalidate operation from. It will be aligned to   */
+/* the beginning of the cache line automatically and the size will be adjusted accordingly.      */
+static inline void mvOsCacheMultiLineFlushInv(void *handle, void *addr, int size)
+{
+		dma_map_single(handle, addr, size, DMA_BIDIRECTIONAL);
+}
+
+/* register manipulations  */
+
+/******************************************************************************
+* This debug function enable the write of each register that u-boot access to
+* to an array in the DRAM, the function record only MV_REG_WRITE access.
+* The function could not be operate when booting from flash.
+* In order to print the array we use the printreg command.
+******************************************************************************/
+/* #define REG_DEBUG */
+#if defined(REG_DEBUG)
+extern int reg_arry[2048][2];
+extern int reg_arry_index;
+#endif
+
+/* Marvell controller register read/write macros */
+#define MV_REG_VALUE(offset)          \
+	(MV_MEMIO32_READ((INTER_REGS_VIRT_BASE | (offset))))
+
+/* PPv2 specific reg read/write */
+#ifdef CONFIG_OF
+#define MV_PP2_CPU0_REG_READ(offset)             \
+	(MV_MEMIO_LE32_READ(offset))
+#define MV_PP2_CPU0_REG_WRITE(offset, val)    \
+	MV_MEMIO_LE32_WRITE((offset), (val))
+
+#define MV_PP2_CPU1_REG_READ(offset)             \
+	(MV_MEMIO_LE32_READ(offset))
+#define MV_PP2_CPU1_REG_WRITE(offset, val)    \
+	MV_MEMIO_LE32_WRITE((offset), (val))
+#else
+#define MV_PP2_CPU0_REG_READ(offset)             \
+	(MV_MEMIO_LE32_READ(PP2_CPU0_VIRT_BASE | (offset & 0xffff)))
+#define MV_PP2_CPU0_REG_WRITE(offset, val)    \
+	MV_MEMIO_LE32_WRITE((PP2_CPU0_VIRT_BASE | (offset & 0xffff)), (val))
+
+#define MV_PP2_CPU1_REG_READ(offset)             \
+	(MV_MEMIO_LE32_READ(PP2_CPU1_VIRT_BASE | (offset & 0xffff)))
+#define MV_PP2_CPU1_REG_WRITE(offset, val)    \
+	MV_MEMIO_LE32_WRITE((PP2_CPU1_VIRT_BASE | (offset & 0xffff)), (val))
+#endif
+
+#ifdef CONFIG_SMP
+#define MV_PP2_REG_READ(offset)	\
+	((smp_processor_id() == 0) ? MV_PP2_CPU0_REG_READ(offset) : MV_PP2_CPU1_REG_READ(offset))
+
+#define MV_PP2_REG_WRITE(offset, val)	\
+	((smp_processor_id() == 0) ? MV_PP2_CPU0_REG_WRITE(offset, val) : MV_PP2_CPU1_REG_WRITE(offset, val))
+#else
+#define MV_PP2_REG_READ(offset)	\
+	MV_PP2_CPU0_REG_READ(offset)
+
+#define MV_PP2_REG_WRITE(offset, val)	\
+	MV_PP2_CPU0_REG_WRITE(offset, val)
+#endif
+
+#define MV_REG_READ(offset)			MV_MEMIO_LE32_READ(offset)
+
+#if defined(REG_DEBUG)
+#define MV_REG_WRITE(offset, val)    \
+	MV_MEMIO_LE32_WRITE(((offset)), (val)); \
+	{ \
+		reg_arry[reg_arry_index][0] = (offset);\
+		reg_arry[reg_arry_index][1] = (val);\
+		reg_arry_index++;\
+	}
+#else
+#define MV_REG_WRITE(offset, val)	MV_MEMIO_LE32_WRITE((offset), (val))
+#endif
+
+#define MV_REG_BYTE_READ(offset)	MV_MEMIO8_READ((offset))
+
+#if defined(REG_DEBUG)
+#define MV_REG_BYTE_WRITE(offset, val)  \
+	MV_MEMIO8_WRITE((offset), (val)); \
+	{ \
+		reg_arry[reg_arry_index][0] = (offset);\
+		reg_arry[reg_arry_index][1] = (val);\
+		reg_arry_index++;\
+	}
+#else
+#define MV_REG_BYTE_WRITE(offset, val)  \
+	MV_MEMIO8_WRITE((offset), (val))
+#endif
+
+#if defined(REG_DEBUG)
+#define MV_REG_BIT_SET(offset, bitMask)                 \
+	(MV_MEMIO32_WRITE((offset), \
+	(MV_MEMIO32_READ(offset) | \
+	MV_32BIT_LE_FAST(bitMask)))); \
+	{ \
+		reg_arry[reg_arry_index][0] = (offset);\
+		reg_arry[reg_arry_index][1] = (MV_MEMIO32_READ(offset));\
+		reg_arry_index++;\
+	}
+#else
+#define MV_REG_BIT_SET(offset, bitMask)                 \
+	(MV_MEMIO32_WRITE((offset), \
+	(MV_MEMIO32_READ(offset) | \
+	MV_32BIT_LE_FAST(bitMask))))
+#endif
+
+#if defined(REG_DEBUG)
+#define MV_REG_BIT_RESET(offset, bitMask)                \
+	(MV_MEMIO32_WRITE((offset), \
+	(MV_MEMIO32_READ(offset) & \
+	MV_32BIT_LE_FAST(~bitMask)))); \
+	{ \
+		reg_arry[reg_arry_index][0] = (offset);\
+		reg_arry[reg_arry_index][1] = (MV_MEMIO32_READ(offset));\
+		reg_arry_index++;\
+	}
+#else
+#define MV_REG_BIT_RESET(offset, bitMask)                \
+	(MV_MEMIO32_WRITE((offset), \
+	(MV_MEMIO32_READ(offset) & \
+	MV_32BIT_LE_FAST(~bitMask))))
+#endif
+
+/* Assembly functions */
+
+/*
+** MV_ASM_READ_CPU_EXTRA_FEATURES
+** Read Marvell extra features register.
+*/
+#define MV_ASM_READ_EXTRA_FEATURES(x) __asm__ volatile("mrc  p15, 1, %0, c15, c1, 0" : "=r" (x));
+
+/*
+** MV_ASM_WAIT_FOR_INTERRUPT
+** Wait for interrupt.
+*/
+#define MV_ASM_WAIT_FOR_INTERRUPT      __asm__ volatile("mcr  p15, 0, r0, c7, c0, 4");
+
+
+/* ARM architecture APIs */
+MV_U32  mvOsCpuRevGet(MV_VOID);
+MV_U32  mvOsCpuPartGet(MV_VOID);
+MV_U32  mvOsCpuArchGet(MV_VOID);
+MV_U32  mvOsCpuVarGet(MV_VOID);
+MV_U32  mvOsCpuAsciiGet(MV_VOID);
+MV_U32  mvOsCpuThumbEEGet(MV_VOID);
+
+/*  Other APIs  */
+void *mvOsIoCachedMalloc(void *osHandle, MV_U32 size, MV_ULONG *pPhyAddr, MV_U32 *memHandle);
+void *mvOsIoUncachedMalloc(void *osHandle, MV_U32 size, MV_ULONG *pPhyAddr, MV_U32 *memHandle);
+void mvOsIoUncachedFree(void *osHandle, MV_U32 size, MV_ULONG phyAddr, void *pVirtAddr, MV_U32 memHandle);
+void mvOsIoCachedFree(void *osHandle, MV_U32 size, MV_ULONG phyAddr, void *pVirtAddr, MV_U32 memHandle);
+int  mvOsRand(void);
+
+#endif /* _MV_OS_LNX_H_ */
diff --git a/drivers/telephony/mvebu_phone/mvSysTdmConfig.h b/drivers/telephony/mvebu_phone/mvSysTdmConfig.h
new file mode 100644
index 0000000..a94dbe8
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mvSysTdmConfig.h
@@ -0,0 +1,172 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvSysTdmConfig.h - Marvell TDM unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+#ifndef __INCmvSysTdmConfigh
+#define __INCmvSysTdmConfigh
+
+//#include "mvOs.h"
+#include "voiceband/mvSysTdmSpi.h"
+#include "voiceband/common/mvTdmComm.h"
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+extern int tdm_base, use_pclk_external;
+#define MV_TDM_REGS_BASE	(tdm_base)
+
+/* Core DivClk Control Register */
+
+/* DCO clock apply/reset bits */
+#define DCO_CLK_DIV_MOD_OFFS			24
+#define DCO_CLK_DIV_APPLY			(0x1 << DCO_CLK_DIV_MOD_OFFS)
+#define DCO_CLK_DIV_RESET_OFFS			25
+#define DCO_CLK_DIV_RESET			(0x1 << DCO_CLK_DIV_RESET_OFFS)
+
+/* DCO clock ratio is 24Mhz/x */
+#define DCO_CLK_DIV_RATIO_OFFS			26
+#define DCO_CLK_DIV_RATIO_MASK			0xfc000000
+#define DCO_CLK_DIV_RATIO_8M			(0x3 << DCO_CLK_DIV_RATIO_OFFS)
+#define DCO_CLK_DIV_RATIO_4M			(0x6 << DCO_CLK_DIV_RATIO_OFFS)
+#define DCO_CLK_DIV_RATIO_2M			(0xc << DCO_CLK_DIV_RATIO_OFFS)
+
+/* TDM PLL configuration registers */
+#define TDM_PLL_CONF_REG0			0x0
+#define TDM_PLL_FB_CLK_DIV_OFFSET		10
+#define TDM_PLL_FB_CLK_DIV_MASK			0x7fc00
+
+#define TDM_PLL_CONF_REG1			0x4
+#define TDM_PLL_FREQ_OFFSET_MASK		0xffff
+#define TDM_PLL_FREQ_OFFSET_VALID		BIT16
+#define TDM_PLL_SW_RESET			BIT31
+
+#define TDM_PLL_CONF_REG2			0x8
+#define TDM_PLL_POSTDIV_MASK			0x7f
+
+/* Debug-trace stub */
+#define TRC_INIT(...)
+#define TRC_RELEASE(...)
+#define TRC_START(...)
+#define TRC_STOP(...)
+#define TRC_REC(...)
+#define TRC_OUTPUT(...)
+
+struct mv_phone_dev {
+	void __iomem *tdm_base;
+	void __iomem *pll_base;
+	void __iomem *dco_div_reg;
+	MV_TDM_PARAMS *tdm_params;
+	struct platform_device *parent;
+	struct device_node *np;
+	struct clk *clk;
+	u32 pclk_freq_mhz;
+	int irq;
+};
+
+/* This enumerator defines the Marvell Units ID */
+typedef enum {
+	SLIC_EXTERNAL_ID,
+	SLIC_ZARLINK_ID,
+	SLIC_SILABS_ID,
+	SLIC_LANTIQ_ID
+} MV_SLIC_UNIT_TYPE;
+
+typedef enum {
+	MV_TDM_UNIT_NONE,
+	MV_TDM_UNIT_TDM2C,
+	MV_TDM_UNIT_TDMMC
+} MV_TDM_UNIT_TYPE;
+
+enum {
+	SPI_TYPE_FLASH = 0,
+	SPI_TYPE_SLIC_ZARLINK_SILABS,
+	SPI_TYPE_SLIC_LANTIQ,
+	SPI_TYPE_SLIC_ZSI,
+	SPI_TYPE_SLIC_ISI
+};
+
+typedef enum _devBoardSlicType {
+	MV_BOARD_SLIC_DISABLED,
+	MV_BOARD_SLIC_SSI_ID, /* Lantiq Integrated SLIC */
+	MV_BOARD_SLIC_ISI_ID, /* Silicon Labs ISI Bus */
+	MV_BOARD_SLIC_ZSI_ID, /* Zarlink ZSI Bus */
+	MV_BOARD_SLIC_EXTERNAL_ID /* Cross vendor external SLIC */
+} MV_BOARD_SLIC_TYPE;
+
+/* Declarations */
+u32 mvBoardSlicUnitTypeGet(void);
+u32 mvCtrlTdmUnitIrqGet(void);
+MV_TDM_UNIT_TYPE mvCtrlTdmUnitTypeGet(void);
+int mvSysTdmInit(MV_TDM_PARAMS *tdmParams);
+
+#endif /* __INCmvSysTdmConfigh */
diff --git a/drivers/telephony/mvebu_phone/mvTypes.h b/drivers/telephony/mvebu_phone/mvTypes.h
new file mode 100644
index 0000000..f0f70c9
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mvTypes.h
@@ -0,0 +1,270 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvTypesh
+#define __INCmvTypesh
+
+/* Defines */
+
+/* The following is a list of Marvell status    */
+#define MV_ERROR		    (-1)
+#define MV_OK			    (0)	/* Operation succeeded                   */
+#define MV_FAIL			    (1)	/* Operation failed                      */
+#define MV_BAD_VALUE        (2)	/* Illegal value (general)               */
+#define MV_OUT_OF_RANGE     (3)	/* The value is out of range             */
+#define MV_BAD_PARAM        (4)	/* Illegal parameter in function called  */
+#define MV_BAD_PTR          (5)	/* Illegal pointer value                 */
+#define MV_BAD_SIZE         (6)	/* Illegal size                          */
+#define MV_BAD_STATE        (7)	/* Illegal state of state machine        */
+#define MV_SET_ERROR        (8)	/* Set operation failed                  */
+#define MV_GET_ERROR        (9)	/* Get operation failed                  */
+#define MV_CREATE_ERROR     (10)	/* Fail while creating an item           */
+#define MV_NOT_FOUND        (11)	/* Item not found                        */
+#define MV_NO_MORE          (12)	/* No more items found                   */
+#define MV_NO_SUCH          (13)	/* No such item                          */
+#define MV_TIMEOUT          (14)	/* Time Out                              */
+#define MV_NO_CHANGE        (15)	/* Parameter(s) is already in this value */
+#define MV_NOT_SUPPORTED    (16)	/* This request is not support           */
+#define MV_NOT_IMPLEMENTED  (17)	/* Request supported but not implemented */
+#define MV_NOT_INITIALIZED  (18)	/* The item is not initialized           */
+#define MV_NO_RESOURCE      (19)	/* Resource not available (memory ...)   */
+#define MV_FULL             (20)	/* Item is full (Queue or table etc...)  */
+#define MV_EMPTY            (21)	/* Item is empty (Queue or table etc...) */
+#define MV_INIT_ERROR       (22)	/* Error occured while INIT process      */
+#define MV_HW_ERROR         (23)	/* Hardware error                        */
+#define MV_TX_ERROR         (24)	/* Transmit operation not succeeded      */
+#define MV_RX_ERROR         (25)	/* Recieve operation not succeeded       */
+#define MV_NOT_READY	    (26)	/* The other side is not ready yet       */
+#define MV_ALREADY_EXIST    (27)	/* Tried to create existing item         */
+#define MV_OUT_OF_CPU_MEM   (28)	/* Cpu memory allocation failed.         */
+#define MV_NOT_STARTED      (29)	/* Not started yet                       */
+#define MV_BUSY             (30)	/* Item is busy.                         */
+#define MV_TERMINATE        (31)	/* Item terminates it's work.            */
+#define MV_NOT_ALIGNED      (32)	/* Wrong alignment                       */
+#define MV_NOT_ALLOWED      (33)	/* Operation NOT allowed                 */
+#define MV_WRITE_PROTECT    (34)	/* Write protected                       */
+#define MV_DROPPED          (35)	/* Packet dropped                        */
+#define MV_STOLEN           (36)	/* Packet stolen */
+#define MV_CONTINUE         (37)        /* Continue */
+#define MV_RETRY		    (38)	/* Operation failed need retry           */
+
+#define MV_INVALID  (int)(-1)
+
+#define MV_FALSE	0
+#define MV_TRUE     (!(MV_FALSE))
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#ifndef MV_ASMLANGUAGE
+/* typedefs */
+
+typedef char MV_8;
+typedef unsigned char MV_U8;
+
+typedef int MV_32;
+typedef unsigned int MV_U32;
+
+typedef short MV_16;
+typedef unsigned short MV_U16;
+
+#ifdef MV_PPC64
+typedef long MV_64;
+typedef unsigned long MV_U64;
+#else
+typedef long long MV_64;
+typedef unsigned long long MV_U64;
+#endif
+
+typedef long MV_LONG;		/* 32/64 */
+typedef unsigned long MV_ULONG;	/* 32/64 */
+
+typedef int MV_STATUS;
+typedef int MV_BOOL;
+typedef void MV_VOID;
+typedef float MV_FLOAT;
+
+typedef int (*MV_FUNCPTR) (void);	/* ptr to function returning int   */
+typedef void (*MV_VOIDFUNCPTR) (void);	/* ptr to function returning void  */
+typedef double (*MV_DBLFUNCPTR) (void);	/* ptr to function returning double */
+typedef float (*MV_FLTFUNCPTR) (void);	/* ptr to function returning float */
+
+typedef MV_U32 MV_KHZ;
+typedef MV_U32 MV_MHZ;
+typedef MV_U32 MV_HZ;
+
+/* This enumerator describes the set of commands that can be applied on		*/
+/* an engine (e.g. IDMA, XOR). Appling a comman depends on the current		*/
+/* status (see MV_STATE enumerator)						*/
+/* Start can be applied only when status is IDLE				*/
+/* Stop can be applied only when status is IDLE, ACTIVE or PAUSED		*/
+/* Pause can be applied only when status is ACTIVE				*/
+/* Restart can be applied only when status is PAUSED				*/
+typedef enum _mvCommand {
+	MV_START,		/* Star */
+	MV_STOP,		/* Stop */
+	MV_PAUSE,		/* Pause */
+	MV_RESTART		/* Restart */
+} MV_COMMAND;
+
+/* This enumerator describes the set of state conditions.					*/
+/* Moving from one state to other is stricted.							*/
+typedef enum _mvState {
+	MV_IDLE,
+	MV_ACTIVE,
+	MV_PAUSED,
+	MV_UNDEFINED_STATE
+} MV_STATE;
+
+typedef enum {
+	ETH_MAC_SPEED_10M,
+	ETH_MAC_SPEED_100M,
+	ETH_MAC_SPEED_1000M,
+	ETH_MAC_SPEED_AUTO
+
+} MV_ETH_MAC_SPEED;
+
+/* This structure describes address space window. Window base can be        */
+/* 64 bit, window size up to 4GB                                            */
+typedef struct _mvAddrWin {
+	MV_U32 baseLow;		/* 32bit base low       */
+	MV_U32 baseHigh;	/* 32bit base high      */
+	MV_U64 size;		/* 64bit size           */
+} MV_ADDR_WIN;
+
+/* This binary enumerator describes protection attribute status		*/
+typedef enum _mvProtRight {
+	ALLOWED,		/* Protection attribute allowed		*/
+	FORBIDDEN		/* Protection attribute forbidden	*/
+} MV_PROT_RIGHT;
+
+/* Unified struct for Rx and Tx packet operations. The user is required to	*/
+/* be familier only with Tx/Rx descriptor command status.			*/
+typedef struct _bufInfo {
+	MV_U32 cmdSts;		/* Tx/Rx command status			*/
+	MV_U16 byteCnt;		/* Size of valid data in the buffer	*/
+	MV_U16 bufSize;		/* Total size of the buffer		*/
+	MV_U8 *pBuff;		/* Pointer to Buffer			*/
+	MV_U8 *pData;		/* Pointer to data in the Buffer	*/
+	MV_U32 userInfo1;	/* Tx/Rx attached user information 1	*/
+	MV_U32 userInfo2;	/* Tx/Rx attached user information 2	*/
+	struct _bufInfo *pNextBufInfo;	/* Next buffer in packet	*/
+} BUF_INFO;
+
+/* This structure contains information describing one of buffers
+ * (fragments) they are built Ethernet packet.
+ */
+typedef struct {
+	MV_U8 *bufVirtPtr;
+	MV_ULONG bufPhysAddr;
+	MV_U32 bufSize;
+	MV_U32 dataSize;
+	MV_U32 memHandle;
+	MV_32 bufAddrShift;
+} MV_BUF_INFO;
+
+/* This structure contains information describing Ethernet packet.
+ * The packet can be divided for few buffers (fragments)
+ */
+typedef struct {
+	MV_ULONG osInfo;
+	MV_BUF_INFO *pFrags;
+	MV_U32 status;
+	MV_U16 pktSize;
+	MV_U16 numFrags;
+	MV_U32 ownerId;
+	MV_U32 fragIP;
+	MV_U32 txq;
+} MV_PKT_INFO;
+
+/* This structure describes SoC units address decode window	*/
+typedef struct {
+	MV_ADDR_WIN addrWin;	/* An address window */
+	MV_BOOL enable;		/* Address decode window is enabled/disabled    */
+	MV_U8 attrib;		/* chip select attributes */
+	MV_U8 targetId;		/* Target Id of this MV_TARGET */
+} MV_UNIT_WIN_INFO;
+
+/* This structure describes access rights for Access protection windows     */
+/* that can be found in IDMA, XOR, Ethernet and MPSC units.                 */
+/* Note that the permission enumerator coresponds to its register format.   */
+/* For example, Read only premission is presented as "1" in register field. */
+typedef enum _mvAccessRights {
+	NO_ACCESS_ALLOWED = 0,	/* No access allowed            */
+	READ_ONLY = 1,		/* Read only permission         */
+	ACC_RESERVED = 2,	/* Reserved access right                */
+	FULL_ACCESS = 3,	/* Read and Write permission    */
+	MAX_ACC_RIGHTS
+} MV_ACCESS_RIGHTS;
+
+typedef struct _mvDecRegs {
+	MV_U32 baseReg;
+	MV_U32 baseRegHigh;
+	MV_U32 ctrlReg;
+} MV_DEC_REGS;
+
+#endif /* MV_ASMLANGUAGE */
+
+#endif /* __INCmvTypesh */
diff --git a/drivers/telephony/mvebu_phone/mv_phone/Kconfig b/drivers/telephony/mvebu_phone/mv_phone/Kconfig
new file mode 100644
index 0000000..82f7ea2
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/Kconfig
@@ -0,0 +1,6 @@
+menu "SoC Telephony support"
+	depends on MV_INCLUDE_TDM
+
+	comment "See under:  Staging drivers -> Telephony support -> Marvell Telephony Options"
+
+endmenu
diff --git a/drivers/telephony/mvebu_phone/mv_phone/Makefile b/drivers/telephony/mvebu_phone/mv_phone/Makefile
new file mode 100644
index 0000000..20191e7
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/Makefile
@@ -0,0 +1,81 @@
+#
+# Makefile for the Marvell Phone Device Driver
+#
+#
+
+ifneq ($(CONFIG_ARCH_MVEBU),y)
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
+
+VB_SRC_PATH = ../../mv_hal/voiceband
+else
+VB_SRC_PATH = ../voiceband
+endif
+LSP_TAL_PATH = tal
+LSP_SPI_PATH = spi
+LSP_SLIC_PATH = slic
+LSP_TDM_PATH = tdm
+LSP_DFEV_PATH = dfev
+
+obj-$(CONFIG_MV_INCLUDE_TDM) += mv_phone.o
+
+# TAL
+PHONE_OBJS = $(LSP_TAL_PATH)/tal.o $(LSP_TAL_PATH)/tal_dev.o
+
+ifneq ($(CONFIG_ARCH_MVEBU),y)
+# TDM HAL
+PHONE_OBJS += ../../../../../$(MACHINE)/mv_hal_if/mvSysTdm.o
+endif
+
+# SPI and SLIC, always compile SPI and all SLIC in none DFEV mode
+ifneq ($(MV_LANTIQ_DFEV_SUPPORT),y)
+	PHONE_OBJS += $(LSP_SPI_PATH)/spi_dev.o
+	PHONE_OBJS += $(LSP_SLIC_PATH)/drv_dxt_if.o
+	PHONE_OBJS += $(LSP_SLIC_PATH)/silabs_if.o
+	PHONE_OBJS += $(LSP_SLIC_PATH)/zarlink_if.o
+endif
+
+ifeq ($(CONFIG_ARCH_MVEBU),y)
+	PHONE_OBJS += ../mv_phone_dev.o
+	PHONE_OBJS += ../mv_phone_spi.o
+
+	ccflags-y += $(MVEBU_PHONE_FLAGS)
+	ccflags-y += $(INCLUDE_DIRS)
+endif
+
+# TDM2C support
+ifeq ($(CONFIG_MV_TDM2C_SUPPORT),y)
+ifneq ($(CONFIG_ARCH_MVEBU),y)
+	PHONE_OBJS += $(VB_SRC_PATH)/tdm/mvTdmAddrDec.o
+endif
+	PHONE_OBJS += $(VB_SRC_PATH)/tdm/mvTdm.o
+	PHONE_OBJS += $(LSP_TDM_PATH)/tdm_if.o
+endif
+
+# TDMMC support
+ifeq ($(CONFIG_MV_TDMMC_SUPPORT),y)
+	PHONE_OBJS += $(VB_SRC_PATH)/commUnit/mvCommUnit.o $(VB_SRC_PATH)/commUnit/mvCommUnitAddrDec.o
+	PHONE_OBJS += $(LSP_TDM_PATH)/tdm_if.o
+endif
+
+# DFEV support
+ifeq ($(CONFIG_MV_LANTIQ_DFEV_SUPPORT),y)
+	IPC_DFEV_MODE = SMP
+ifeq ($(CONFIG_MV_IPC_LINUX_DRIVER),y)
+	IPC_DFEV_MODE = AMP
+endif
+ifeq ($(CONFIG_MV_IPC_FREERTOS_DRIVER),y)
+	IPC_DFEV_MODE = AMP
+endif
+	PHONE_OBJS += $(LSP_SLIC_PATH)/sdd_if.o
+	PHONE_OBJS += $(LSP_DFEV_PATH)/dfev_if.o
+ifeq ($(IPC_DFEV_MODE),AMP)
+	PHONE_OBJS += $(LSP_DFEV_PATH)/ipc_dfev.o
+else
+	PHONE_OBJS += $(LSP_DFEV_PATH)/ipc_dfev_smp.o
+endif
+endif
+
+mv_phone-objs := $(PHONE_OBJS)
+obj-y := mv_phone.o
diff --git a/drivers/telephony/mvebu_phone/mv_phone/dfev/dfev_if.c b/drivers/telephony/mvebu_phone/mv_phone/dfev/dfev_if.c
new file mode 100644
index 0000000..d3754ec
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/dfev/dfev_if.c
@@ -0,0 +1,221 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <plat/ipc_dfev.h>
+#include "../tal/tal.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include <plat/sdd_if.h>
+
+static struct ipc_dfev_data_handle *ipc_handle;
+static int pcm_active;
+static int wideband;
+static int dfev_init;
+static unsigned int rx_miss;
+static unsigned int tx_miss;
+static unsigned int rx_over;
+static unsigned int tx_under;
+
+static void dfev_if_rx_callback(struct ipc_dfev_data_msg *msg)
+{
+	if (pcm_active) {
+		tal_mmp_rx((unsigned char *)msg->samples, sizeof(msg->samples));
+		if (ipc_dfev_send_rx(ipc_handle, msg)) {
+			pr_err("%s(): Data RX message lost!\n", __func__);
+			ipc_dfev_data_msg_put(ipc_handle, msg);
+		}
+	} else {
+		ipc_dfev_data_msg_put(ipc_handle, msg);
+	}
+}
+
+static void dfev_if_tx_callback(struct ipc_dfev_data_msg *msg)
+{
+	if (pcm_active) {
+		tal_mmp_tx((unsigned char *)msg->samples, sizeof(msg->samples));
+		if (ipc_dfev_send_tx(ipc_handle, msg)) {
+			pr_err("%s(): Data TX message lost!\n", __func__);
+			ipc_dfev_data_msg_put(ipc_handle, msg);
+		}
+	} else {
+		ipc_dfev_data_msg_put(ipc_handle, msg);
+	}
+}
+
+static struct ipc_dfev_data_ops dfev_if_data_ops = {
+	.ipc_dfev_rx_callback		= dfev_if_rx_callback,
+	.ipc_dfev_tx_callback		= dfev_if_tx_callback,
+};
+
+static MV_STATUS dfev_if_init(tal_params_t *tal_params)
+{
+	if (tal_params->total_lines != 2)
+		return MV_ERROR;
+
+
+	switch (tal_params->pcm_format) {
+	case TAL_PCM_FORMAT_1BYTE:
+		wideband = 0;
+		break;
+	case TAL_PCM_FORMAT_2BYTES:
+		wideband = 0;
+		break;
+	case TAL_PCM_FORMAT_4BYTES:
+		wideband = 1;
+		break;
+	default:
+		return MV_ERROR;
+	}
+
+	ipc_handle = ipc_dfev_data_init(IPC_DFEV_MODE_INTERRUPT, &dfev_if_data_ops);
+	if (ipc_handle == NULL)
+		return MV_ERROR;
+
+	dfev_init = 1;
+	return MV_OK;
+}
+
+static void dfev_if_exit(void)
+{
+	ipc_dfev_data_exit(ipc_handle);
+
+	dfev_init = 0;
+}
+
+static void dfev_if_pcm_start(void)
+{
+	struct ipc_dfev_data_msg *msg[4];
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(msg); i++) {
+		msg[i] = ipc_dfev_data_msg_get(ipc_handle);
+		if (!msg[i]) {
+			pr_err("%s(): Data message allocation error!\n", __func__);
+			break;
+		}
+
+		msg[i]->wideband = wideband;
+		memset(msg[i]->samples, 0, sizeof(msg[i]->samples));
+	}
+
+	pcm_active = 1;
+
+	ipc_dfev_send_rx(ipc_handle, msg[1]);
+	ipc_dfev_send_tx(ipc_handle, msg[0]);
+
+	dfev_if_rx_callback(msg[2]);
+	dfev_if_tx_callback(msg[3]);
+}
+
+static void dfev_if_pcm_stop(void)
+{
+	pcm_active = 0;
+}
+
+void dfev_if_stats_get(tal_stats_t *dfev_if_stats)
+{
+	if (dfev_init == 0)
+		return;
+
+	dfev_if_stats->tdm_init = dfev_init;
+	dfev_if_stats->rx_miss = rx_miss;
+	dfev_if_stats->tx_miss = tx_miss;
+	dfev_if_stats->rx_over = rx_over;
+	dfev_if_stats->tx_under = tx_under;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	memset(&dfev_if_stats->tdm_ext_stats, 0, sizeof(MV_TDM_EXTENDED_STATS));
+#endif
+	return;
+}
+
+static tal_if_t dfev_if = {
+	.init		= dfev_if_init,
+	.exit		= dfev_if_exit,
+	.pcm_start	= dfev_if_pcm_start,
+	.pcm_stop	= dfev_if_pcm_stop,
+	.stats_get	= dfev_if_stats_get,
+};
+
+static int __init dfev_if_module_init(void)
+{
+	if (MV_TDM_UNIT_DFEV == mvCtrlTdmUnitTypeGet())
+		tal_set_if(&dfev_if);
+	return 0;
+}
+
+static void __exit dfev_if_module_exit(void)
+{
+	if (MV_TDM_UNIT_DFEV == mvCtrlTdmUnitTypeGet())
+		tal_set_if(NULL);
+	return;
+}
+
+/* Module stuff */
+module_init(dfev_if_module_init);
+module_exit(dfev_if_module_exit);
+MODULE_DESCRIPTION("Marvell DFEV I/F Device Driver - www.marvell.com");
+MODULE_AUTHOR("Piotr Ziecik <kosmo@semihalf.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/telephony/mvebu_phone/mv_phone/dfev/ipc_dfev.c b/drivers/telephony/mvebu_phone/mv_phone/dfev/ipc_dfev.c
new file mode 100644
index 0000000..ea5e558
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/dfev/ipc_dfev.c
@@ -0,0 +1,598 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/workqueue.h>
+#include <plat/ipc_dfev.h>
+
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvStack.h"
+#include "mvIpc.h"
+#include "mv_ipc/linux_amp/mv_ipc_os.h"
+#include "mv_ipc/linux_amp/mv_ipc_common.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+#define ipc_attach_chn(linkId, chnId, cpu, ret)	mvIpcAttachChannel(linkId, chnId, cpu, ret)
+#define ipc_dettach_chn(linkId, chnId)		mvIpcDettachChannel(linkId, chnId)
+#define ipc_close_chn(linkId, chnId)		mvIpcCloseChannel(linkId, chnId)
+#define ipc_tx_msg(linkId, chnId, msg)		mvIpcTxMsg(linkId, chnId, msg)
+#define ipc_rx_msg(linkId, chnId)		mvIpcRxMsg(linkId, chnId)
+#define ipc_tx_ready(linkId, chnId)		mvIpcIsTxReady(linkId, chnId)
+#define ipc_release_msg(linkId, chnId, msg)	mvIpcReleaseMsg(linkId, chnId, msg)
+#define ipc_sh_malloc(linkId, size)		mvIpcShmemMalloc(linkId, size)
+#define ipc_open_chn(linkId, chnId, rx_clbk)	mvIpcOpenChannel(linkId, chnId, rx_clbk)
+#define ipc_enable_chn_rx(linkId, chnId)	mvIpcEnableChnRx(linkId, chnId)
+#define ipc_disable_chn_rx(linkId, chnId)	mvIpcDisableChnRx(linkId, chnId)
+#define ipc_virt_to_phys(linkId, virt_addr)	mvIpcOsVirt2Phys(linkId, virt_addr)
+#define ipc_phys_to_virt(linkId, phys_addr)	mvIpcOsPhys2Virt(linkId, phys_addr)
+
+#define IPC_DFEV_SLAVE_TO_MASTER_WAIT_TIME	1
+#define IPC_DFEV_SLAVE_TO_MASTER_WAIT_LOOPS	100
+
+/* IPC Identifiers */
+#define IPC_DFEV_LINK_ID		0
+#define IPC_DFEV_CTRL_CHAN_ID		0
+#define IPC_DFEV_DATA_TX_CHAN_ID	1
+#define IPC_DFEV_DATA_RX_CHAN_ID	2
+#define IPC_DFEV_DATA_RETURN_CHAN_ID	3
+
+/* Message type identifiers */
+#define IPC_DFEV_MSG_TYPE_COMMAND	0
+#define IPC_DFEV_MSG_TYPE_EVENT		1
+#define IPC_DFEV_MSG_TYPE_RX		2
+#define IPC_DFEV_MSG_TYPE_TX		3
+#define IPC_DFEV_MSG_TYPE_PRINT		4
+
+struct ipc_dfev_ctrl_buffer {
+	atomic_t			in_use;
+	struct ipc_dfev_ctrl_msg	msg;
+};
+
+struct ipc_dfev_ctrl_pool {
+	spinlock_t			lock;
+	unsigned int			idx;
+	struct ipc_dfev_ctrl_buffer	*fifo[IPC_DFEV_CTRL_BUFFERS];
+};
+
+struct ipc_dfev_data_buffer {
+	atomic_t			in_use;
+	struct ipc_dfev_data_msg	msg;
+};
+
+struct ipc_dfev_data_pool {
+	spinlock_t			lock;
+	unsigned int			idx;
+	struct ipc_dfev_data_buffer	*fifo[IPC_DFEV_DATA_BUFFERS];
+};
+
+static struct ipc_dfev_ctrl_handle {
+	int				dummy;
+} ipc_dfev_ctrl_handle;
+
+static struct ipc_dfev_data_handle {
+	int				dummy;
+} ipc_dfev_data_handle;
+
+static struct ipc_dfev_ctrl_ops *ipc_dfev_ctrl_ops;
+static struct ipc_dfev_data_ops *ipc_dfev_data_ops;
+
+static struct ipc_dfev_ctrl_pool ipc_dfev_ctrl_pool;
+static struct ipc_dfev_data_pool ipc_dfev_data_pool;
+
+static struct delayed_work ipc_dfev_linkup;
+
+#define ipc_dfev_init_pool(ch, perror)					\
+	do {								\
+		unsigned int i;						\
+									\
+		*(perror) = 0;						\
+		spin_lock_init(&(ch)->lock);				\
+									\
+		for (i = 0; i < ARRAY_SIZE((ch)->fifo); i++) {		\
+			(ch)->fifo[i] = ipc_sh_malloc(IPC_DFEV_LINK_ID,	\
+					     sizeof(*((ch)->fifo[i])));	\
+			if ((ch)->fifo[i] == NULL) {			\
+				*(perror) = -ENOMEM;			\
+				break;					\
+			}						\
+									\
+			atomic_set(&(ch)->fifo[i]->in_use, 0);		\
+		}							\
+	} while (0)
+
+#define ipc_dfev_get_buffer(ch, pbuffer)				\
+	do {								\
+		unsigned long flags;					\
+		unsigned int idx;					\
+									\
+		spin_lock_irqsave(&(ch)->lock, flags);			\
+									\
+		idx = (ch)->idx & (ARRAY_SIZE((ch)->fifo) - 1);		\
+		if (atomic_read(&(ch)->fifo[idx]->in_use) == 0) {	\
+			*(pbuffer) = (ch)->fifo[idx];			\
+			atomic_set(&(*(pbuffer))->in_use, 1);		\
+			(ch)->idx += 1;					\
+		}							\
+									\
+		spin_unlock_irqrestore(&(ch)->lock, flags);		\
+	} while (0)
+
+static void ipc_dfev_handshake(struct work_struct *dummy)
+{
+	unsigned int channels_to_attach = 4;
+	int attached;
+
+	ipc_attach_chn(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID,
+			mvIpcGetlinkRemoteNodeId(IPC_DFEV_LINK_ID), &attached);
+	if (attached)
+		channels_to_attach -= 1;
+
+	ipc_attach_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID,
+			mvIpcGetlinkRemoteNodeId(IPC_DFEV_LINK_ID), &attached);
+	if (attached)
+		channels_to_attach -= 1;
+
+	ipc_attach_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID,
+			mvIpcGetlinkRemoteNodeId(IPC_DFEV_LINK_ID), &attached);
+	if (attached)
+		channels_to_attach -= 1;
+
+	ipc_attach_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID,
+			mvIpcGetlinkRemoteNodeId(IPC_DFEV_LINK_ID), &attached);
+	if (attached)
+		channels_to_attach -= 1;
+
+	if (channels_to_attach != 0)
+		schedule_delayed_work(&ipc_dfev_linkup, HZ);
+}
+
+static int ipc_dfev_send(int type, int channel, void *message)
+{
+	MV_IPC_MSG msg;
+
+	msg.type = type;
+	msg.size = 0;
+	msg.ptr = ipc_virt_to_phys(IPC_DFEV_LINK_ID, message);
+
+	if (ipc_tx_msg(IPC_DFEV_LINK_ID, channel, &msg) != MV_OK)
+		return -EAGAIN;
+
+	return 0;
+}
+
+static int ipc_dfev_open_channel(MV_U32 linkId, MV_U32 chId,
+							MV_IPC_RX_CLBK rx_clbk)
+{
+	int attached, counter, status;
+
+	counter = 0;
+	do {
+		status = ipc_open_chn(linkId, chId, rx_clbk);
+		if (status == MV_NOT_STARTED) {
+			if (counter++ >= IPC_DFEV_SLAVE_TO_MASTER_WAIT_LOOPS)
+				return -ENODEV;
+			udelay(IPC_DFEV_SLAVE_TO_MASTER_WAIT_TIME);
+			continue;
+		}
+
+		if (status != MV_OK) {
+			pr_err("IPC DFEV: Failed to open IPC channel %d-%d\n",
+								linkId, chId);
+			return -ENODEV;
+		}
+	} while (status != MV_OK);
+
+	status = ipc_attach_chn(linkId, chId,
+				mvIpcGetlinkRemoteNodeId(linkId), &attached);
+	if (status != MV_OK) {
+		pr_err("IPC DFEV: Failed to attach IPC channel %d-%d\n",
+								linkId, chId);
+		ipc_close_chn(linkId, chId);
+		return -ENODEV;
+	}
+
+	ipc_enable_chn_rx(linkId, chId);
+
+	return 0;
+}
+
+/*
+ * Control Path API
+ */
+struct ipc_dfev_ctrl_handle *ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
+					struct ipc_dfev_ctrl_ops *ctrl_ops)
+{
+	if (ctrl_ops == NULL)
+		return NULL;
+
+	/* Wait for IPC link */
+	while (!ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID))
+		msleep(25);
+
+	switch (mode) {
+	case IPC_DFEV_MODE_INTERRUPT:
+		ipc_enable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
+		break;
+	case IPC_DFEV_MODE_POLLING:
+		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
+		break;
+	default:
+		return NULL;
+	}
+
+	ipc_dfev_ctrl_ops = ctrl_ops;
+
+	return &ipc_dfev_ctrl_handle;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_init);
+
+void ipc_dfev_ctrl_exit(struct ipc_dfev_ctrl_handle *handle)
+{
+	ipc_dfev_ctrl_ops = NULL;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_exit);
+
+int ipc_dfev_ctrl_poll(struct ipc_dfev_ctrl_handle *handle)
+{
+	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_poll);
+
+struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(struct ipc_dfev_ctrl_handle *handle)
+{
+	struct ipc_dfev_ctrl_buffer *buffer = NULL;
+
+	ipc_dfev_get_buffer(&ipc_dfev_ctrl_pool, &buffer);
+
+	if (!buffer)
+		return NULL;
+
+	return &buffer->msg;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_msg_get);
+
+void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+
+	buffer = container_of(msg, struct ipc_dfev_ctrl_buffer, msg);
+	atomic_set(&buffer->in_use, 0);
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_msg_put);
+
+int ipc_dfev_send_command(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_COMMAND, IPC_DFEV_CTRL_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_command);
+
+int ipc_dfev_send_event(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_EVENT, IPC_DFEV_CTRL_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_event);
+
+static int ipc_dfev_ctrl_msg_handler(MV_IPC_MSG *msg)
+{
+	struct ipc_dfev_ctrl_msg *message;
+
+	message = ipc_phys_to_virt(IPC_DFEV_LINK_ID, msg->ptr);
+
+	switch (msg->type) {
+	case IPC_DFEV_MSG_TYPE_COMMAND:
+		if (ipc_dfev_ctrl_ops && ipc_dfev_ctrl_ops->ipc_dfev_command_callback)
+			ipc_dfev_ctrl_ops->ipc_dfev_command_callback(message);
+		else
+			ipc_dfev_ctrl_msg_put(NULL, message);
+		break;
+	case IPC_DFEV_MSG_TYPE_EVENT:
+		if (ipc_dfev_ctrl_ops && ipc_dfev_ctrl_ops->ipc_dfev_event_callback)
+			ipc_dfev_ctrl_ops->ipc_dfev_event_callback(message);
+		else
+			ipc_dfev_ctrl_msg_put(NULL, message);
+		break;
+	case IPC_DFEV_MSG_TYPE_PRINT:
+		if (message->size)
+			printk(KERN_INFO "Dragonite: %s", message->payload);
+		ipc_dfev_ctrl_msg_put(NULL, message);
+		break;
+	default:
+		pr_err("IPC DFEV: Unknown ctrl message type %u!\n", msg->type);
+	}
+
+	ipc_release_msg(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID, msg);
+	return 0;
+}
+
+/*
+ * Data Path API
+ */
+struct ipc_dfev_data_handle *ipc_dfev_data_init(enum ipc_dfev_mode mode,
+					struct ipc_dfev_data_ops *data_ops)
+{
+	if (data_ops == NULL)
+		return NULL;
+
+	/* Wait for IPC link */
+	while (!ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID) ||
+	       !ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID) ||
+	       !ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID)) {
+		msleep(25);
+	}
+
+	switch (mode) {
+	case IPC_DFEV_MODE_INTERRUPT:
+		ipc_enable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
+		ipc_enable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
+		ipc_enable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
+		break;
+	case IPC_DFEV_MODE_POLLING:
+		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
+		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
+		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
+		break;
+	default:
+		return NULL;
+	}
+
+	ipc_dfev_data_ops = data_ops;
+	return &ipc_dfev_data_handle;
+}
+EXPORT_SYMBOL(ipc_dfev_data_init);
+
+void ipc_dfev_data_exit(struct ipc_dfev_data_handle *handle)
+{
+	ipc_dfev_data_ops = NULL;
+}
+EXPORT_SYMBOL(ipc_dfev_data_exit);
+
+struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(struct ipc_dfev_data_handle *handle)
+{
+	struct ipc_dfev_data_buffer *buffer = NULL;
+
+	ipc_dfev_get_buffer(&ipc_dfev_data_pool, &buffer);
+
+	if (!buffer)
+		return NULL;
+
+	return &buffer->msg;
+}
+EXPORT_SYMBOL(ipc_dfev_data_msg_get);
+
+void ipc_dfev_data_msg_put(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	atomic_set(&buffer->in_use, 0);
+}
+EXPORT_SYMBOL(ipc_dfev_data_msg_put);
+
+int ipc_dfev_send_tx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_TX, IPC_DFEV_DATA_TX_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_tx);
+
+int ipc_dfev_send_rx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_RX, IPC_DFEV_DATA_RX_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_rx);
+
+int ipc_dfev_send_tx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_TX, IPC_DFEV_DATA_RETURN_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_tx_return);
+
+int ipc_dfev_send_rx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_RX, IPC_DFEV_DATA_RETURN_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_rx_return);
+
+int ipc_dfev_data_poll_rx(struct ipc_dfev_data_handle *handle)
+{
+	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_rx);
+
+int ipc_dfev_data_poll_tx(struct ipc_dfev_data_handle *handle)
+{
+	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_tx);
+
+int ipc_dfev_data_poll_return(struct ipc_dfev_data_handle *handle)
+{
+	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_return);
+
+static void ipc_dfev_data_handler(MV_IPC_MSG *msg)
+{
+	struct ipc_dfev_data_msg *message;
+
+	message = ipc_phys_to_virt(IPC_DFEV_LINK_ID, msg->ptr);
+
+	switch (msg->type) {
+	case IPC_DFEV_MSG_TYPE_RX:
+		if (ipc_dfev_data_ops && ipc_dfev_data_ops->ipc_dfev_rx_callback)
+			ipc_dfev_data_ops->ipc_dfev_rx_callback(message);
+		else
+			ipc_dfev_data_msg_put(NULL, message);
+		break;
+	case IPC_DFEV_MSG_TYPE_TX:
+		if (ipc_dfev_data_ops && ipc_dfev_data_ops->ipc_dfev_tx_callback)
+			ipc_dfev_data_ops->ipc_dfev_tx_callback(message);
+		else
+			ipc_dfev_data_msg_put(NULL, message);
+		break;
+	default:
+		pr_err("IPC DFEV: Unknown data message type %u!\n", msg->type);
+	}
+}
+
+static int ipc_dfev_data_rx(MV_IPC_MSG *msg)
+{
+	ipc_dfev_data_handler(msg);
+	ipc_release_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID, msg);
+	return 0;
+}
+
+static int ipc_dfev_data_tx(MV_IPC_MSG *msg)
+{
+	ipc_dfev_data_handler(msg);
+	ipc_release_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID, msg);
+	return 0;
+}
+
+static int ipc_dfev_data_return(MV_IPC_MSG *msg)
+{
+	ipc_dfev_data_handler(msg);
+	ipc_release_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID, msg);
+	return 0;
+}
+
+static int __init ipc_dfev_init_module(void)
+{
+	int error;
+	int link;
+
+	if (MV_TDM_UNIT_DFEV != mvCtrlTdmUnitTypeGet())
+		return 0;
+
+	/* start link after IPC and dragonite modules are initialized, to make sure the dragonite DTCM accessable */
+	for (link = 0; link < mvIpcGetNumOfLinks(); link++) {
+		error = mvIpcLinkStart(link);
+		if (error != MV_OK) {
+			printk(KERN_ERR "IPC: IPC HAL %d initialization failed\n", 0);
+			return error;
+		}
+	}
+
+	/* Open Command Channel */
+	error = ipc_dfev_open_channel(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID, ipc_dfev_ctrl_msg_handler);
+	if (error)
+		goto error0;
+
+	/* Open Data Channels */
+	error = ipc_dfev_open_channel(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID, ipc_dfev_data_rx);
+	if (error)
+		goto error1;
+
+	error = ipc_dfev_open_channel(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID, ipc_dfev_data_tx);
+	if (error)
+		goto error2;
+
+	error = ipc_dfev_open_channel(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID, ipc_dfev_data_return);
+	if (error)
+		goto error3;
+
+	/* Allocate shared memory for command channel */
+	ipc_dfev_init_pool(&ipc_dfev_ctrl_pool, &error);
+	if (error) {
+		pr_err("IPC DFEV: Failed to allocate shared memory for IPC link %u\n", IPC_DFEV_LINK_ID);
+		goto error4;
+	}
+
+	/* Allocate shared memory for data channel */
+	ipc_dfev_init_pool(&ipc_dfev_data_pool, &error);
+	if (error) {
+		pr_err("IPC DFEV: Failed to allocate shared memory for IPC link %u!\n", IPC_DFEV_LINK_ID);
+		goto error4;
+	}
+
+	INIT_DELAYED_WORK(&ipc_dfev_linkup, ipc_dfev_handshake);
+	schedule_delayed_work(&ipc_dfev_linkup, HZ);
+
+	return 0;
+
+error4:
+	ipc_close_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
+error3:
+	ipc_close_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
+error2:
+	ipc_close_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
+error1:
+	ipc_close_chn(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
+error0:
+	return error;
+}
+
+static void __exit ipc_dfev_cleanup_module(void)
+{
+}
+
+module_init(ipc_dfev_init_module);
+module_exit(ipc_dfev_cleanup_module);
+MODULE_DESCRIPTION("Marvell Inter-Processor DFEV Communication Driver");
+MODULE_AUTHOR("Piotr Ziecik <kosmo@semihalf.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/telephony/mvebu_phone/mv_phone/dfev/ipc_dfev_smp.c b/drivers/telephony/mvebu_phone/mv_phone/dfev/ipc_dfev_smp.c
new file mode 100644
index 0000000..2279b65
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/dfev/ipc_dfev_smp.c
@@ -0,0 +1,544 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <plat/ipc_dfev.h>
+
+#define IPC_DFEV_FIFO_SIZE		16	/* must be power of 2 */
+
+#define IPC_DFEV_MSG_TYPE_COMMAND	0
+#define IPC_DFEV_MSG_TYPE_EVENT		1
+#define IPC_DFEV_MSG_TYPE_RX		2
+#define IPC_DFEV_MSG_TYPE_TX		3
+#define IPC_DFEV_MSG_TYPE_PRINT		4
+
+struct ipc_dfev_channel {
+	atomic_t	read_idx;
+	atomic_t	write_idx;
+	void		*fifo[IPC_DFEV_FIFO_SIZE];
+};
+
+static struct ipc_dfev_channel ctrl_dfev2host;
+static struct ipc_dfev_channel ctrl_host2dfev;
+
+static struct ipc_dfev_channel rx_dfev2host;
+static struct ipc_dfev_channel rx_host2dfev;
+
+static struct ipc_dfev_channel tx_dfev2host;
+static struct ipc_dfev_channel tx_host2dfev;
+
+static struct ipc_dfev_channel return_dfev2host;
+static struct ipc_dfev_channel return_host2dfev;
+
+static struct tasklet_struct ipc_dfev_tasklet;
+
+struct ipc_dfev_ctrl_buffer {
+	int				type;
+	struct ipc_dfev_ctrl_msg	msg;
+};
+
+struct ipc_dfev_ctrl_handle {
+	struct ipc_dfev_channel		*ctrl_rx;
+	struct ipc_dfev_channel		*ctrl_tx;
+
+	struct ipc_dfev_ctrl_ops	*ctrl_ops;
+	struct tasklet_struct		*tasklet;
+};
+
+static struct ipc_dfev_ctrl_handle ipc_dfev_ctrl_handle_dfev = {
+	.ctrl_rx	= &ctrl_host2dfev,
+	.ctrl_tx	= &ctrl_dfev2host,
+
+	.tasklet	= &ipc_dfev_tasklet,
+};
+
+static struct ipc_dfev_ctrl_handle ipc_dfev_ctrl_handle_host = {
+	.ctrl_rx	= &ctrl_dfev2host,
+	.ctrl_tx	= &ctrl_host2dfev,
+
+	.tasklet	= NULL,
+};
+
+struct ipc_dfev_data_buffer {
+	int				type;
+	struct ipc_dfev_data_msg	msg;
+};
+
+struct ipc_dfev_data_handle {
+	struct ipc_dfev_channel		*rx_rx;
+	struct ipc_dfev_channel		*rx_tx;
+
+	struct ipc_dfev_channel		*tx_rx;
+	struct ipc_dfev_channel		*tx_tx;
+
+	struct ipc_dfev_channel		*return_rx;
+	struct ipc_dfev_channel		*return_tx;
+
+	struct ipc_dfev_data_ops	*data_ops;
+	struct tasklet_struct		*tasklet;
+};
+
+static struct ipc_dfev_data_handle ipc_dfev_data_handle_dfev = {
+	.rx_rx		= &rx_host2dfev,
+	.rx_tx		= &rx_dfev2host,
+
+	.tx_rx		= &tx_host2dfev,
+	.tx_tx		= &tx_dfev2host,
+
+	.return_rx	= &return_host2dfev,
+	.return_tx	= &return_dfev2host,
+
+	.tasklet	= &ipc_dfev_tasklet,
+};
+
+static struct ipc_dfev_data_handle ipc_dfev_data_handle_host = {
+	.rx_rx		= &rx_dfev2host,
+	.rx_tx		= &rx_host2dfev,
+
+	.tx_rx		= &tx_dfev2host,
+	.tx_tx		= &tx_host2dfev,
+
+	.return_rx	= &return_dfev2host,
+	.return_tx	= &return_host2dfev,
+
+	.tasklet	= NULL,
+};
+
+static int ipc_dfev_channel_is_empty(struct ipc_dfev_channel *ch)
+{
+	BUG_ON(ch == NULL);
+	return ((atomic_read(&ch->write_idx) - atomic_read(&ch->read_idx)) == 0);
+}
+
+static int ipc_dfev_channel_is_full(struct ipc_dfev_channel *ch)
+{
+	BUG_ON(ch == NULL);
+	return ((atomic_read(&ch->write_idx) - atomic_read(&ch->read_idx)) >=
+						IPC_DFEV_FIFO_SIZE);
+}
+
+static int ipc_dfev_msg_put(struct ipc_dfev_channel *ch, void *msg)
+{
+	unsigned int idx;
+
+	if (ipc_dfev_channel_is_full(ch))
+		return -ENOMEM;
+
+	idx = atomic_read(&ch->write_idx) & (IPC_DFEV_FIFO_SIZE - 1);
+	ch->fifo[idx] = msg;
+	atomic_inc(&ch->write_idx);
+
+	return 0;
+}
+
+static void *ipc_dfev_msg_get(struct ipc_dfev_channel *ch)
+{
+	unsigned int idx;
+	void *msg;
+
+	if (ipc_dfev_channel_is_empty(ch))
+		return NULL;
+
+	idx = atomic_read(&ch->read_idx) & (IPC_DFEV_FIFO_SIZE - 1);
+	msg = ch->fifo[idx];
+	atomic_inc(&ch->read_idx);
+
+	return msg;
+}
+
+static void ipc_dfev_tasklet_func(unsigned long data)
+{
+	int again;
+
+	do {
+		again = 0;
+
+		if (ipc_dfev_ctrl_handle_host.ctrl_ops != NULL)
+			if (ipc_dfev_ctrl_poll(&ipc_dfev_ctrl_handle_host) == 0)
+				again = 1;
+
+		if (ipc_dfev_data_handle_host.data_ops != NULL) {
+			if (ipc_dfev_data_poll_rx(&ipc_dfev_data_handle_host) == 0)
+				again = 1;
+
+			if (ipc_dfev_data_poll_tx(&ipc_dfev_data_handle_host) == 0)
+				again = 1;
+
+			if (ipc_dfev_data_poll_return(&ipc_dfev_data_handle_host) == 0)
+				again = 1;
+		}
+	} while (again);
+}
+
+/*
+ * Control Path API
+ */
+struct ipc_dfev_ctrl_handle *ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
+					struct ipc_dfev_ctrl_ops *ctrl_ops)
+{
+	switch (mode) {
+	case IPC_DFEV_MODE_INTERRUPT:
+		/* Host side uses INTERRUPT mode */
+		ipc_dfev_ctrl_handle_host.ctrl_ops = ctrl_ops;
+		return &ipc_dfev_ctrl_handle_host;
+	case IPC_DFEV_MODE_POLLING:
+		/* DFEV side uses POLLING mode */
+		ipc_dfev_ctrl_handle_dfev.ctrl_ops = ctrl_ops;
+		return &ipc_dfev_ctrl_handle_dfev;
+	default:
+		return NULL;
+	}
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_init);
+
+void ipc_dfev_ctrl_exit(struct ipc_dfev_ctrl_handle *handle)
+{
+	handle->ctrl_ops = NULL;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_exit);
+
+int ipc_dfev_ctrl_poll(struct ipc_dfev_ctrl_handle *handle)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+	void *msg;
+
+	msg = ipc_dfev_msg_get(handle->ctrl_rx);
+	if (!msg)
+		return -ENOMSG;
+
+	buffer = container_of(msg, struct ipc_dfev_ctrl_buffer, msg);
+	switch (buffer->type) {
+	case IPC_DFEV_MSG_TYPE_COMMAND:
+		if (handle->ctrl_ops && handle->ctrl_ops->ipc_dfev_command_callback)
+			handle->ctrl_ops->ipc_dfev_command_callback(msg);
+		else
+			ipc_dfev_ctrl_msg_put(handle, msg);
+		break;
+	case IPC_DFEV_MSG_TYPE_EVENT:
+		if (handle->ctrl_ops && handle->ctrl_ops->ipc_dfev_event_callback)
+			handle->ctrl_ops->ipc_dfev_event_callback(msg);
+		else
+			ipc_dfev_ctrl_msg_put(handle, msg);
+		break;
+	default:
+		pr_err("IPC DFEV: Unknown ctrl message type %u!\n", buffer->type);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_poll);
+
+struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(struct ipc_dfev_ctrl_handle *handle)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+
+	buffer = kmalloc(sizeof(struct ipc_dfev_ctrl_buffer), GFP_ATOMIC);
+	if (!buffer)
+		return NULL;
+
+	return &buffer->msg;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_msg_get);
+
+void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	kfree(container_of(msg, struct ipc_dfev_ctrl_buffer, msg));
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_msg_put);
+
+int ipc_dfev_send_command(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_ctrl_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_COMMAND;
+
+	retval = ipc_dfev_msg_put(handle->ctrl_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+}
+EXPORT_SYMBOL(ipc_dfev_send_command);
+
+int ipc_dfev_send_event(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_ctrl_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_EVENT;
+
+	retval = ipc_dfev_msg_put(handle->ctrl_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+
+}
+EXPORT_SYMBOL(ipc_dfev_send_event);
+
+/*
+ * Data Path API
+ */
+struct ipc_dfev_data_handle *ipc_dfev_data_init(enum ipc_dfev_mode mode,
+					struct ipc_dfev_data_ops *data_ops)
+{
+	switch (mode) {
+	case IPC_DFEV_MODE_INTERRUPT:
+		/* Host side uses INTERRUPT mode */
+		ipc_dfev_data_handle_host.data_ops = data_ops;
+		return &ipc_dfev_data_handle_host;
+	case IPC_DFEV_MODE_POLLING:
+		/* DFEV side uses POLLING mode */
+		ipc_dfev_data_handle_dfev.data_ops = data_ops;
+		return &ipc_dfev_data_handle_dfev;
+	default:
+		return NULL;
+	}
+}
+EXPORT_SYMBOL(ipc_dfev_data_init);
+
+void ipc_dfev_data_exit(struct ipc_dfev_data_handle *handle)
+{
+	handle->data_ops = NULL;
+}
+EXPORT_SYMBOL(ipc_dfev_data_exit);
+
+struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(struct ipc_dfev_data_handle *handle)
+{
+	struct ipc_dfev_data_buffer *buffer;
+
+	buffer = kmalloc(sizeof(struct ipc_dfev_data_buffer), GFP_ATOMIC);
+	if (!buffer)
+		return NULL;
+
+	return &buffer->msg;
+}
+EXPORT_SYMBOL(ipc_dfev_data_msg_get);
+
+void ipc_dfev_data_msg_put(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	kfree(container_of(msg, struct ipc_dfev_data_buffer, msg));
+}
+EXPORT_SYMBOL(ipc_dfev_data_msg_put);
+
+int ipc_dfev_send_tx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_TX;
+
+	retval = ipc_dfev_msg_put(handle->tx_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+
+}
+EXPORT_SYMBOL(ipc_dfev_send_tx);
+
+int ipc_dfev_send_rx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_RX;
+
+	retval = ipc_dfev_msg_put(handle->rx_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+}
+EXPORT_SYMBOL(ipc_dfev_send_rx);
+
+int ipc_dfev_send_tx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_TX;
+
+	retval = ipc_dfev_msg_put(handle->return_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+}
+EXPORT_SYMBOL(ipc_dfev_send_tx_return);
+
+int ipc_dfev_send_rx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+	int retval;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	buffer->type = IPC_DFEV_MSG_TYPE_RX;
+
+	retval = ipc_dfev_msg_put(handle->return_tx, msg);
+
+	if (handle->tasklet)
+		tasklet_schedule(handle->tasklet);
+
+	return retval;
+}
+EXPORT_SYMBOL(ipc_dfev_send_rx_return);
+
+static void ipc_dfev_data_handle_msg(struct ipc_dfev_data_handle *handle,
+						struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	switch (buffer->type) {
+	case IPC_DFEV_MSG_TYPE_RX:
+		if (handle->data_ops && handle->data_ops->ipc_dfev_rx_callback)
+			handle->data_ops->ipc_dfev_rx_callback(msg);
+		else
+			ipc_dfev_data_msg_put(handle, msg);
+		break;
+	case IPC_DFEV_MSG_TYPE_TX:
+		if (handle->data_ops && handle->data_ops->ipc_dfev_tx_callback)
+			handle->data_ops->ipc_dfev_tx_callback(msg);
+		else
+			ipc_dfev_data_msg_put(handle, msg);
+		break;
+	default:
+		pr_err("IPC DFEV: Unknown data message type %u!\n", buffer->type);
+	}
+}
+
+int ipc_dfev_data_poll_rx(struct ipc_dfev_data_handle *handle)
+{
+	void *msg;
+
+	msg = ipc_dfev_msg_get(handle->rx_rx);
+	if (!msg)
+		return -ENOMSG;
+
+	ipc_dfev_data_handle_msg(handle, msg);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_rx);
+
+int ipc_dfev_data_poll_tx(struct ipc_dfev_data_handle *handle)
+{
+	void *msg;
+
+	msg = ipc_dfev_msg_get(handle->tx_rx);
+	if (!msg)
+		return -ENOMSG;
+
+	ipc_dfev_data_handle_msg(handle, msg);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_tx);
+
+int ipc_dfev_data_poll_return(struct ipc_dfev_data_handle *handle)
+{
+	void *msg;
+
+	msg = ipc_dfev_msg_get(handle->return_rx);
+	if (!msg)
+		return -ENOMSG;
+
+	ipc_dfev_data_handle_msg(handle, msg);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_return);
+
+static int __init ipc_dfev_init_module(void)
+{
+	tasklet_init(&ipc_dfev_tasklet, ipc_dfev_tasklet_func, 0);
+
+	return 0;
+}
+
+static void __exit ipc_dfev_cleanup_module(void)
+{
+	tasklet_kill(&ipc_dfev_tasklet);
+}
+
+module_init(ipc_dfev_init_module);
+module_exit(ipc_dfev_cleanup_module);
+MODULE_DESCRIPTION("Marvell Inter-Processor DFEV Communication Driver");
+MODULE_AUTHOR("Piotr Ziecik <kosmo@semihalf.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/telephony/mvebu_phone/mv_phone/slic/drv_dxt_if.c b/drivers/telephony/mvebu_phone/mv_phone/slic/drv_dxt_if.c
new file mode 100644
index 0000000..1fbe61d
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/slic/drv_dxt_if.c
@@ -0,0 +1,165 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <plat/drv_dxt_if.h>
+#ifndef CONFIG_OF
+#include "spi/mvSpi.h"
+#endif
+#include "voiceband/mvSysTdmSpi.h"
+
+static int drv_dxt_spi_cs;
+static int drv_dxt_irq;
+static void *drv_dxt_irq_dev;
+static irq_handler_t drv_dxt_irq_handler;
+
+void
+drv_dxt_if_signal_interrupt(void)
+{
+	if (drv_dxt_irq_handler == NULL)
+		return;
+
+	drv_dxt_irq_handler(drv_dxt_irq, drv_dxt_irq_dev);
+}
+
+void
+drv_dxt_if_enable_irq(unsigned int irq)
+{
+	/* We have only one TDM channel */
+	mvSysTdmIntEnable(0);
+}
+EXPORT_SYMBOL(drv_dxt_if_enable_irq);
+
+void
+drv_dxt_if_disable_irq(unsigned int irq)
+{
+	/* We have only one TDM channel */
+	mvSysTdmIntDisable(0);
+}
+EXPORT_SYMBOL(drv_dxt_if_disable_irq);
+
+int
+drv_dxt_if_request_irq(unsigned int irq, irq_handler_t handler,
+			unsigned long flags, const char *name, void *dev)
+{
+	drv_dxt_irq = irq;
+	drv_dxt_irq_dev = dev;
+	drv_dxt_irq_handler = handler;
+
+	return 0;
+}
+EXPORT_SYMBOL(drv_dxt_if_request_irq);
+
+void
+drv_dxt_if_free_irq(unsigned int irq, void *dev)
+{
+	drv_dxt_irq_handler = NULL;
+}
+EXPORT_SYMBOL(drv_dxt_if_free_irq);
+
+void
+drv_dxt_if_spi_cs_set(unsigned int dev_no, unsigned int hi_lo)
+{
+	if (hi_lo == 0)
+		drv_dxt_spi_cs = dev_no;
+	else
+		drv_dxt_spi_cs = -1;
+}
+EXPORT_SYMBOL(drv_dxt_if_spi_cs_set);
+
+int
+drv_dxt_if_spi_ll_read_write(unsigned char *tx_data, unsigned int tx_size,
+				 unsigned char *rx_data, unsigned int rx_size)
+{
+	uint16_t *ptr;
+	int i;
+
+	if ((tx_size & 1) || (rx_size & 1)) {
+		pr_err("drv_dxt_if: SPI transfer is not word aligned!\n");
+		return 0;
+	}
+
+	ptr = (uint16_t *)tx_data;
+	for (i = 0; i < tx_size / 2; i++, ptr++)
+		*ptr = htons(*ptr);
+
+	if (rx_data != NULL && rx_size != 0) {
+		mvSysTdmSpiRead(drv_dxt_spi_cs, tx_data, tx_size,
+							rx_data, rx_size, SPI_TYPE_SLIC_LANTIQ);
+	} else if (tx_data != NULL && tx_size > 2) {
+		mvSysTdmSpiWrite(drv_dxt_spi_cs, tx_data, 2,
+						tx_data + 2, tx_size - 2, SPI_TYPE_SLIC_LANTIQ);
+	} else {
+		pr_err("drv_dxt_if: Unsupported SPI access mode!\n");
+	}
+
+	ptr = (uint16_t *)rx_data;
+	for (i = 0; i < rx_size / 2; i++, ptr++)
+		*ptr = htons(*ptr);
+
+	return 0;
+}
+EXPORT_SYMBOL(drv_dxt_if_spi_ll_read_write);
diff --git a/drivers/telephony/mvebu_phone/mv_phone/slic/sdd_if.c b/drivers/telephony/mvebu_phone/mv_phone/slic/sdd_if.c
new file mode 100644
index 0000000..e410068
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/slic/sdd_if.c
@@ -0,0 +1,209 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <mach/avantalp.h>
+#include <plat/sdd_if.h>
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+
+#ifdef CONFIG_MV_AMP_ENABLE
+
+/* Use SoC Per-CPU Timer as all Global Timers are busy. */
+#define	TIMER_CTRL		(MV_CPUIF_REGS_OFFSET(whoAmI()) + 0x40)
+#define  TIMER_EN(x)		(1 << (2 * x))
+#define  TIMER_RELOAD_EN(x)	(2 << (2 * x))
+#define  TIMER_25MHZ_EN(x)	(1 << (x + 11))
+#define TIMER_CAUSE		(MV_CPUIF_REGS_OFFSET(whoAmI()) + 0x68)
+#define  TIMER_INT_CLR(x)	(~(1 << (8 * x)))
+#define TIMER_RELOAD(x)		(MV_CPUIF_REGS_OFFSET(whoAmI()) + 0x50 + (8 * x))
+#define TIMER_VAL(x)		(MV_CPUIF_REGS_OFFSET(whoAmI()) + 0x54 + (8 * x))
+
+#define DFEV_TIMER	0
+#define DFEV_TIMER_IRQ	IRQ_PRIV_SOC_PRIV_TIMER0
+
+#else /* !CONFIG_MV_AMP_ENABLE */
+
+/* Use SoC Global Timer */
+#define TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
+#define  TIMER_EN(x)		(1 << (2 * x))
+#define  TIMER_RELOAD_EN(x)	(2 << (2 * x))
+#define  TIMER_25MHZ_EN(x)	(1 << (x + 11))
+#define TIMER_CAUSE		(MV_CNTMR_REGS_OFFSET + 0x0004)
+#define  TIMER_INT_CLR(x)	(~(1 << (8 * x)))
+#define TIMER_RELOAD(x)		(MV_CNTMR_REGS_OFFSET + 0x0010 + (8 * x))
+#define TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
+
+#define DFEV_TIMER	3
+#define DFEV_TIMER_IRQ	IRQ_GLOBAL_TIMER(DFEV_TIMER)
+
+#endif /* !CONFIG_MV_AMP_ENABLE */
+
+/* SSI Reset GPIO */
+#define SSI_RESET	19
+
+static irq_handler_t sdd_if_tick;
+
+static irqreturn_t sdd_if_tick_wrapper(int irq, void *data)
+{
+	irqreturn_t r;
+
+	if (sdd_if_tick)
+		r = sdd_if_tick(irq, data);
+	else
+		r = IRQ_HANDLED;
+
+	MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(DFEV_TIMER));
+	return r;
+}
+void sdd_if_hw_init(void)
+{
+	gpio_request(SSI_RESET, "SSI RESET");
+	gpio_direction_output(SSI_RESET, 1);
+}
+EXPORT_SYMBOL(sdd_if_hw_init);
+
+void sdd_if_hw_exit(void)
+{
+	gpio_free(SSI_RESET);
+}
+EXPORT_SYMBOL(sdd_if_hw_exit);
+
+void sdd_if_peripheral_reset(void)
+{
+	gpio_set_value(SSI_RESET, 0);
+	msleep(25);
+	gpio_set_value(SSI_RESET, 1);
+}
+EXPORT_SYMBOL(sdd_if_peripheral_reset);
+
+unsigned long sdd_if_read(unsigned long addr)
+{
+	return readl(DFEV_VIRT_BASE + addr);
+}
+EXPORT_SYMBOL(sdd_if_read);
+
+void sdd_if_write(unsigned long data, unsigned long addr)
+{
+	writel(data, DFEV_VIRT_BASE + addr);
+}
+EXPORT_SYMBOL(sdd_if_write);
+
+int sdd_if_timer_request(irq_handler_t tickfcn, unsigned int tickrate)
+{
+	unsigned long tv;
+	int r;
+
+	if (!tickfcn)
+		return -EINVAL;
+
+	sdd_if_tick = tickfcn;
+
+	tv = alp_soc_timer_rate_get() / tickrate;
+	MV_REG_WRITE(TIMER_VAL(DFEV_TIMER), tv);
+	MV_REG_WRITE(TIMER_RELOAD(DFEV_TIMER), tv);
+	MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(DFEV_TIMER));
+
+	r = request_irq(DFEV_TIMER_IRQ,
+		sdd_if_tick_wrapper, 0, "DFEV Tick", NULL);
+	if (r)
+		return r;
+
+	return 0;
+}
+EXPORT_SYMBOL(sdd_if_timer_request);
+
+void sdd_if_timer_release(void)
+{
+	sdd_if_timer_stop();
+	free_irq(DFEV_TIMER_IRQ, NULL);
+}
+EXPORT_SYMBOL(sdd_if_timer_release);
+
+void sdd_if_timer_start(void)
+{
+	unsigned long reg;
+
+	reg = MV_REG_READ(TIMER_CTRL);
+	reg |= TIMER_EN(DFEV_TIMER) | TIMER_RELOAD_EN(DFEV_TIMER) | TIMER_25MHZ_EN(DFEV_TIMER);
+	MV_REG_WRITE(TIMER_CTRL, reg);
+}
+EXPORT_SYMBOL(sdd_if_timer_start);
+
+void sdd_if_timer_stop(void)
+{
+	unsigned long reg;
+
+	reg = MV_REG_READ(TIMER_CTRL);
+	reg &= ~TIMER_EN(DFEV_TIMER);
+	MV_REG_WRITE(TIMER_CTRL, reg);
+}
+EXPORT_SYMBOL(sdd_if_timer_stop);
diff --git a/drivers/telephony/mvebu_phone/mv_phone/slic/silabs_if.c b/drivers/telephony/mvebu_phone/mv_phone/slic/silabs_if.c
new file mode 100644
index 0000000..77246d4
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/slic/silabs_if.c
@@ -0,0 +1,141 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <plat/silabs_if.h>
+
+#ifndef CONFIG_OF
+#include "boardEnv/mvBoardEnvLib.h"
+#include "spi/mvSpi.h"
+#endif
+#include "voiceband/mvSysTdmSpi.h"
+
+static handler isi_handler;
+
+void silabs_if_enable_irq(unsigned int device)
+{
+	mvSysTdmIntEnable(device);
+}
+EXPORT_SYMBOL(silabs_if_enable_irq);
+
+void silabs_if_disable_irq(unsigned int device)
+{
+	mvSysTdmIntDisable(device);
+}
+EXPORT_SYMBOL(silabs_if_disable_irq);
+
+void silabs_if_handler_register(handler func)
+{
+	isi_handler = func;
+}
+EXPORT_SYMBOL(silabs_if_handler_register);
+
+void silabs_if_handler_unregister(void)
+{
+	isi_handler = NULL;
+}
+EXPORT_SYMBOL(silabs_if_handler_unregister);
+
+void silabs_if_isi_interrupt(void)
+{
+	if (isi_handler != NULL)
+		isi_handler(0);
+}
+EXPORT_SYMBOL(silabs_if_isi_interrupt);
+
+void silabs_if_spi_init(unsigned int line)
+{
+	return;
+}
+EXPORT_SYMBOL(silabs_if_spi_init);
+
+void silabs_if_spi_read(unsigned int line,
+	unsigned char *cmd, unsigned char cmd_size,
+	unsigned char *data, unsigned char data_size)
+{
+	MV_U32 slicDevice;
+	slicDevice = mvBoardSlicUnitTypeGet();
+
+	if (SLIC_SILABS_ID == slicDevice)
+		mvSysTdmSpiRead(line, cmd, cmd_size, data, data_size, SPI_TYPE_SLIC_ISI);
+	else
+		mvSysTdmSpiRead(line, cmd, cmd_size, data, data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(silabs_if_spi_read);
+
+void silabs_if_spi_write(unsigned int line,
+	unsigned char *cmd, unsigned char cmd_size,
+	unsigned char *data, unsigned char data_size)
+{
+	MV_U32 slicDevice;
+	slicDevice = mvBoardSlicUnitTypeGet();
+
+	if (SLIC_SILABS_ID == slicDevice)
+		mvSysTdmSpiWrite(line, cmd, cmd_size, data, data_size, SPI_TYPE_SLIC_ISI);
+	else
+		mvSysTdmSpiWrite(line, cmd, cmd_size, data, data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(silabs_if_spi_write);
diff --git a/drivers/telephony/mvebu_phone/mv_phone/slic/zarlink_if.c b/drivers/telephony/mvebu_phone/mv_phone/slic/zarlink_if.c
new file mode 100644
index 0000000..6b1eed1
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/slic/zarlink_if.c
@@ -0,0 +1,135 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <plat/zarlink_if.h>
+
+#ifndef CONFIG_OF
+#include "boardEnv/mvBoardEnvLib.h"
+#include "spi/mvSpi.h"
+#endif
+#include "voiceband/mvSysTdmSpi.h"
+
+static handler zsi_handler;
+
+void zarlink_if_enable_irq(unsigned int device)
+{
+	mvSysTdmIntEnable(device);
+}
+EXPORT_SYMBOL(zarlink_if_enable_irq);
+
+void zarlink_if_disable_irq(unsigned int device)
+{
+	mvSysTdmIntDisable(device);
+}
+EXPORT_SYMBOL(zarlink_if_disable_irq);
+
+void zarlink_if_handler_register(handler func)
+{
+	zsi_handler = func;
+}
+EXPORT_SYMBOL(zarlink_if_handler_register);
+
+void zarlink_if_handler_unregister(void)
+{
+	zsi_handler = NULL;
+}
+EXPORT_SYMBOL(zarlink_if_handler_unregister);
+
+void zarlink_if_zsi_interrupt(void)
+{
+	if (zsi_handler != NULL)
+		zsi_handler(0);
+}
+EXPORT_SYMBOL(zarlink_if_zsi_interrupt);
+
+void zarlink_if_spi_read(unsigned int line,
+	unsigned char *cmd, unsigned char cmd_size,
+	unsigned char *data, unsigned char data_size)
+{
+	MV_U32 slicDevice;
+	slicDevice = mvBoardSlicUnitTypeGet();
+
+	if (SLIC_ZARLINK_ID == slicDevice)
+		mvSysTdmSpiRead(line, cmd, cmd_size, data, data_size, SPI_TYPE_SLIC_ZSI);
+	else
+		mvSysTdmSpiRead(line, cmd, cmd_size, data, data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(zarlink_if_spi_read);
+
+void zarlink_if_spi_write(unsigned int line,
+	unsigned char *cmd, unsigned char cmd_size,
+	unsigned char *data, unsigned char data_size)
+{
+	MV_U32 slicDevice;
+	slicDevice = mvBoardSlicUnitTypeGet();
+
+	if (SLIC_ZARLINK_ID == slicDevice)
+		mvSysTdmSpiWrite(line, cmd, cmd_size, data, data_size, SPI_TYPE_SLIC_ZSI);
+	else
+		mvSysTdmSpiWrite(line, cmd, cmd_size, data, data_size, SPI_TYPE_SLIC_ZARLINK_SILABS);
+}
+EXPORT_SYMBOL(zarlink_if_spi_write);
diff --git a/drivers/telephony/mvebu_phone/mv_phone/spi/spi_dev.c b/drivers/telephony/mvebu_phone/mv_phone/spi/spi_dev.c
new file mode 100644
index 0000000..3ee6a8f
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/spi/spi_dev.c
@@ -0,0 +1,263 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include "spi_dev.h"
+#ifndef CONFIG_OF
+#include "boardEnv/mvBoardEnvLib.h"
+#include "spi/mvSpi.h"
+#endif
+#include "voiceband/mvSysTdmSpi.h"
+
+/* Defines */
+#define SPI_MOD_NAME				"spi"
+
+static ssize_t spi_read(struct file *file, char __user *buf, size_t size, loff_t *ppos);
+static ssize_t spi_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos);
+static unsigned int spi_poll(struct file *pFile, poll_table *pPollTable);
+static long spi_ioctl(struct file *pFile, unsigned int cmd, unsigned long arg);
+static int spi_open(struct inode *pInode, struct file *pFile);
+static int spi_release(struct inode *pInode, struct file *pFile);
+
+/* SPI-API Dispatchers */
+static int spi_read_reg(unsigned long arg);
+static int spi_write_reg(unsigned long arg);
+
+/* Structs */
+static const struct file_operations spi_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= NULL,
+	.read		= spi_read,
+	.write		= spi_write,
+	.poll		= spi_poll,
+	.unlocked_ioctl	= spi_ioctl,
+	.open		= spi_open,
+	.release	= spi_release,
+	.fasync		= NULL
+};
+
+/* Globals */
+static struct miscdevice spi_misc_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = SPI_MOD_NAME,
+	.fops = &spi_fops,
+};
+
+static ssize_t spi_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
+{
+	return 0;
+}
+
+static ssize_t spi_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos)
+{
+	return 0;
+}
+
+static unsigned int spi_poll(struct file *pFile, poll_table *pPollTable)
+{
+	return 0;
+}
+
+static long spi_ioctl(struct file *pFile, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	/* Argument checking */
+	if (_IOC_TYPE(cmd) != SPI_MOD_IOCTL_MAGIC) {
+		printk(KERN_ERR "%s: invalid SPI MOD Magic Num %i %i\n", __func__, _IOC_TYPE(cmd), SPI_MOD_IOCTL_MAGIC);
+		return -ENOTTY;
+	}
+
+	if ((_IOC_NR(cmd) > SPI_MOD_IOCTL_MAX) || (_IOC_NR(cmd) < SPI_MOD_IOCTL_MIN)) {
+		printk(KERN_ERR "%s: invalid SPI MOD IOCTL request\n", __func__);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (ret) {
+		printk(KERN_ERR "%s: invalid SPI MOD access type %i from cmd %i\n", __func__, _IOC_DIR(cmd), cmd);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case SPI_MOD_IOX_REG_READ:
+		/*printk("ioctl: SPI_MOD_IOX_REG_READ\n");*/
+		ret = spi_read_reg(arg);
+		break;
+
+	case SPI_MOD_IOX_REG_WRITE:
+		/*printk("ioctl: SPI_MOD_IOX_REG_WRITE\n");*/
+		ret = spi_write_reg(arg);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: error, ioctl command(0x%x) not supported !!!\n", __func__, cmd);
+		ret = -EFAULT;
+		break;
+	}
+
+	return ret;
+}
+
+static int spi_read_reg(unsigned long arg)
+{
+	SpiModRWObjType data;
+
+	/* Get user data */
+	if (copy_from_user(&data, (void *)arg, sizeof(SpiModRWObjType))) {
+		printk(KERN_ERR "%s: copy_from_user failed\n", __func__);
+		return -EFAULT;
+	}
+
+	mvSysTdmIntDisable(data.lineId);
+
+	mvSysTdmSpiRead(data.lineId, data.pCmdBuff, data.cmdSize, data.pDataBuff, data.dataSize, data.spiType);
+
+	mvSysTdmIntEnable(data.lineId);
+
+	/* Copy status back to user */
+	if (copy_to_user((void *)arg, &data, sizeof(SpiModRWObjType))) {
+		printk(KERN_ERR "%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int spi_write_reg(unsigned long arg)
+{
+	SpiModRWObjType data;
+
+	/* Get user data */
+	if (copy_from_user(&data, (void *)arg, sizeof(SpiModRWObjType))) {
+		printk(KERN_ERR "%s: copy_from_user failed\n", __func__);
+		return -EFAULT;
+	}
+
+	mvSysTdmIntDisable(data.lineId);
+
+	mvSysTdmSpiWrite(data.lineId, data.pCmdBuff, data.cmdSize, data.pDataBuff, data.dataSize, data.spiType);
+
+	mvSysTdmIntEnable(data.lineId);
+
+	/* Copy status back to user */
+	if (copy_to_user((void *)arg, &data, sizeof(SpiModRWObjType))) {
+		printk(KERN_ERR "%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int spi_open(struct inode *pInode, struct file *pFile)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int spi_release(struct inode *pInode, struct file *pFile)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+int __init spi_module_init(void)
+{
+	int status = 0;
+
+	printk(KERN_INFO "Loading Marvell %s device\n", SPI_MOD_NAME);
+
+	status = misc_register(&spi_misc_dev);
+
+	/* Register SPI device module */
+	if (status < 0) {
+		printk(KERN_ERR "Error, failed to load %s module(%d)\n", SPI_MOD_NAME, status);
+		return status;
+	}
+	return 0;
+}
+
+void __exit spi_module_exit(void)
+{
+	printk(KERN_INFO "Unloading %s device module\n", SPI_MOD_NAME);
+
+	/* Unregister SPI misc device */
+	misc_deregister(&spi_misc_dev);
+
+	return;
+}
+
+/* Module stuff */
+module_init(spi_module_init);
+module_exit(spi_module_exit);
+MODULE_DESCRIPTION("SPI Access Device");
+MODULE_AUTHOR("Nadav Haklai <nadavh@marvell.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/telephony/mvebu_phone/mv_phone/spi/spi_dev.h b/drivers/telephony/mvebu_phone/mv_phone/spi/spi_dev.h
new file mode 100644
index 0000000..ddb12dd
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/spi/spi_dev.h
@@ -0,0 +1,96 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _SPI_DEV_H_
+#define _SPI_DEV_H_
+
+
+#define SPI_MOD_IOCTL_MAGIC	'z'
+
+#define SPI_MOD_IOCTL_MIN	1
+
+/* SI-API System Configuration Functions */
+#define SPI_MOD_IOX_REG_READ	_IOWR(SPI_MOD_IOCTL_MAGIC, 1, SpiModRWObjType)
+#define SPI_MOD_IOX_REG_WRITE	_IOWR(SPI_MOD_IOCTL_MAGIC, 2, SpiModRWObjType)
+
+#define SPI_MOD_IOCTL_MAX	2
+
+/********************** SPI register read/write ********************/
+typedef struct SpiModRWObj {
+	/* Input arg(s) */
+	unsigned short	lineId;
+	unsigned char	*pCmdBuff;
+	unsigned char	cmdSize;
+	unsigned char	*pDataBuff;
+	unsigned char	dataSize;
+	unsigned char	spiType;
+} SpiModRWObjType;
+
+/* APIs */
+int spi_module_init(void);
+void spi_module_exit(void);
+
+
+#endif /*_SPI_DEV_H_*/
+
diff --git a/drivers/telephony/mvebu_phone/mv_phone/tal/tal.c b/drivers/telephony/mvebu_phone/mv_phone/tal/tal.c
new file mode 100644
index 0000000..b508f99
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/tal/tal.c
@@ -0,0 +1,135 @@
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+********************************************************************************/
+
+/* Marvell Telephony Adaptation Layer */
+#include "tal.h"
+
+static tal_if_t *tal_if;
+static tal_mmp_ops_t *tal_mmp;
+
+tal_stat_t tal_init(tal_params_t *tal_params, tal_mmp_ops_t *mmp_ops)
+{
+	if (!tal_params || !mmp_ops) {
+		mvOsPrintf("%s: Error, bad parameters.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	if (!mmp_ops->tal_mmp_rx_callback || !mmp_ops->tal_mmp_tx_callback) {
+		mvOsPrintf("%s: Error, MMP callbacks are missing.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	tal_mmp = mmp_ops;
+	if (tal_if && tal_if->init)
+		if (tal_if->init(tal_params) != MV_OK)
+			return TAL_STAT_INIT_ERROR;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_init);
+
+void tal_exit(void)
+{
+	if (tal_if && tal_if->exit)
+		tal_if->exit();
+
+	tal_mmp = NULL;
+}
+EXPORT_SYMBOL(tal_exit);
+
+void tal_pcm_start(void)
+{
+	if (tal_if && tal_if->pcm_start)
+		tal_if->pcm_start();
+}
+EXPORT_SYMBOL(tal_pcm_start);
+
+void tal_pcm_stop(void)
+{
+	if (tal_if && tal_if->pcm_stop)
+		tal_if->pcm_stop();
+}
+EXPORT_SYMBOL(tal_pcm_stop);
+
+int tal_control(int cmd, void *data)
+{
+	if (tal_if && tal_if->control)
+		return tal_if->control(cmd, data);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(tal_control);
+
+tal_stat_t tal_write(unsigned char *buffer, int size)
+{
+	if (tal_if && tal_if->write)
+		if (tal_if->write(buffer, size) != MV_OK)
+			return TAL_STAT_BAD_PARAM;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_write);
+
+tal_stat_t tal_stats_get(tal_stats_t *tal_stats)
+{
+	if (tal_stats && tal_if && tal_if->stats_get) {
+		tal_if->stats_get(tal_stats);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_stats_get);
+
+tal_stat_t tal_set_if(tal_if_t *interface)
+{
+	if (interface && (!interface->init || !interface->exit ||
+			  !interface->pcm_start || !interface->pcm_stop)) {
+		mvOsPrintf("%s: Error, TAL callbacks are missing.\n", __func__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	tal_if = interface;
+
+	return TAL_STAT_OK;
+}
+EXPORT_SYMBOL(tal_set_if);
+
+tal_stat_t tal_mmp_rx(unsigned char *buffer, int size)
+{
+	if (tal_mmp && tal_mmp->tal_mmp_rx_callback) {
+		tal_mmp->tal_mmp_rx_callback(buffer, size);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_mmp_rx);
+
+tal_stat_t tal_mmp_tx(unsigned char *buffer, int size)
+{
+	if (tal_mmp && tal_mmp->tal_mmp_tx_callback) {
+		tal_mmp->tal_mmp_tx_callback(buffer, size);
+		return TAL_STAT_OK;
+	}
+
+	return TAL_STAT_BAD_PARAM;
+}
+EXPORT_SYMBOL(tal_mmp_tx);
diff --git a/drivers/telephony/mvebu_phone/mv_phone/tal/tal.h b/drivers/telephony/mvebu_phone/mv_phone/tal/tal.h
new file mode 100644
index 0000000..d4cc4b8
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/tal/tal.h
@@ -0,0 +1,89 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************/
+
+/* Marvell Telephony Adaptation Layer */
+
+#ifndef _TAL_H_
+#define _TAL_H_
+
+#include <mvOs.h>
+
+/* Defines */
+#define TAL_MAX_PHONE_LINES	32
+
+/* Enumerators */
+typedef enum {
+	TAL_PCM_FORMAT_1BYTE = 1,
+	TAL_PCM_FORMAT_2BYTES = 2,
+	TAL_PCM_FORMAT_4BYTES = 4,
+} tal_pcm_format_t;
+
+typedef enum {
+	TAL_STAT_OK = 0,
+	TAL_STAT_BAD_PARAM,
+	TAL_STAT_INIT_ERROR,
+} tal_stat_t;
+
+/* Structures */
+typedef struct {
+	tal_pcm_format_t pcm_format;
+	unsigned short pcm_slot[TAL_MAX_PHONE_LINES];
+	unsigned char sampling_period;
+	unsigned short total_lines;
+} tal_params_t;
+
+typedef struct {
+	int tdm_init;
+	unsigned int rx_miss;
+	unsigned int tx_miss;
+	unsigned int rx_over;
+	unsigned int tx_under;
+#ifdef MV_TDM_EXT_STATS
+	MV_TDM_EXTENDED_STATS tdm_ext_stats;
+#endif
+} tal_stats_t;
+
+typedef struct {
+	void (*tal_mmp_rx_callback)(unsigned char *rx_buff, int size);
+	void (*tal_mmp_tx_callback)(unsigned char *tx_buff, int size);
+} tal_mmp_ops_t;
+
+typedef struct {
+	MV_STATUS (*init)(tal_params_t *tal_params);
+	void (*exit)(void);
+	void (*pcm_start)(void);
+	void (*pcm_stop)(void);
+	int (*control)(int cmd, void *data);
+	MV_STATUS (*write)(unsigned char *buffer, int size);
+	void (*stats_get)(tal_stats_t *tal_stats);
+} tal_if_t;
+
+/* API */
+tal_stat_t tal_init(tal_params_t *tal_params, tal_mmp_ops_t *mmp_ops);
+tal_stat_t tal_stats_get(tal_stats_t *tal_stats);
+void tal_exit(void);
+void tal_pcm_start(void);
+void tal_pcm_stop(void);
+int tal_control(int cmd, void *data);
+
+tal_stat_t tal_set_if(tal_if_t *interface);
+tal_stat_t tal_mmp_rx(unsigned char *buffer, int size);
+tal_stat_t tal_mmp_tx(unsigned char *buffer, int size);
+tal_stat_t tal_write(unsigned char *buffer, int size);
+
+#endif /* _TAL_H */
diff --git a/drivers/telephony/mvebu_phone/mv_phone/tal/tal_dev.c b/drivers/telephony/mvebu_phone/mv_phone/tal/tal_dev.c
new file mode 100644
index 0000000..4d2ae52
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/tal/tal_dev.c
@@ -0,0 +1,311 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+
+#ifndef CONFIG_OF
+#include "spi/mvSpi.h"
+#endif
+#include "tal.h"
+#include "../tdm/tdm_if.h"
+#include "tal_dev.h"
+
+#define	TALDEV_NAME	"tal"
+
+static DECLARE_WAIT_QUEUE_HEAD(tal_dev_wait);
+static DEFINE_SPINLOCK(tal_dev_lock);
+static unsigned char *rx_buff_p, *tx_buff_p;
+static size_t rx_buff_size, tx_buff_size;
+
+static void tal_dev_rx_callback(unsigned char *rx_buff, int size)
+{
+	unsigned long flags;
+
+	/* Save buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	rx_buff_p = rx_buff;
+	rx_buff_size = size;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	wake_up_interruptible(&tal_dev_wait);
+}
+
+static void tal_dev_tx_callback(unsigned char *tx_buff, int size)
+{
+	unsigned long flags;
+
+	/* Save buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	tx_buff_p = tx_buff;
+	tx_buff_size = size;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	wake_up_interruptible(&tal_dev_wait);
+}
+
+static tal_params_t tal_params;
+static tal_mmp_ops_t tal_mmp_ops = {
+	.tal_mmp_rx_callback	= tal_dev_rx_callback,
+	.tal_mmp_tx_callback	= tal_dev_tx_callback,
+};
+
+static ssize_t tal_dev_read(struct file *file_p, char __user *buf, size_t size, loff_t *ppos)
+{
+	unsigned long flags;
+	unsigned char *rx_buff;
+
+	/* Check if we have got the buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	rx_buff = rx_buff_p;
+	rx_buff_p = NULL;
+	size = min(rx_buff_size, size);
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	if (!rx_buff)
+		return 0;
+
+	/* Copy data to userspace */
+	if (copy_to_user(buf, rx_buff, size))
+		return -EFAULT;
+
+	return size;
+}
+
+static ssize_t tal_dev_write(struct file *file_p, const char __user *buf, size_t size, loff_t *ppos)
+{
+	unsigned long flags;
+	unsigned char *tx_buff;
+
+	/* Check if we have got the buffer */
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	tx_buff = tx_buff_p;
+	tx_buff_p = NULL;
+	size = min(tx_buff_size, size);
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	if (!tx_buff)
+		return 0;
+
+	/* Copy data from userspace */
+	if (copy_from_user(tx_buff, buf, size))
+		size = -EFAULT;
+
+	/* Pass the buffer to TAL */
+	if (tal_write(tx_buff, size) != TAL_STAT_OK)
+		return -EIO;
+
+	return size;
+}
+
+static int tal_dev_open(struct inode *inode_p, struct file *file_p)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int tal_dev_release(struct inode *inode_p, struct file *file_p)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static unsigned int tal_dev_poll(struct file *file_p, poll_table *poll_table_p)
+{
+	unsigned long flags;
+	int mask = 0;
+
+	poll_wait(file_p, &tal_dev_wait, poll_table_p);
+
+	spin_lock_irqsave(&tal_dev_lock, flags);
+	if (rx_buff_p)
+		mask |= POLLIN | POLLRDNORM;
+	if (tx_buff_p)
+		mask |= POLLOUT | POLLWRNORM;
+	spin_unlock_irqrestore(&tal_dev_lock, flags);
+
+	return mask;
+}
+
+static long tal_dev_ioctl(struct file *file_p, unsigned int cmd,
+							unsigned long arg)
+{
+	tal_dev_params_t tal_dev_params;
+	char buffer[16];
+	long ret = 0;
+	int i;
+
+	/* Argument checking */
+	if (_IOC_TYPE(cmd) != TAL_DEV_IOCTL_MAGIC) {
+		pr_err("%s: invalid TAL DEV Magic Num %i %i\n", __func__, _IOC_TYPE(cmd), TAL_DEV_IOCTL_MAGIC);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if ((_IOC_DIR(cmd) & _IOC_WRITE) && !ret)
+		ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (ret) {
+		pr_err("%s: invalid TAL DEV access type %i from cmd %i\n", __func__, _IOC_DIR(cmd), cmd);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+	case TAL_DEV_INIT:
+		if (copy_from_user(&tal_dev_params, (void *)arg, sizeof(tal_dev_params)))
+			return -EFAULT;
+
+		tal_params.pcm_format = tal_dev_params.pcm_format;
+		tal_params.sampling_period = 10; /* ms */
+		tal_params.total_lines = tal_dev_params.total_lines;
+		for (i = 0; i < TAL_MAX_PHONE_LINES; i++)
+			tal_params.pcm_slot[i] = (i + 1) * tal_dev_params.pcm_format;
+
+		if (tal_init(&tal_params, &tal_mmp_ops) != TAL_STAT_OK)
+			return -EIO;
+
+		break;
+
+	case TAL_DEV_EXIT:
+		tal_exit();
+		break;
+
+	case TAL_DEV_PCM_START:
+		rx_buff_p = NULL;
+		tx_buff_p = NULL;
+		tal_pcm_start();
+		break;
+
+	case TAL_DEV_PCM_STOP:
+		tal_pcm_stop();
+		break;
+
+	default:
+		/* Pass ioctl to the low-level interface */
+		if (_IOC_SIZE(cmd) > sizeof(buffer))
+			return -E2BIG;
+
+		if (_IOC_DIR(cmd) & _IOC_WRITE)
+			if (copy_from_user(buffer, (void *)arg, _IOC_SIZE(cmd)))
+				return -EFAULT;
+
+		ret = tal_control(cmd, buffer);
+
+		if (_IOC_DIR(cmd) & _IOC_READ)
+			if (copy_to_user((void *)arg, buffer, _IOC_SIZE(cmd)))
+				return -EFAULT;
+
+		break;
+	}
+
+	return ret;
+}
+
+static const struct file_operations tal_dev_fops = {
+	.owner		= THIS_MODULE,
+	.read		= tal_dev_read,
+	.write		= tal_dev_write,
+	.poll		= tal_dev_poll,
+	.unlocked_ioctl	= tal_dev_ioctl,
+	.open		= tal_dev_open,
+	.release	= tal_dev_release,
+};
+
+static struct miscdevice tal_dev = {
+	.minor	= TALDEV_MINOR,
+	.name	= TALDEV_NAME,
+	.fops	= &tal_dev_fops,
+};
+
+static int __init tal_dev_init(void)
+{
+	int status;
+
+	status = misc_register(&tal_dev);
+	if (status < 0) {
+		pr_err("Failed to register TAL device!\n");
+		return status;
+	}
+
+	return 0;
+}
+
+static void __exit tal_dev_exit(void)
+{
+	misc_deregister(&tal_dev);
+}
+
+/* Module stuff */
+module_init(tal_dev_init);
+module_exit(tal_dev_exit);
+MODULE_DESCRIPTION("Marvell TAL Device Interface");
+MODULE_AUTHOR("Piotr Ziecik <kosmo@angel.net.pl>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/telephony/mvebu_phone/mv_phone/tal/tal_dev.h b/drivers/telephony/mvebu_phone/mv_phone/tal/tal_dev.h
new file mode 100644
index 0000000..df05519
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/tal/tal_dev.h
@@ -0,0 +1,94 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _TAL_DEV_H_
+#define _TAL_DEV_H_
+
+#define TAL_DEV_IOCTL_MAGIC		't'
+
+#define TAL_DEV_INIT			_IOWR(TAL_DEV_IOCTL_MAGIC, 1, tal_dev_params_t)
+#define TAL_DEV_EXIT			_IO(TAL_DEV_IOCTL_MAGIC, 2)
+#define TAL_DEV_PCM_START		_IO(TAL_DEV_IOCTL_MAGIC, 3)
+#define TAL_DEV_PCM_STOP		_IO(TAL_DEV_IOCTL_MAGIC, 4)
+
+typedef struct {
+	unsigned char pcm_format;
+	unsigned short total_lines;
+} tal_dev_params_t;
+
+/* TDM-specific ioctls exported to TAL by tdm_if */
+#if defined(MV_TDM_USE_DCO)
+typedef struct tdm_dev_clk {
+	int correction;
+} tdm_dev_clk_t;
+
+#define TDM_DEV_TDM_CLK_CONFIG		_IOWR(TAL_DEV_IOCTL_MAGIC, 5, tdm_dev_clk_t)
+#define TDM_DEV_TDM_CLK_GET		_IOWR(TAL_DEV_IOCTL_MAGIC, 6, tdm_dev_clk_t)
+#define TDM_DEV_TDM_CLK_SET		_IOWR(TAL_DEV_IOCTL_MAGIC, 7, tdm_dev_clk_t)
+#endif
+
+#define	TDM_DEV_TDM_TEST_MODE_ENABLE	_IO(TAL_DEV_IOCTL_MAGIC, 8)
+#define	TDM_DEV_TDM_TEST_MODE_DISABLE	_IO(TAL_DEV_IOCTL_MAGIC, 9)
+
+#endif /*_TAL_DEV_H_*/
diff --git a/drivers/telephony/mvebu_phone/mv_phone/tdm/tdm_if.c b/drivers/telephony/mvebu_phone/mv_phone/tdm/tdm_if.c
new file mode 100644
index 0000000..118e48c
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/tdm/tdm_if.c
@@ -0,0 +1,951 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+#include "../tal/tal.h"
+#include "tdm_if.h"
+#include "../tal/tal_dev.h"
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <plat/drv_dxt_if.h>
+#include <plat/zarlink_if.h>
+#include <plat/silabs_if.h>
+#ifndef CONFIG_OF
+#include "gpp/mvGppRegs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#endif
+
+#define TDM_STOP_MAX_POLLING_TIME 20 /* ms */
+
+/* TDM Interrupt Service Routine */
+static irqreturn_t tdm_if_isr(int irq, void* dev_id);
+
+/* PCM start/stop */
+static void tdm_if_pcm_start(void);
+static void tdm_if_pcm_stop(void);
+
+/* Rx/Tx Tasklets  */
+#if !(defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) && !(defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+static void tdm_if_pcm_rx_process(unsigned long arg);
+static void tdm_if_pcm_tx_process(unsigned long arg);
+#else
+static inline void tdm_if_pcm_rx_process(void);
+static inline void tdm_if_pcm_tx_process(void);
+#endif
+/* TDM proc-fs statistics */
+#ifndef CONFIG_OF
+static int proc_tdm_init_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+static int proc_rx_miss_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+static int proc_tx_miss_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+static int proc_rx_over_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+static int proc_tx_under_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+#ifdef CONFIG_MV_TDM_EXT_STATS
+static int proc_dump_ext_stats(char *buffer, char **buffer_location, off_t offset,
+				int buffer_length, int *zero, void *ptr);
+#endif
+#endif /* !CONFIG_OF */
+
+/* TDM SW Reset */
+static void tdm2c_if_stop_channels(unsigned long args);
+
+/* Module */
+static int __init tdm_if_module_init(void);
+static void __exit tdm_if_module_exit(void);
+
+/* Globals */
+#if !(defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) && !(defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+static DECLARE_TASKLET(tdm_if_rx_tasklet, tdm_if_pcm_rx_process, 0);
+static DECLARE_TASKLET(tdm_if_tx_tasklet, tdm_if_pcm_tx_process, 0);
+#endif
+static DECLARE_TASKLET(tdm2c_if_stop_tasklet, tdm2c_if_stop_channels, 0);
+static DEFINE_SPINLOCK(tdm_if_lock);
+static unsigned char *rxBuff = NULL, *txBuff = NULL;
+static char irqnr;
+static unsigned int rx_miss = 0, tx_miss = 0;
+static unsigned int rx_over = 0, tx_under = 0;
+static struct proc_dir_entry *tdm_stats;
+static int pcm_enable = 0;
+static int irq_init = 0;
+static int tdm_init = 0;
+static int buff_size = 0;
+static unsigned short test_enable = 0;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+static unsigned int pcm_stop_fail;
+#endif
+static int pcm_stop_flag;
+static int pcm_stop_status;
+static unsigned int pcm_start_stop_state;
+static unsigned int is_pcm_stopping;
+static unsigned int mv_tdm_unit_type;
+
+#ifdef CONFIG_OF
+static int proc_tdm_status_show(struct seq_file *m, void *v)
+{
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	MV_TDM_EXTENDED_STATS tdm_ext_stats;
+#endif
+
+	seq_printf(m, "tdm_init:	%u\n", tdm_init);
+	seq_printf(m, "rx_miss:		%u\n", rx_miss);
+	seq_printf(m, "tx_miss:		%u\n", tx_miss);
+	seq_printf(m, "rx_over:		%u\n", rx_over);
+	seq_printf(m, "tx_under:	%u\n", tx_under);
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	mvTdmExtStatsGet(&tdm_ext_stats);
+
+	seq_printf(m, "\nTDM Extended Statistics:\n");
+	seq_printf(m, "intRxCount	= %u\n", tdm_ext_stats.intRxCount);
+	seq_printf(m, "intTxCount	= %u\n", tdm_ext_stats.intTxCount);
+	seq_printf(m, "intRx0Count	= %u\n", tdm_ext_stats.intRx0Count);
+	seq_printf(m, "intTx0Count	= %u\n", tdm_ext_stats.intTx0Count);
+	seq_printf(m, "intRx1Count	= %u\n", tdm_ext_stats.intRx1Count);
+	seq_printf(m, "intTx1Count	= %u\n", tdm_ext_stats.intTx1Count);
+	seq_printf(m, "intRx0Miss	= %u\n", tdm_ext_stats.intRx0Miss);
+	seq_printf(m, "intTx0Miss	= %u\n", tdm_ext_stats.intTx0Miss);
+	seq_printf(m, "intRx1Miss	= %u\n", tdm_ext_stats.intRx1Miss);
+	seq_printf(m, "intTx1Miss	= %u\n", tdm_ext_stats.intTx1Miss);
+	seq_printf(m, "pcmRestartCount	= %u\n", tdm_ext_stats.pcmRestartCount);
+	seq_printf(m, "pcm_stop_fail	= %u\n", pcm_stop_fail);
+#endif
+
+	return 0;
+}
+
+static int proc_tdm_status_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_tdm_status_show, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_tdm_operations = {
+	.open		= proc_tdm_status_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+#else
+static int proc_tdm_init_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", tdm_init);
+}
+
+static int proc_rx_miss_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", rx_miss);
+}
+
+static int proc_tx_miss_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", tx_miss);
+}
+
+static int proc_rx_over_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", rx_over);
+}
+
+static int proc_tx_under_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", tx_under);
+}
+#endif /* CONFIG_OF */
+
+static void tdm_if_unit_type_set(unsigned int tdm_unit)
+{
+	unsigned long flags;
+
+	TRC_REC("->%s\n", __func__);
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+
+	mv_tdm_unit_type = tdm_unit;
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+	TRC_REC("<-%s\n", __func__);
+	return;
+}
+
+static unsigned int tdm_if_unit_type_get(void)
+{
+	return mv_tdm_unit_type;
+}
+
+#ifndef CONFIG_OF
+#ifdef CONFIG_MV_TDM_EXT_STATS
+static int proc_dump_ext_stats(char *buffer, char **buffer_location, off_t offset,
+				int buffer_length, int *zero, void *ptr)
+{
+	char *str;
+	MV_TDM_EXTENDED_STATS tdm_ext_stats;
+
+	if (offset > 0)
+		return 0;
+
+	mvTdmExtStatsGet(&tdm_ext_stats);
+
+	str = buffer;
+	str += sprintf(str, "\nTDM Extended Statistics:\n");
+	str += sprintf(str, "intRxCount = %u\n", tdm_ext_stats.intRxCount);
+	str += sprintf(str, "intTxCount = %u\n", tdm_ext_stats.intTxCount);
+	str += sprintf(str, "intRx0Count = %u\n", tdm_ext_stats.intRx0Count);
+	str += sprintf(str, "intTx0Count = %u\n", tdm_ext_stats.intTx0Count);
+	str += sprintf(str, "intRx1Count = %u\n", tdm_ext_stats.intRx1Count);
+	str += sprintf(str, "intTx1Count = %u\n", tdm_ext_stats.intTx1Count);
+	str += sprintf(str, "intRx0Miss = %u\n", tdm_ext_stats.intRx0Miss);
+	str += sprintf(str, "intTx0Miss	= %u\n", tdm_ext_stats.intTx0Miss);
+	str += sprintf(str, "intRx1Miss	= %u\n", tdm_ext_stats.intRx1Miss);
+	str += sprintf(str, "intTx1Miss	= %u\n", tdm_ext_stats.intTx1Miss);
+	str += sprintf(str, "pcmRestartCount = %u\n", tdm_ext_stats.pcmRestartCount);
+	str += sprintf(str, "pcm_stop_fail = %u\n", pcm_stop_fail);
+
+	return (int)(str - buffer);
+}
+#endif
+#endif /* !CONFIG_OF */
+
+MV_STATUS tdm_if_init(tal_params_t *tal_params)
+{
+	MV_TDM_PARAMS tdm_params;
+
+	if (tdm_init) {
+		printk(KERN_INFO "Marvell Telephony Driver already started...\n");
+		return MV_OK;
+	}
+
+	printk(KERN_INFO "Loading Marvell Telephony Driver\n");
+
+#ifndef CONFIG_OF
+	/* Check if any SLIC module exists */
+	if (mvCtrlSocUnitInfoNumGet(TDM_UNIT_ID) == 0) {
+		mvCtrlPwrClckSet(TDM_UNIT_ID, 0, MV_FALSE);
+		printk(KERN_WARNING "%s: Warning, no SLIC module is connected\n", __func__);
+		return MV_OK;
+	}
+#endif
+
+	if (tal_params == NULL) {
+		printk(KERN_ERR "%s: bad parameters\n", __func__);
+		return MV_ERROR;
+
+	}
+
+	/* Reset globals */
+	rxBuff = txBuff = NULL;
+	irq_init = 0;
+	tdm_init = 0;
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get()) {
+
+		pcm_enable = 0;
+		is_pcm_stopping = 0;
+		pcm_stop_flag = 0;
+		pcm_stop_status = 0;
+	}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+	if (MV_TDM_UNIT_TDMMC == tdm_if_unit_type_get())
+		pcm_enable = 1;
+#endif
+
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	pcm_stop_fail = 0;
+#endif
+
+	/* Calculate Rx/Tx buffer size(use in callbacks) */
+	buff_size = (tal_params->pcm_format * tal_params->total_lines * 80 *
+			(tal_params->sampling_period/MV_TDM_BASE_SAMPLING_PERIOD));
+
+	/* Extract TDM irq number */
+	irqnr = mvCtrlTdmUnitIrqGet();
+
+	/* Enable Marvell tracing */
+	TRC_INIT();
+	TRC_START();
+	TRC_REC("->%s\n", __func__);
+
+	/* Assign TDM parameters */
+	memcpy(&tdm_params, tal_params, sizeof(MV_TDM_PARAMS));
+
+	/* Soft reset to PCM I/F */
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get())
+		mvTdmPcmIfReset();
+#endif
+
+	/* TDM init */
+	if (mvSysTdmInit(&tdm_params) != MV_OK) {
+			printk(KERN_ERR "%s: Error, TDM initialization failed !!!\n", __func__);
+			return MV_ERROR;
+	}
+	tdm_init = 1;
+
+	/* Register TDM interrupt */
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	if (request_fiq(irqnr, tdm_if_isr, IRQF_DISABLED, "tdm", NULL)) {
+		printk(KERN_ERR "%s: Failed to connect fiq(%d)\n", __func__, irqnr);
+		return MV_ERROR;
+	}
+#else /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+	if (request_irq(irqnr, tdm_if_isr, 0/*IRQF_DISABLED*/, "tdm", NULL)) {
+		printk(KERN_ERR "%s: Failed to connect irq(%d)\n", __func__, irqnr);
+		return MV_ERROR;
+	}
+#endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+
+	irq_init = 1;
+
+	/* Create TDM procFS statistics */
+	tdm_stats = proc_mkdir("tdm", NULL);
+	if (tdm_stats != NULL) {
+#ifdef CONFIG_OF
+		if (!proc_create("tdm_stats", S_IRUGO, tdm_stats, &proc_tdm_operations))
+			return -ENOMEM;
+#else
+		create_proc_read_entry("tdm_init", 0, tdm_stats, proc_tdm_init_read, NULL);
+		create_proc_read_entry("rx_miss", 0, tdm_stats, proc_rx_miss_read, NULL);
+		create_proc_read_entry("tx_miss", 0, tdm_stats, proc_tx_miss_read, NULL);
+		create_proc_read_entry("rx_over", 0, tdm_stats, proc_rx_over_read, NULL);
+		create_proc_read_entry("tx_under", 0, tdm_stats, proc_tx_under_read, NULL);
+#ifdef CONFIG_MV_TDM_EXT_STATS
+		create_proc_read_entry("tdm_extended_stats", 0, tdm_stats, proc_dump_ext_stats, NULL);
+#endif
+#endif /* CONFIG_OF */
+	}
+
+	TRC_REC("Marvell Telephony Driver Loaded Successfully\n");
+
+	/* WA to stop the MCDMA gracefully after commUnit initialization */
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+	if (MV_TDM_UNIT_TDMMC == tdm_if_unit_type_get())
+		tdm_if_pcm_stop();
+#endif
+	TRC_REC("<-%s\n", __func__);
+	return MV_OK;
+}
+
+
+void tdm_if_exit(void)
+{
+	u32 max_poll = 0;
+
+	/* Check if already stopped */
+	if (!irq_init && !pcm_enable && !tdm_init)
+		return;
+
+	TRC_REC("->%s\n", __func__);
+
+	/* Stop PCM channels */
+	if (pcm_enable)
+		tdm_if_pcm_stop();
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get()) {
+			while ((is_pcm_stopping != 0) && (max_poll < 20)) {
+				mdelay(1);
+				max_poll++;
+			}
+
+			if (max_poll >= 20)
+				printk(KERN_WARNING "%s: waiting for pcm channels to stop exceeded 20ms\n", __func__);
+		}
+#endif
+
+	if (irq_init) {
+		/* Release interrupt */
+#ifndef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+		free_irq(irqnr, NULL);
+#else /* !CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+		free_fiq(irqnr, NULL);
+#endif /* !CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
+		irq_init = 0;
+	}
+
+	if (tdm_init) {
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get())
+			mvTdmRelease();
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (MV_TDM_UNIT_TDMMC == tdm_if_unit_type_get())
+			mvCommUnitRelease();
+#endif
+		/* Remove proc directory & entries */
+#ifdef CONFIG_OF
+		remove_proc_entry("tdm_stats", tdm_stats);
+#else
+		remove_proc_entry("tdm_init", tdm_stats);
+		remove_proc_entry("rx_miss", tdm_stats);
+		remove_proc_entry("tx_miss", tdm_stats);
+		remove_proc_entry("rx_over", tdm_stats);
+		remove_proc_entry("tx_under", tdm_stats);
+#ifdef CONFIG_MV_TDM_EXT_STATS
+		remove_proc_entry("tdm_extended_stats", tdm_stats);
+#endif
+#endif /* CONFIG_OF */
+		remove_proc_entry("tdm", NULL);
+
+		tdm_init = 0;
+	}
+
+	TRC_REC("<-%s\n", __func__);
+
+	/* Dump output and release Marvell trace resources */
+	TRC_OUTPUT(0, 1);
+	TRC_RELEASE();
+}
+
+static void tdm_if_pcm_start(void)
+{
+	unsigned long flags;
+	u32 max_poll = 0;
+
+	TRC_REC("->%s\n", __func__);
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	if (!pcm_enable) {
+		pcm_enable = 1;
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get()) {
+			if (is_pcm_stopping == 0) {
+				pcm_stop_flag = 0;
+				pcm_stop_status = 0;
+				pcm_start_stop_state = 0;
+				rxBuff = txBuff = NULL;
+				mvTdmPcmStart();
+			} else {
+				pcm_start_stop_state++;
+				while (is_pcm_stopping && max_poll < TDM_STOP_MAX_POLLING_TIME) {
+					spin_unlock_irqrestore(&tdm_if_lock, flags);
+					mdelay(1);
+					max_poll++;
+					spin_lock_irqsave(&tdm_if_lock, flags);
+				}
+
+				if (is_pcm_stopping) {/*issue found or timeout*/
+					if (mvPcmStopIntMiss())
+						TRC_REC("pcm stop issue found\n");
+					else
+						TRC_REC("pcm stop timeout\n");
+						is_pcm_stopping = 0;
+						pcm_stop_flag = 0;
+						pcm_stop_status = 0;
+						pcm_start_stop_state = 0;
+						rxBuff = txBuff = NULL;
+						mvTdmPcmStart();
+				} else {
+					TRC_REC("pcm_start_stop_state(%d), max_poll=%d\n",
+						pcm_start_stop_state, max_poll);
+				}
+			}
+		}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (MV_TDM_UNIT_TDMMC == tdm_if_unit_type_get()) {
+			rxBuff = txBuff = NULL;
+			mvCommUnitPcmStart();
+		}
+#endif
+	}
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+	TRC_REC("<-%s\n", __func__);
+	return;
+}
+
+static void tdm_if_pcm_stop(void)
+{
+	unsigned long flags;
+
+	TRC_REC("->%s\n", __func__);
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	if (pcm_enable) {
+		pcm_enable = 0;
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get()) {
+			if (is_pcm_stopping == 0) {
+				is_pcm_stopping = 1;
+				mvTdmPcmStop();
+			} else {
+				pcm_start_stop_state--;
+				TRC_REC("pcm_start_stop_state(%d)\n", pcm_start_stop_state);
+			}
+		}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (MV_TDM_UNIT_TDMMC == tdm_if_unit_type_get())
+			mvCommUnitPcmStop();
+#endif
+	}
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+	TRC_REC("<-%s\n", __func__);
+	return;
+}
+
+static irqreturn_t tdm_if_isr(int irq, void* dev_id)
+{
+	MV_TDM_INT_INFO tdm_int_info;
+	unsigned int int_type;
+	int ret = 0;
+
+	TRC_REC("->%s\n", __func__);
+
+	/* Extract interrupt information from low level ISR */
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get())
+		ret = mvTdmIntLow(&tdm_int_info);
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+	if (MV_TDM_UNIT_TDMMC == tdm_if_unit_type_get())
+		ret = mvCommUnitIntLow(&tdm_int_info);
+#endif
+
+	int_type = tdm_int_info.intType;
+	/*device_id = tdm_int_info.cs;*/
+
+	/* Handle ZSI interrupts */
+	if (MV_BOARD_SLIC_ZSI_ID == mvBoardSlicUnitTypeGet())
+		zarlink_if_zsi_interrupt();
+	/* Handle ISI interrupts */
+	else if (MV_BOARD_SLIC_ISI_ID == mvBoardSlicUnitTypeGet())
+		silabs_if_isi_interrupt();
+
+	/* Nothing to do - return */
+	if (int_type == MV_EMPTY_INT)
+		goto out;
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get()) {
+		if ((ret == -1) && (pcm_stop_status == 0))	{
+			pcm_stop_status = 1;
+
+			/* If Rx/Tx tasklets already scheduled, let them do the work. */
+			if ((!rxBuff) && (!txBuff)) {
+				TRC_REC("Stopping the TDM\n");
+				tdm_if_pcm_stop();
+				pcm_stop_flag = 0;
+				tasklet_hi_schedule(&tdm2c_if_stop_tasklet);
+			} else {
+				TRC_REC("Some tasklet is running, mark pcm_stop_flag\n");
+				pcm_stop_flag = 1;
+			}
+		}
+
+		/* Restarting PCM, skip Rx/Tx handling */
+		if (pcm_stop_status)
+			goto skip_rx_tx;
+	}
+#endif
+
+	/* Support multiple interrupt handling */
+	/* RX interrupt */
+	if (int_type & MV_RX_INT) {
+		if (rxBuff != NULL) {
+			rx_miss++;
+			TRC_REC("%s: Warning, missed Rx buffer processing !!!\n", __func__);
+		} else {
+			rxBuff = tdm_int_info.tdmRxBuff;
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+			TRC_REC("%s: running Rx in ISR\n", __func__);
+			tdm_if_pcm_rx_process();
+#else
+			/* Schedule Rx processing within SOFT_IRQ context */
+			TRC_REC("%s: schedule Rx tasklet\n", __func__);
+			tasklet_hi_schedule(&tdm_if_rx_tasklet);
+#endif
+		}
+	}
+
+	/* TX interrupt */
+	if (int_type & MV_TX_INT) {
+		if (txBuff != NULL) {
+			tx_miss++;
+			TRC_REC("%s: Warning, missed Tx buffer processing !!!\n", __func__);
+		} else {
+			txBuff = tdm_int_info.tdmTxBuff;
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+			TRC_REC("%s: running Tx in ISR\n", __func__);
+			tdm_if_pcm_tx_process();
+#else
+			/* Schedule Tx processing within SOFT_IRQ context */
+			TRC_REC("%s: schedule Tx tasklet\n", __func__);
+			tasklet_hi_schedule(&tdm_if_tx_tasklet);
+#endif
+		}
+	}
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get()) {
+		/* TDM2CH PCM channels stop indication */
+		if ((int_type & MV_CHAN_STOP_INT) && (tdm_int_info.data == 4)) {
+			TRC_REC("%s: Received MV_CHAN_STOP_INT indication\n", __func__);
+			is_pcm_stopping = 0;
+			if (pcm_start_stop_state) {
+				TRC_REC("%s: calling to tdm_if_pcm_start()\n", __func__);
+				pcm_enable = 0;
+				tdm_if_pcm_start();
+			}
+		}
+	}
+#endif
+
+skip_rx_tx:
+
+	/* PHONE interrupt, Lantiq specific */
+	if (int_type & MV_PHONE_INT) {
+		/* TBD */
+		drv_dxt_if_signal_interrupt();
+	}
+
+	/* ERROR interrupt */
+	if (int_type & MV_ERROR_INT) {
+		if (int_type & MV_RX_ERROR_INT)
+			rx_over++;
+
+		if (int_type & MV_TX_ERROR_INT)
+			tx_under++;
+	}
+
+out:
+	TRC_REC("<-%s\n", __func__);
+	return IRQ_HANDLED;
+}
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+static inline void tdm_if_pcm_rx_process(void)
+#else
+/* Rx tasklet */
+static void tdm_if_pcm_rx_process(unsigned long arg)
+#endif
+{
+	unsigned long flags;
+	unsigned int tdm_type;
+
+	TRC_REC("->%s\n", __func__);
+	tdm_type = tdm_if_unit_type_get();
+	if (pcm_enable) {
+		if(rxBuff == NULL) {
+			TRC_REC("%s: Error, empty Rx processing\n", __func__);
+			return;
+		}
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		/* Fill TDM Rx aggregated buffer */
+		if (MV_TDM_UNIT_TDM2C == tdm_type) {
+			if (mvTdmRx(rxBuff) == MV_OK)
+				tal_mmp_rx(rxBuff, buff_size); /* Dispatch Rx handler */
+			else
+				printk(KERN_WARNING "%s: could not fill Rx buffer\n", __func__);
+		}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (MV_TDM_UNIT_TDMMC == tdm_type) {
+			if (mvCommUnitRx(rxBuff) == MV_OK) {
+				tal_mmp_rx(rxBuff, buff_size); /* Dispatch Rx handler */
+				/* Since data buffer is shared among MCDMA and CPU, need to invalidate
+					before it accessed by MCDMA. MMP may stop channels from this context,
+					so make sure the buffer is still valid	*/
+				if (pcm_enable)
+					mvOsCacheInvalidate(NULL, rxBuff, buff_size);
+			} else
+				printk(KERN_WARNING "%s: could not fill Rx buffer\n", __func__);
+		}
+#endif
+	}
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	/* Clear rxBuff for next iteration */
+	rxBuff = NULL;
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (MV_TDM_UNIT_TDM2C == tdm_type) {
+		if ((pcm_stop_flag == 1) && !txBuff) {
+			TRC_REC("Stopping TDM from Rx tasklet\n");
+			tdm_if_pcm_stop();
+			spin_lock_irqsave(&tdm_if_lock, flags);
+			pcm_stop_flag = 0;
+			spin_unlock_irqrestore(&tdm_if_lock, flags);
+			tasklet_hi_schedule(&tdm2c_if_stop_tasklet);
+		}
+	}
+#endif
+
+	TRC_REC("<-%s\n", __func__);
+	return;
+}
+
+#if (defined CONFIG_MV_PHONE_USE_IRQ_PROCESSING) || (defined CONFIG_MV_PHONE_USE_FIQ_PROCESSING)
+static inline void tdm_if_pcm_tx_process(void)
+#else
+/* Tx tasklet */
+static void tdm_if_pcm_tx_process(unsigned long arg)
+#endif
+{
+	unsigned long flags;
+	unsigned int tdm_type;
+
+	TRC_REC("->%s\n", __func__);
+	tdm_type = tdm_if_unit_type_get();
+
+	if (pcm_enable) {
+		if (txBuff == NULL) {
+			TRC_REC("%s: Error, empty Tx processing\n", __func__);
+			return;
+		}
+
+		/* Dispatch Tx handler */
+		tal_mmp_tx(txBuff, buff_size);
+
+		if (test_enable == 0) {
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+			/* Fill Tx aggregated buffer */
+			if (MV_TDM_UNIT_TDM2C == tdm_type) {
+				if (mvTdmTx(txBuff) != MV_OK)
+					printk(KERN_WARNING "%s: could not fill Tx buffer\n", __func__);
+			}
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+			if (MV_TDM_UNIT_TDMMC == tdm_type) {
+				if (mvCommUnitTx(txBuff) != MV_OK)
+					printk(KERN_WARNING "%s: could not fill Tx buffer\n", __func__);
+			}
+#endif
+		}
+	}
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	/* Clear txBuff for next iteration */
+	txBuff = NULL;
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+	if (MV_TDM_UNIT_TDM2C == tdm_type) {
+		if ((pcm_stop_flag == 1) && !rxBuff) {
+			TRC_REC("Stopping TDM from Tx tasklet\n");
+			tdm_if_pcm_stop();
+			spin_lock_irqsave(&tdm_if_lock, flags);
+			pcm_stop_flag = 0;
+			spin_unlock_irqrestore(&tdm_if_lock, flags);
+			tasklet_hi_schedule(&tdm2c_if_stop_tasklet);
+		}
+	}
+#endif
+
+	TRC_REC("<-%s\n", __func__);
+	return;
+}
+
+void tdm_if_stats_get(tal_stats_t *tdm_if_stats)
+{
+	if (tdm_init == 0)
+		return;
+
+	tdm_if_stats->tdm_init = tdm_init;
+	tdm_if_stats->rx_miss = rx_miss;
+	tdm_if_stats->tx_miss = tx_miss;
+	tdm_if_stats->rx_over = rx_over;
+	tdm_if_stats->tx_under = tx_under;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	mvTdmExtStatsGet(&tdm_if_stats->tdm_ext_stats);
+#endif
+	return;
+}
+
+static void tdm2c_if_stop_channels(unsigned long arg)
+{
+	u32 max_poll = 0;
+	unsigned long flags;
+
+	TRC_REC("->%s\n", __func__);
+
+	/* Wait for all channels to stop  */
+	while (((MV_REG_READ(CH_ENABLE_REG(0)) & 0x101) || (MV_REG_READ(CH_ENABLE_REG(1)) & 0x101)) && (max_poll < 30)) {
+		mdelay(1);
+		max_poll++;
+	}
+
+	TRC_REC("Finished polling on channels disable\n");
+	if (max_poll >= 30) {
+		MV_REG_WRITE(CH_ENABLE_REG(0), 0);
+		MV_REG_WRITE(CH_ENABLE_REG(1), 0);
+		printk(KERN_WARNING "\n\npolling on channels disabling exceeded 30ms\n\n");
+#ifdef CONFIG_MV_TDM_EXT_STATS
+		pcm_stop_fail++;
+#endif
+		mdelay(10);
+	}
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	is_pcm_stopping = 0;
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+	tdm_if_pcm_start();
+
+	TRC_REC("<-%s\n", __func__);
+	return;
+}
+
+static int tdm_if_control(int cmd, void *arg)
+{
+#ifdef MV_TDM_USE_DCO
+	tdm_dev_clk_t *tdm_dev_clk = arg;
+#endif
+
+	switch (cmd) {
+	case TDM_DEV_TDM_TEST_MODE_ENABLE:
+		test_enable = 1;
+		break;
+
+	case TDM_DEV_TDM_TEST_MODE_DISABLE:
+		test_enable = 0;
+		break;
+
+#ifdef MV_TDM_USE_DCO
+	case TDM_DEV_TDM_CLK_CONFIG:
+		mvCtrlTdmClkCtrlConfig();
+		printk(KERN_INFO "ioctl: TDM_DEV_TDM_CLK_CONFIG\n");
+		break;
+
+	case TDM_DEV_TDM_CLK_GET:
+		tdm_dev_clk->correction = mvCtrlTdmClkCtrlGet();
+		printk(KERN_INFO "ioctl: TDM_DEV_TDM_CLK_GET\n");
+		break;
+
+	case TDM_DEV_TDM_CLK_SET:
+		printk(KERN_INFO "ioctl: TDM_DEV_TDM_CLK_SET: %x\n", tdm_dev_clk->correction);
+		mvCtrlTdmClkCtrlSet(tdm_dev_clk->correction);
+		break;
+#endif /* MV_TDM_USE_DCO */
+	default:
+		return -EINVAL;
+	};
+
+	return 0;
+}
+
+static int tdm_if_write(unsigned char *buffer, int size)
+{
+	if (test_enable) {
+#ifdef CONFIG_MV_TDM2C_SUPPORT
+		if (MV_TDM_UNIT_TDM2C == tdm_if_unit_type_get())
+			return mvTdmTx(buffer);
+#endif
+#ifdef CONFIG_MV_TDMMC_SUPPORT
+		if (MV_TDM_UNIT_TDMMC == tdm_if_unit_type_get())
+			return mvCommUnitTx(buffer);
+#endif
+	}
+	return MV_OK;
+}
+
+static tal_if_t tdm_if = {
+	.init		= tdm_if_init,
+	.exit		= tdm_if_exit,
+	.pcm_start	= tdm_if_pcm_start,
+	.pcm_stop	= tdm_if_pcm_stop,
+	.control	= tdm_if_control,
+	.write		= tdm_if_write,
+	.stats_get	= tdm_if_stats_get,
+};
+
+static int __init tdm_if_module_init(void)
+{
+	u32 tdmUnit;
+	tdmUnit = mvCtrlTdmUnitTypeGet();
+	if ((MV_TDM_UNIT_TDM2C == tdmUnit) ||
+		MV_TDM_UNIT_TDMMC == tdmUnit) {
+		tal_set_if(&tdm_if);
+		tdm_if_unit_type_set(tdmUnit);
+	}
+	return 0;
+}
+
+static void __exit tdm_if_module_exit(void)
+{
+	u32 tdmUnit;
+	tdmUnit = mvCtrlTdmUnitTypeGet();
+	if ((MV_TDM_UNIT_TDM2C == tdmUnit) ||
+		MV_TDM_UNIT_TDMMC == tdmUnit) {
+		tal_set_if(NULL);
+	}
+	return;
+}
+
+/* Module stuff */
+module_init(tdm_if_module_init);
+module_exit(tdm_if_module_exit);
+MODULE_DESCRIPTION("Marvell TDM I/F Device Driver - www.marvell.com");
+MODULE_AUTHOR("Eran Ben-Avi <benavi@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/telephony/mvebu_phone/mv_phone/tdm/tdm_if.h b/drivers/telephony/mvebu_phone/mv_phone/tdm/tdm_if.h
new file mode 100644
index 0000000..572ad5c
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone/tdm/tdm_if.h
@@ -0,0 +1,127 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _TDM_IF_H_
+#define _TDM_IF_H_
+
+#ifndef CONFIG_OF
+#include "mvSysTdmApi.h"
+#endif
+#include "voiceband/tdm/mvTdm.h"
+#include "voiceband/commUnit/mvCommUnit.h"
+#ifndef CONFIG_OF
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#endif
+
+/* Structures */
+typedef struct {
+	int tdm_init;
+	unsigned int rx_miss;
+	unsigned int tx_miss;
+	unsigned int rx_over;
+	unsigned int tx_under;
+#ifdef CONFIG_MV_TDM_EXT_STATS
+	MV_TDM_EXTENDED_STATS tdm_ext_stats;
+#endif
+} tdm_if_stats_t;
+
+typedef struct {
+	MV_PCM_FORMAT pcm_format;
+	unsigned short pcm_slot[32];
+	unsigned char sampling_period;
+	unsigned short total_lines;
+	unsigned short test_enable;
+} tdm_if_params_t;
+
+/* control callbacks */
+typedef struct {
+	void (*ctl_pcm_start)(void);
+	void (*ctl_pcm_stop)(void);
+} tdm_if_ctl_ops_t;
+
+/* pcm callbacks */
+typedef struct {
+	void (*pcm_tx_callback)(unsigned char* tx_buff, int size);
+	void (*pcm_rx_callback)(unsigned char* rx_buff, int size);
+} tdm_if_pcm_ops_t;
+
+typedef struct {
+	tdm_if_ctl_ops_t tdm_if_ctl_ops;
+	tdm_if_pcm_ops_t tdm_if_pcm_ops;
+} tdm_if_register_ops_t;
+
+/* APIs */
+void tdm_if_stats_get(tal_stats_t *tdm_if_stats);
+
+#if defined(MV_TDM_USE_DCO)
+MV_VOID mvCtrlTdmDcoReset(MV_VOID);
+MV_32 mvCtrlTdmDcoGet(MV_VOID);
+MV_VOID mvCtrlTdmDcoSet(MV_32 DcoCorrection);
+#endif
+
+#endif /*_TDM_IF_H_*/
+
diff --git a/drivers/telephony/mvebu_phone/mv_phone_dev.c b/drivers/telephony/mvebu_phone/mv_phone_dev.c
new file mode 100644
index 0000000..caaa6db
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone_dev.c
@@ -0,0 +1,454 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	    notice, this list of conditions and the following disclaimer in the
+	    documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	    used to endorse or promote products derived from this software without
+	    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/mbus.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "voiceband/tdm/mvTdm.h"
+#include "voiceband/mvSysTdmSpi.h"
+
+#define DRV_NAME "mvebu_phone"
+
+int tdm_base;
+int use_pclk_external;
+int mv_phone_enabled;
+struct mv_phone_dev *priv;
+
+/* Initialize the TDM subsystem. */
+int mvSysTdmInit(MV_TDM_PARAMS *tdm_params)
+{
+	MV_TDM_HAL_DATA hal_data;
+	MV_TDM_UNIT_TYPE tdm_unit;
+	u8 spi_mode = 0;
+	int ret;
+
+	tdm_unit = mvCtrlTdmUnitTypeGet();
+	if (tdm_unit != MV_TDM_UNIT_TDM2C)
+		return 0;
+
+	hal_data.spiMode = spi_mode;
+
+	switch (priv->pclk_freq_mhz) {
+	case 8:
+		hal_data.frameTs = MV_FRAME_128TS;
+		break;
+	case 4:
+		hal_data.frameTs = MV_FRAME_64TS;
+		break;
+	case 2:
+		hal_data.frameTs = MV_FRAME_32TS;
+		break;
+	default:
+		hal_data.frameTs = MV_FRAME_128TS;
+		break;
+	}
+
+	ret = mvTdmHalInit(tdm_params, &hal_data);
+
+	priv->tdm_params = tdm_params;
+
+	return ret;
+}
+
+/* Enable device interrupts. */
+void mvSysTdmIntEnable(u8 dev_id)
+{
+	MV_TDM_UNIT_TYPE tdmUnit;
+	tdmUnit = mvCtrlTdmUnitTypeGet();
+
+	if (tdmUnit == MV_TDM_UNIT_TDM2C)
+		mvTdmIntEnable();
+}
+
+/* Disable device interrupts. */
+void mvSysTdmIntDisable(u8 dev_id)
+{
+	MV_TDM_UNIT_TYPE tdm_unit;
+	tdm_unit = mvCtrlTdmUnitTypeGet();
+
+	if (tdm_unit == MV_TDM_UNIT_TDM2C)
+		mvTdmIntDisable();
+}
+
+/* Get board type for SLIC unit (pre-defined). */
+u32 mvBoardSlicUnitTypeGet(void)
+{
+	return MV_BOARD_SLIC_DISABLED;
+}
+
+/* Get TDM unit interrupt number. */
+u32 mvCtrlTdmUnitIrqGet(void)
+{
+	return priv->irq;
+}
+
+/* Get TDM unit type. */
+MV_TDM_UNIT_TYPE mvCtrlTdmUnitTypeGet(void)
+{
+	MV_TDM_UNIT_TYPE tdm_type = MV_TDM_UNIT_NONE;
+
+	if (!mv_phone_enabled)
+		return tdm_type;
+
+	if (of_device_is_compatible(priv->np, "marvell,armada-380-tdm"))
+		tdm_type = MV_TDM_UNIT_TDM2C;
+
+	return tdm_type;
+}
+
+/* Configure PLL to 24MHz */
+static int mv_phone_tdm_clk_pll_config(struct platform_device *pdev)
+{
+	struct resource *mem;
+	u32 reg_val;
+	u16 freq_offset = 0x22b0;
+	u8 tdm_postdiv = 0x6, fb_clk_div = 0x1d;
+
+	if (!priv->pll_base) {
+		mem = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   "pll_regs");
+		priv->pll_base = devm_ioremap_resource(&pdev->dev, mem);
+		if (IS_ERR(priv->pll_base))
+			return -ENOMEM;
+	}
+
+	/* Set frequency offset value to not valid and enable PLL reset */
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG1);
+	reg_val &= ~TDM_PLL_FREQ_OFFSET_VALID;
+	reg_val &= ~TDM_PLL_SW_RESET;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	udelay(1);
+
+	/* Update PLL parameters */
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG0);
+	reg_val &= ~TDM_PLL_FB_CLK_DIV_MASK;
+	reg_val |= (fb_clk_div << TDM_PLL_FB_CLK_DIV_OFFSET);
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG0);
+
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG2);
+	reg_val &= ~TDM_PLL_POSTDIV_MASK;
+	reg_val |= tdm_postdiv;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG2);
+
+	reg_val = readl(priv->pll_base + TDM_PLL_CONF_REG1);
+	reg_val &= ~TDM_PLL_FREQ_OFFSET_MASK;
+	reg_val |= freq_offset;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	udelay(1);
+
+	/* Disable reset */
+	reg_val |= TDM_PLL_SW_RESET;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	/* Wait 50us for PLL to lock */
+	udelay(50);
+
+	/* Restore frequency offset value validity */
+	reg_val |= TDM_PLL_FREQ_OFFSET_VALID;
+	writel(reg_val, priv->pll_base + TDM_PLL_CONF_REG1);
+
+	return 0;
+}
+
+/* Set DCO post divider in respect of 24MHz PLL output */
+static int mv_phone_dco_post_div_config(struct platform_device *pdev,
+					u32 pclk_freq_mhz)
+{
+	struct resource *mem;
+	u32 reg_val, pcm_clk_ratio;
+
+	if (!priv->dco_div_reg) {
+		mem = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						   "dco_div");
+		priv->dco_div_reg = devm_ioremap_resource(&pdev->dev, mem);
+		if (IS_ERR(priv->dco_div_reg))
+			return -ENOMEM;
+	}
+
+	switch (pclk_freq_mhz) {
+	case 8:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_8M;
+		break;
+	case 4:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_4M;
+		break;
+	case 2:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_2M;
+		break;
+	default:
+		pcm_clk_ratio = DCO_CLK_DIV_RATIO_8M;
+		break;
+	}
+
+	/* Disable output clock */
+	reg_val = readl(priv->dco_div_reg);
+	writel(MV_BIT_CLEAR(reg_val, DCO_CLK_DIV_RESET_OFFS),
+	       priv->dco_div_reg);
+
+	/* Set DCO source ratio */
+	reg_val = readl(priv->dco_div_reg);
+	writel((reg_val & ~DCO_CLK_DIV_RATIO_MASK) | pcm_clk_ratio,
+	       priv->dco_div_reg);
+
+	/* Reload new DCO source ratio */
+	reg_val = readl(priv->dco_div_reg);
+	writel(MV_BIT_SET(reg_val, DCO_CLK_DIV_MOD_OFFS), priv->dco_div_reg);
+	mdelay(1);
+
+	reg_val = readl(priv->dco_div_reg);
+	writel(MV_BIT_CLEAR(reg_val, DCO_CLK_DIV_MOD_OFFS), priv->dco_div_reg);
+	mdelay(1);
+
+	/* Enable output clock */
+	reg_val = readl(priv->dco_div_reg);
+	writel(MV_BIT_SET(reg_val, DCO_CLK_DIV_RESET_OFFS), priv->dco_div_reg);
+
+	return 0;
+}
+
+/* Initialize decoding windows */
+static int mv_conf_mbus_windows(struct device *dev, void __iomem *regs,
+				const struct mbus_dram_target_info *dram)
+{
+	int i;
+
+	if (!dram) {
+		dev_err(dev, "no mbus dram info\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < TDM_MBUS_MAX_WIN; i++) {
+		writel(0, regs + TDM_WIN_CTRL_REG(i));
+		writel(0, regs + TDM_WIN_BASE_REG(i));
+	}
+
+	for (i = 0; i < dram->num_cs; i++) {
+		const struct mbus_dram_window *cs = dram->cs + i;
+
+		/* Write size, attributes and target id to control register */
+		writel(((cs->size - 1) & 0xffff0000) |
+			(cs->mbus_attr << 8) |
+			(dram->mbus_dram_target_id << 4) | 1,
+			regs + TDM_WIN_CTRL_REG(i));
+		/* Write base address to base register */
+		writel(cs->base, regs + TDM_WIN_BASE_REG(i));
+	}
+
+	return 0;
+}
+
+static int mvebu_phone_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *mem;
+	int err;
+	printk ("Rabeeh - GOT PROBE %s %d\n",__FUNCTION__,__LINE__);
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct mv_phone_dev),
+			    GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "allocation failed\n");
+		return -ENOMEM;
+	}
+
+	priv->np = np;
+
+	mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tdm_regs");
+	priv->tdm_base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(priv->tdm_base))
+		return PTR_ERR(priv->tdm_base);
+	tdm_base = (int)priv->tdm_base;
+
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq <= 0) {
+		dev_err(&pdev->dev, "platform_get_irq failed\n");
+		return -ENXIO;
+	}
+
+	err = mv_conf_mbus_windows(&pdev->dev, priv->tdm_base,
+				   mv_mbus_dram_info());
+	if (err < 0)
+		return err;
+
+	priv->clk = devm_clk_get(&pdev->dev, "gateclk");
+	if (IS_ERR(priv->clk)) {
+		dev_err(&pdev->dev, "no clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	err = clk_prepare_enable(priv->clk);
+	if (err < 0)
+		return err;
+
+	if (of_property_read_bool(np, "use-external-pclk")) {
+		dev_info(&pdev->dev, "using external pclk\n");
+		use_pclk_external = 1;
+	} else {
+		dev_info(&pdev->dev, "using internal pclk\n");
+		use_pclk_external = 0;
+	}
+
+	if (of_property_read_u32(np, "pclk-freq-mhz", &priv->pclk_freq_mhz) ||
+	    (priv->pclk_freq_mhz != 8 && priv->pclk_freq_mhz != 4 &&
+	     priv->pclk_freq_mhz != 2)) {
+		priv->pclk_freq_mhz = 8;
+		dev_info(&pdev->dev, "wrong pclk frequency in the DT\n");
+	}
+	dev_info(&pdev->dev, "setting pclk frequency to %d MHz\n",
+		 priv->pclk_freq_mhz);
+
+	if (of_device_is_compatible(np, "marvell,armada-380-tdm")) {
+		err = mv_phone_tdm_clk_pll_config(pdev);
+		err |= mv_phone_dco_post_div_config(pdev, priv->pclk_freq_mhz);
+		if (err < 0)
+			goto err_clk;
+	}
+
+	mv_phone_enabled = 1;
+
+	return 0;
+
+err_clk:
+	clk_disable_unprepare(priv->clk);
+
+	return err;
+}
+
+static int mvebu_phone_remove(struct platform_device *pdev)
+{
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int mvebu_phone_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int mvebu_phone_resume(struct device *dev)
+{
+	struct platform_device *pdev = priv->parent;
+	int err;
+
+	err = mv_conf_mbus_windows(dev, priv->tdm_base,
+				   mv_mbus_dram_info());
+	if (err < 0)
+		return err;
+
+	if (of_device_is_compatible(priv->np, "marvell,armada-380-tdm")) {
+		err = mv_phone_tdm_clk_pll_config(pdev);
+		err |= mv_phone_dco_post_div_config(pdev, priv->pclk_freq_mhz);
+		if (err < 0)
+			return err;
+	}
+
+	mvSysTdmInit(priv->tdm_params);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops mvebu_phone_pmops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mvebu_phone_suspend, mvebu_phone_resume)
+};
+
+#define MVEBU_PHONE_PMOPS (&mvebu_phone_pmops)
+
+#else
+#define MVEBU_PHONE_PMOPS NULL
+#endif
+
+static const struct of_device_id mvebu_phone_match[] = {
+	{ .compatible = "marvell,armada-380-tdm" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mvebu_phone_match);
+
+static struct platform_driver mvebu_phone_driver = {
+	.probe	= mvebu_phone_probe,
+	.remove	= mvebu_phone_remove,
+	.driver	= {
+		.name	= DRV_NAME,
+		.of_match_table = mvebu_phone_match,
+		.owner	= THIS_MODULE,
+		.pm	= MVEBU_PHONE_PMOPS,
+	},
+};
+
+module_platform_driver(mvebu_phone_driver);
+
+MODULE_DESCRIPTION("Marvell Telephony Driver");
+MODULE_AUTHOR("Marcin Wojtas <mw@semihalf.com>");
diff --git a/drivers/telephony/mvebu_phone/mv_phone_spi.c b/drivers/telephony/mvebu_phone/mv_phone_spi.c
new file mode 100644
index 0000000..35db67e
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/mv_phone_spi.c
@@ -0,0 +1,174 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	    notice, this list of conditions and the following disclaimer in the
+	    documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	    used to endorse or promote products derived from this software without
+	    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include "voiceband/tdm/mvTdm.h"
+#include "voiceband/mvSysTdmSpi.h"
+
+#define DRV_NAME "mvebu_phone_spi"
+
+#undef MVEBU_PHONE_SPI_DEBUG
+
+struct spi_device *slic_spi;
+
+/* Telephony register read via SPI interface. */
+void mvSysTdmSpiRead(u16 line_id, u8 *cmd_buff, u8 cmd_size,
+		     u8 *data_buff, u8 data_size, u32 spi_type)
+{
+	int err;
+
+#ifdef MVEBU_PHONE_SPI_DEBUG
+	pr_info("%s():line(%d) Spi ID=%d line_id=%d Spi CS=%d Spi type=%d\n",
+		__func__, __LINE__, slic_spi->master->bus_num, line_id,
+		slic_spi->chip_select , spi_type);
+#endif
+
+	err = spi_write_then_read(slic_spi, (const void *)cmd_buff, cmd_size,
+				  (void *)data_buff, data_size);
+	if (err)
+		dev_err(&slic_spi->dev, "SPI read failed\n");
+
+#ifdef MVEBU_PHONE_SPI_DEBUG
+	pr_info("CMD = 0x%x, cmd_size = 0x%x, DATA = 0x%x, data_size = 0x%x\n",
+		*cmd_buff, cmd_size, *data_buff, data_size);
+#endif
+}
+
+/* Telephony register write via SPI interface. */
+void mvSysTdmSpiWrite(u16 line_id, u8 *cmd_buff, u8 cmd_size,
+		      u8 *data_buff, u8 data_size, u32 spi_type)
+{
+	int err;
+	struct spi_message m;
+	struct spi_transfer t[2] = { { .tx_buf = (const void *)cmd_buff,
+				       .len = cmd_size, },
+				     { .tx_buf = (const void *)data_buff,
+				       .len = data_size, }, };
+
+#ifdef MVEBU_PHONE_SPI_DEBUG
+	pr_info("%s():line(%d) Spi ID=%d line_id=%d Spi CS=%d Spi type=%d\n",
+		__func__, __LINE__, slic_spi->master->bus_num, line_id,
+		slic_spi->chip_select , spi_type);
+	if (!cmd_buff) {printk ("ERROR - cmd_buff = 0x%x\n",cmd_buff); return;}
+	if (!data_buff) {printk ("ERROR - data_buff = 0x%x\n",data_buff); return;}
+	pr_info("CMD = 0x%x, cmd_size = 0x%x, DATA = 0x%x, data_size = 0x%x\n",
+		*cmd_buff, cmd_size, *data_buff, data_size);
+#endif
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+
+	err = spi_sync(slic_spi, &m);
+	if (err)
+		dev_err(&slic_spi->dev, "SPI write failed\n");
+}
+
+static int mvebu_phone_spi_probe(struct spi_device *spi)
+{
+	int err;
+
+	err = spi_setup(spi);
+	if (err) {
+		dev_err(&spi->dev, "spi setup failed\n");
+		return err;
+	}
+
+	slic_spi = spi;
+
+	dev_info(&spi->dev, "registered slic spi device at bus #%d, CS #%d",
+		 spi->master->bus_num, spi->chip_select);
+
+	return 0;
+}
+
+static int mvebu_phone_spi_remove(struct spi_device *spi)
+{
+	return 0;
+}
+
+static const struct spi_device_id mvebu_phone_spi_ids[] = {
+	{ "mv_slic", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, mvebu_phone_spi_ids);
+
+static struct spi_driver mvebu_phone_spi_driver = {
+	.driver = {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.id_table = mvebu_phone_spi_ids,
+	.probe	= mvebu_phone_spi_probe,
+	.remove	= mvebu_phone_spi_remove,
+};
+
+module_spi_driver(mvebu_phone_spi_driver);
+
+MODULE_DESCRIPTION("Marvell Telephony SPI Driver");
+MODULE_AUTHOR("Marcin Wojtas <mw@semihalf.com>");
diff --git a/drivers/telephony/mvebu_phone/plat/drv_dxt_if.h b/drivers/telephony/mvebu_phone/plat/drv_dxt_if.h
new file mode 100644
index 0000000..c96c809
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/plat/drv_dxt_if.h
@@ -0,0 +1,91 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef __PLAT_DRV_DXT_IF_H
+#define __PLAT_DRV_DXT_IF_H
+
+#ifdef CONFIG_OF
+#include "mvSysTdmConfig.h"
+#endif
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+
+/* Interface to drv_dxt driver */
+extern void drv_dxt_if_enable_irq(unsigned int irq);
+extern void drv_dxt_if_disable_irq(unsigned int irq);
+
+extern int drv_dxt_if_request_irq(unsigned int irq, irq_handler_t handler,
+			      unsigned long flags, const char *name, void *dev);
+extern void drv_dxt_if_free_irq(unsigned int irq, void *dev);
+
+extern void drv_dxt_if_spi_cs_set(unsigned int dev_no, unsigned int hi_lo);
+extern int drv_dxt_if_spi_ll_read_write(unsigned char *tx_data,
+	    unsigned int tx_size, unsigned char *rx_data, unsigned int rx_size);
+
+/* Internal hooks */
+extern void drv_dxt_if_signal_interrupt(void);
+
+typedef void (*handler)(unsigned long);
+#endif
diff --git a/drivers/telephony/mvebu_phone/plat/silabs_if.h b/drivers/telephony/mvebu_phone/plat/silabs_if.h
new file mode 100644
index 0000000..50bc0a8
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/plat/silabs_if.h
@@ -0,0 +1,87 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef __PLAT_SILABS_IF_H
+#define __PLAT_SILABS_IF_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <plat/drv_dxt_if.h>
+
+/* Interface to Silabs SLIC driver */
+extern void silabs_if_enable_irq(unsigned int device);
+extern void silabs_if_disable_irq(unsigned int device);
+extern void silabs_if_handler_register(handler func);
+extern void silabs_if_handler_unregister(void);
+extern void silabs_if_isi_interrupt(void);
+extern void silabs_if_spi_init(unsigned int line);
+extern void silabs_if_spi_read(unsigned int line,
+		unsigned char *cmd, unsigned char cmd_size,
+		unsigned char *data, unsigned char data_size);
+extern void silabs_if_spi_write(unsigned int line,
+		unsigned char *cmd, unsigned char cmd_size,
+		unsigned char *data, unsigned char data_size);
+
+#endif
diff --git a/drivers/telephony/mvebu_phone/plat/zarlink_if.h b/drivers/telephony/mvebu_phone/plat/zarlink_if.h
new file mode 100644
index 0000000..48bae5c
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/plat/zarlink_if.h
@@ -0,0 +1,86 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#ifndef __PLAT_ZARLINK_IF_H
+#define __PLAT_ZARLINK_IF_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <plat/drv_dxt_if.h>
+
+/* Interface to Zarlink SLIC driver */
+extern void zarlink_if_enable_irq(unsigned int device);
+extern void zarlink_if_disable_irq(unsigned int device);
+extern void zarlink_if_handler_register(handler func);
+extern void zarlink_if_handler_unregister(void);
+extern void zarlink_if_zsi_interrupt(void);
+extern void zarlink_if_spi_read(unsigned int line,
+		unsigned char *cmd, unsigned char cmd_size,
+		unsigned char *data, unsigned char data_size);
+extern void zarlink_if_spi_write(unsigned int line,
+		unsigned char *cmd, unsigned char cmd_size,
+		unsigned char *data, unsigned char data_size);
+
+#endif
diff --git a/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnit.c b/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnit.c
new file mode 100644
index 0000000..095f81a
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnit.c
@@ -0,0 +1,1087 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "voiceband/commUnit/mvCommUnit.h"
+
+#undef	MV_COMM_UNIT_DEBUG
+#define	MV_COMM_UNIT_RPT_SUPPORT /* Repeat mode must be set */
+#undef	MV_COMM_UNIT_TEST_SUPPORT
+
+/* defines */
+#define TOTAL_CHAINS		2
+#define CONFIG_RBSZ		16
+#define NEXT_BUFF(buff)		((buff + 1) % TOTAL_CHAINS)
+#define PREV_BUFF(buff)		(buff == 0 ? (TOTAL_CHAINS-1) : (buff-1))
+#define MAX_POLL_USEC		100000	/* 100ms */
+#define COMM_UNIT_SW_RST	(1 << 5)
+#define OLD_INT_WA_BIT		(1 << 15)
+
+/* globals */
+static MV_STATUS tdmEnable;
+static MV_STATUS pcmEnable;
+static MV_U8 spiMode;
+static MV_U8 maxCs;
+static MV_U8 sampleSize;
+static MV_U8 samplingCoeff;
+static MV_U16 totalChannels;
+static MV_U8 prevRxBuff, nextTxBuff;
+static MV_U8 *rxBuffVirt[TOTAL_CHAINS], *txBuffVirt[TOTAL_CHAINS];
+static MV_ULONG rxBuffPhys[TOTAL_CHAINS], txBuffPhys[TOTAL_CHAINS];
+static MV_TDM_MCDMA_RX_DESC *mcdmaRxDescPtr[TOTAL_CHAINS];
+static MV_TDM_MCDMA_TX_DESC *mcdmaTxDescPtr[TOTAL_CHAINS];
+static MV_ULONG mcdmaRxDescPhys[TOTAL_CHAINS], mcdmaTxDescPhys[TOTAL_CHAINS];
+static MV_TDM_DPRAM_ENTRY defDpramEntry = { 0, 0, 0x1, 0x1, 0, 0, 0x1, 0, 0, 0, 0 };
+static MV_U32 ctrlFamilyId;
+static MV_U16 ctrlModel;
+static MV_U16 ctrlRev;
+
+/* Static APIs */
+static MV_VOID mvCommUnitDescChainBuild(MV_VOID);
+static MV_VOID mvCommUnitMcdmaMcscStart(MV_VOID);
+static MV_VOID mvCommUnitMcdmaStop(MV_VOID);
+static MV_VOID mvCommUnitMcdmaMcscAbort(MV_VOID);
+
+static MV_COMMUNIT_IP_VERSION_T mvCommUnitIpVerGet(MV_U32 ctrlFamilyId)
+{
+	switch (ctrlFamilyId) {
+	case MV_65XX_DEV_ID:
+		return MV_COMMUNIT_IP_VER_ORIGIN;
+	case MV_78XX0:
+	case MV_88F66X0:
+	case MV_88F67X0:
+		return MV_COMMUNIT_IP_VER_REVISE_1;
+	default:
+		return MV_COMMUNIT_IP_VER_ORIGIN;
+	}
+}
+
+MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
+{
+	MV_U16 pcmSlot, index;
+	MV_U32 buffSize, chan;
+	MV_U32 totalRxDescSize, totalTxDescSize;
+	MV_U32 maxPoll, clkSyncCtrlReg;
+#if 0
+	MV_U32 chMask;
+#endif
+	MV_U32 count;
+	MV_TDM_DPRAM_ENTRY actDpramEntry, *pActDpramEntry;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Initialize driver resources */
+	tdmEnable = MV_FALSE;
+	pcmEnable = MV_FALSE;
+	spiMode = halData->spiMode;
+	maxCs = halData->maxCs;
+	totalChannels = tdmParams->totalChannels;
+	prevRxBuff = 0;
+	nextTxBuff = 0;
+	ctrlFamilyId = halData->familyId;
+	ctrlModel = halData->model;
+	ctrlRev = halData->ctrlRev;
+
+	/* Check parameters */
+	if ((tdmParams->totalChannels > MV_TDMMC_TOTAL_CHANNELS) ||
+	    (tdmParams->samplingPeriod > MV_TDM_MAX_SAMPLING_PERIOD)) {
+		mvOsPrintf("%s: Error, bad parameters\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* Extract sampling period coefficient */
+	samplingCoeff = (tdmParams->samplingPeriod / MV_TDM_BASE_SAMPLING_PERIOD);
+
+	sampleSize = tdmParams->pcmFormat;
+
+	/* Calculate single Rx/Tx buffer size */
+	buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff);
+
+	/* Allocate cached data buffers for all channels */
+	TRC_REC("%s: allocate %dB for data buffers totalChannels=%d\n",
+		__func__, (buffSize * totalChannels), totalChannels);
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		rxBuffVirt[index] =
+		    (MV_U8 *) mvOsIoCachedMalloc(NULL, ((buffSize * totalChannels) + CPU_D_CACHE_LINE_SIZE),
+						 &rxBuffPhys[index], NULL);
+		txBuffVirt[index] =
+		    (MV_U8 *) mvOsIoCachedMalloc(NULL, ((buffSize * totalChannels) + CPU_D_CACHE_LINE_SIZE),
+						 &txBuffPhys[index], NULL);
+
+		/* Check Rx buffer address & size alignment */
+		if (((MV_U32) rxBuffVirt[index] | buffSize) & (CONFIG_RBSZ - 1)) {
+			mvOsPrintf("%s: Error, unaligned Rx buffer address or size\n", __func__);
+			return MV_ERROR;
+		}
+
+		/* Clear buffers */
+		memset(rxBuffVirt[index], 0, (buffSize * totalChannels));
+		memset(txBuffVirt[index], 0, (buffSize * totalChannels));
+#ifdef MV_COMM_UNIT_TEST_SUPPORT
+	/* Fill Tx buffers with incremental pattern */
+		{
+			int i, j;
+			for (j = 0; j < totalChannels; j++) {
+				for (i = 0; i < buffSize; i++)
+					*(MV_U8 *) (txBuffVirt[index]+i+(j*buffSize)) = (MV_U8)(i+1);
+			}
+		}
+#endif
+
+		/* Flush+Inv buffers */
+		mvOsCacheFlushInv(NULL, rxBuffVirt[index], (buffSize * totalChannels));
+		mvOsCacheFlushInv(NULL, txBuffVirt[index], (buffSize * totalChannels));
+	}
+
+	/* Allocate non-cached MCDMA Rx/Tx descriptors */
+	totalRxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_RX_DESC);
+	totalTxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_TX_DESC);
+
+	TRC_REC("%s: allocate %dB for Rx/Tx descriptors\n", __func__, totalRxDescSize);
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		mcdmaRxDescPtr[index] = (MV_TDM_MCDMA_RX_DESC *) mvOsIoUncachedMalloc(NULL, totalRxDescSize,
+										      &mcdmaRxDescPhys[index], NULL);
+		mcdmaTxDescPtr[index] = (MV_TDM_MCDMA_TX_DESC *) mvOsIoUncachedMalloc(NULL, totalTxDescSize,
+										      &mcdmaTxDescPhys[index], NULL);
+
+		/* Check descriptors alignment */
+		if (((MV_U32) mcdmaRxDescPtr[index] | (MV_U32) mcdmaTxDescPtr[index]) &
+		    (sizeof(MV_TDM_MCDMA_RX_DESC) - 1)) {
+			mvOsPrintf("%s: Error, unaligned MCDMA Rx/Tx descriptors\n", __func__);
+			return MV_ERROR;
+		}
+
+		/* Clear descriptors */
+		memset(mcdmaRxDescPtr[index], 0, totalRxDescSize);
+		memset(mcdmaTxDescPtr[index], 0, totalTxDescSize);
+	}
+
+	/* Poll MCDMA for reset completion */
+	maxPoll = 0;
+	while ((maxPoll < MAX_POLL_USEC) && !(MV_REG_READ(MCDMA_GLOBAL_CONTROL_REG) & MCDMA_RID_MASK)) {
+		mvOsUDelay(1);
+		maxPoll++;
+	}
+
+	if (maxPoll >= MAX_POLL_USEC) {
+		mvOsPrintf("Error, MCDMA reset completion timout\n");
+		return MV_ERROR;
+	}
+
+	/* Poll MCSC for RAM initialization done */
+	if (!(MV_REG_READ(MCSC_GLOBAL_INT_CAUSE_REG) & MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK)) {
+		maxPoll = 0;
+		while ((maxPoll < MAX_POLL_USEC) &&
+		       !(MV_REG_READ(MCSC_GLOBAL_INT_CAUSE_REG) & MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK)) {
+			mvOsUDelay(1);
+			maxPoll++;
+		}
+
+		if (maxPoll >= MAX_POLL_USEC) {
+			mvOsPrintf("Error, MCDMA RAM initialization timout\n");
+			return MV_ERROR;
+		}
+	}
+
+	/***************************************************************/
+	/* MCDMA Configuration(use default MCDMA linked-list settings) */
+	/***************************************************************/
+	/* Set Rx Service Queue Arbiter Weight Register */
+	MV_REG_WRITE(RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG,
+			(MV_REG_READ(RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG) & ~(0x1f << 24))); /*| MCDMA_RSQW_MASK));*/
+
+	/* Set Tx Service Queue Arbiter Weight Register */
+	MV_REG_WRITE(TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG,
+			(MV_REG_READ(TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG) & ~(0x1f << 24)));	/*| MCDMA_TSQW_MASK));*/
+
+	for (chan = 0; chan < totalChannels; chan++) {
+		/* Set RMCCx */
+		MV_REG_WRITE(MCDMA_RECEIVE_CONTROL_REG(chan), CONFIG_RMCCx);
+
+		/* Set TMCCx */
+		MV_REG_WRITE(MCDMA_TRANSMIT_CONTROL_REG(chan), CONFIG_TMCCx);
+	}
+
+	/**********************/
+	/* MCSC Configuration */
+	/**********************/
+	/* Disable Rx/Tx channel balancing & Linear mode fix */
+	MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TCBD_MASK);
+#if 0
+	/* Unmask Rx/Tx channel balancing */
+	chMask = (0xffffffff & ~((MV_U32)((1 << totalChannels) - 1)));
+	MV_REG_WRITE(MCSC_RX_CHANNEL_BALANCING_MASK_REG, chMask);
+	MV_REG_WRITE(MCSC_TX_CHANNEL_BALANCING_MASK_REG, chMask);
+#endif
+
+	for (chan = 0; chan < totalChannels; chan++) {
+		MV_REG_WRITE(MCSC_CHx_RECEIVE_CONFIG_REG(chan), CONFIG_MRCRx);
+		MV_REG_WRITE(MCSC_CHx_TRANSMIT_CONFIG_REG(chan), CONFIG_MTCRx);
+	}
+
+	/* Enable RX/TX linear byte swap, only in linear mode */
+	if (MV_PCM_FORMAT_1BYTE == tdmParams->pcmFormat)
+		MV_REG_WRITE(MCSC_GLOBAL_CONFIG_EXTENDED_REG,
+			    (MV_REG_READ(MCSC_GLOBAL_CONFIG_EXTENDED_REG) & (~CONFIG_LINEAR_BYTE_SWAP)));
+	else
+		MV_REG_WRITE(MCSC_GLOBAL_CONFIG_EXTENDED_REG,
+			    (MV_REG_READ(MCSC_GLOBAL_CONFIG_EXTENDED_REG) | CONFIG_LINEAR_BYTE_SWAP));
+
+	/***********************************************/
+	/* Shared Bus to Crossbar Bridge Configuration */
+	/***********************************************/
+	/* Set Timeout Counter Register */
+	MV_REG_WRITE(TIME_OUT_COUNTER_REG, (MV_REG_READ(TIME_OUT_COUNTER_REG) | TIME_OUT_THRESHOLD_COUNT_MASK));
+
+	/*************************************************/
+	/* Time Division Multiplexing(TDM) Configuration */
+	/*************************************************/
+	pActDpramEntry = &actDpramEntry;
+	memcpy(&actDpramEntry, &defDpramEntry, sizeof(MV_TDM_DPRAM_ENTRY));
+	/* Set repeat mode bits for (sampleSize > 1) */
+	pActDpramEntry->rpt = ((sampleSize == MV_PCM_FORMAT_1BYTE) ? 0 : 1);
+
+	/* Reset all Rx/Tx DPRAM entries to default value */
+	for (index = 0; index < (2 * MV_TDM_MAX_HALF_DPRAM_ENTRIES); index++) {
+		MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+		MV_REG_WRITE(FLEX_TDM_TDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+	}
+
+	/* Set active Rx/Tx DPRAM entries */
+	for (chan = 0; chan < totalChannels; chan++) {
+		/* Same time slot number for both Rx & Tx */
+		pcmSlot = tdmParams->pcmSlot[chan];
+
+		/* Verify time slot is within frame boundries */
+		if (pcmSlot >= halData->frameTs) {
+			mvOsPrintf("Error, time slot(%d) exceeded maximum(%d)\n", pcmSlot, halData->frameTs);
+			return MV_ERROR;
+		}
+
+		/* Verify time slot is aligned to sample size */
+		if ((sampleSize > MV_PCM_FORMAT_1BYTE) && (pcmSlot & 1)) {
+			mvOsPrintf("Error, time slot(%d) not aligned to Linear PCM sample size\n", pcmSlot);
+			return MV_ERROR;
+		}
+
+		/* Update relevant DPRAM fields */
+		pActDpramEntry->ch = chan;
+		pActDpramEntry->mask = 0xff;
+
+		/* Extract physical DPRAM entry id */
+		index = ((sampleSize == MV_PCM_FORMAT_1BYTE) ? pcmSlot : (pcmSlot / 2));
+
+		/* DPRAM low half */
+		MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+		MV_REG_WRITE(FLEX_TDM_TDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+
+		/* DPRAM high half(mirroring DPRAM low half) */
+		pActDpramEntry->mask = 0;
+		MV_REG_WRITE(FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+		MV_REG_WRITE(FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+
+		/* WideBand mode */
+		if (sampleSize == MV_PCM_FORMAT_4BYTES) {
+			index = (index + (halData->frameTs / sampleSize));
+			/* DPRAM low half */
+			pActDpramEntry->mask = 0xff;
+			MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+			MV_REG_WRITE(FLEX_TDM_TDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+
+			/* DPRAM high half(mirroring DPRAM low half) */
+			pActDpramEntry->mask = 0;
+			MV_REG_WRITE(FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+			MV_REG_WRITE(FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+		}
+	}
+
+	/* Fill last Tx/Rx DPRAM entry('LAST'=1) */
+	pActDpramEntry->mask = 0;
+	pActDpramEntry->ch = 0;
+	pActDpramEntry->last = 1;
+
+	/* Index for last entry */
+	if (sampleSize == MV_PCM_FORMAT_1BYTE)
+		index = (halData->frameTs - 1);
+	else
+		index = ((halData->frameTs / 2) - 1);
+
+	/* Low half */
+	MV_REG_WRITE(FLEX_TDM_TDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+	MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+	/* High half */
+	MV_REG_WRITE(FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+	MV_REG_WRITE(FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+
+	/* Set TDM_CLK_AND_SYNC_CONTROL register */
+	clkSyncCtrlReg = MV_REG_READ(TDM_CLK_AND_SYNC_CONTROL_REG);
+	clkSyncCtrlReg &= ~(TDM_TX_FSYNC_OUT_ENABLE_MASK | TDM_RX_FSYNC_OUT_ENABLE_MASK |
+			TDM_TX_CLK_OUT_ENABLE_MASK | TDM_RX_CLK_OUT_ENABLE_MASK);
+	clkSyncCtrlReg |= CONFIG_TDM_CLK_AND_SYNC_CONTROL;
+	MV_REG_WRITE(TDM_CLK_AND_SYNC_CONTROL_REG, clkSyncCtrlReg);
+
+	/* Set TDM TCR register */
+	MV_REG_WRITE(FLEX_TDM_CONFIG_REG, (MV_REG_READ(FLEX_TDM_CONFIG_REG) | CONFIG_FLEX_TDM_CONFIG));
+
+#if 0
+	/* Set TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT register */
+	MV_REG_WRITE(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG, CONFIG_TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT);
+
+	/* Set TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN register */
+	MV_REG_WRITE(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG, CONFIG_TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN);
+
+	/* Restart calculation */
+	MV_REG_BIT_SET(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG,
+				(TX_SYNC_DELAY_OUT_RESTART_CALC_MASK | RX_SYNC_DELAY_OUT_RESTART_CALC_MASK));
+	MV_REG_BIT_SET(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG,
+				(TX_SYNC_DELAY_IN_RESTART_CALC_MASK | RX_SYNC_DELAY_IN_RESTART_CALC_MASK));
+	mvOsDelay(1);
+	MV_REG_BIT_RESET(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG,
+				(TX_SYNC_DELAY_OUT_RESTART_CALC_MASK | RX_SYNC_DELAY_OUT_RESTART_CALC_MASK));
+	MV_REG_BIT_RESET(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG,
+				(TX_SYNC_DELAY_IN_RESTART_CALC_MASK | RX_SYNC_DELAY_IN_RESTART_CALC_MASK));
+#endif
+
+	/* Set TDM_CLK_DIVIDER_CONTROL register */
+	/*MV_REG_WRITE(TDM_CLK_DIVIDER_CONTROL_REG, TDM_RX_FIXED_DIV_ENABLE_MASK); */
+
+	/* Enable SLIC/s interrupt detection(before Rx/Tx are active) */
+	/*MV_REG_WRITE(TDM_MASK_REG, TDM_SLIC_INT); */
+
+	/**********************************************************************/
+	/* Time Division Multiplexing(TDM) Interrupt Controller Configuration */
+	/**********************************************************************/
+	/* Clear TDM cause and mask registers */
+	MV_REG_WRITE(COMM_UNIT_TOP_MASK_REG, 0);
+	MV_REG_WRITE(TDM_MASK_REG, 0);
+	MV_REG_WRITE(COMM_UNIT_TOP_CAUSE_REG, 0);
+	MV_REG_WRITE(TDM_CAUSE_REG, 0);
+
+	/* Clear MCSC cause and mask registers(except InitDone bit) */
+	MV_REG_WRITE(MCSC_GLOBAL_INT_MASK_REG, 0);
+	MV_REG_WRITE(MCSC_EXTENDED_INT_MASK_REG, 0);
+	MV_REG_WRITE(MCSC_GLOBAL_INT_CAUSE_REG, MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK);
+	MV_REG_WRITE(MCSC_EXTENDED_INT_CAUSE_REG, 0);
+
+	/* Set output sync counter bits for FS */
+#if defined(MV_TDM_PCM_CLK_8MHZ)
+	count = MV_FRAME_128TS * 8;
+#elif defined(MV_TDM_PCM_CLK_4MHZ)
+	count = MV_FRAME_64TS * 8;
+#else /* MV_TDM_PCM_CLK_2MHZ */
+	count = MV_FRAME_32TS * 8;
+#endif
+	MV_REG_WRITE(TDM_OUTPUT_SYNC_BIT_COUNT_REG,
+		((count << TDM_SYNC_BIT_RX_OFFS) & TDM_SYNC_BIT_RX_MASK) | (count & TDM_SYNC_BIT_TX_MASK));
+
+#ifdef MV_COMM_UNIT_DEBUG
+	mvCommUnitShow();
+#endif
+
+	/* Enable PCM */
+	mvCommUnitPcmStart();
+
+	/* Mark TDM I/F as enabled */
+	tdmEnable = MV_TRUE;
+
+	/* Enable PCLK */
+	MV_REG_WRITE(TDM_DATA_DELAY_AND_CLK_CTRL_REG, (MV_REG_READ(TDM_DATA_DELAY_AND_CLK_CTRL_REG) |
+				CONFIG_TDM_DATA_DELAY_AND_CLK_CTRL));
+
+	/* Restore old periodic interrupt mechanism WA */
+	/* MV_REG_BIT_SET(TDM_DATA_DELAY_AND_CLK_CTRL_REG, OLD_INT_WA_BIT); */
+
+	/* Keep the software workaround to enable TEN while set Fsync for none-ALP chips */
+	/* Enable TDM */
+	if (MV_COMMUNIT_IP_VER_ORIGIN == mvCommUnitIpVerGet(ctrlFamilyId))
+		MV_REG_BIT_SET(FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+
+#if 0
+	/* Poll for Enter Hunt Execution Status */
+	for (chan = 0; chan < totalChannels; chan++) {
+		maxPoll = 0;
+		while ((maxPoll < MAX_POLL_USEC) &&
+			!(MV_REG_READ(MCSC_CHx_COMM_EXEC_STAT_REG(chan)) & MCSC_EH_E_STAT_MASK)) {
+			mvOsUDelay(1);
+			maxPoll++;
+		}
+
+		if (maxPoll >= MAX_POLL_USEC) {
+			mvOsPrintf("%s: Error, enter hunt execution timeout(ch%d)\n", __func__, chan);
+			return MV_ERROR;
+		}
+
+		MV_REG_BIT_RESET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ENTER_HUNT_MASK);
+	}
+#endif
+
+	MV_TRC_REC("<-%s\n", __func__);
+	return MV_OK;
+}
+
+MV_VOID mvCommUnitRelease(MV_VOID)
+{
+	MV_U32 buffSize, totalRxDescSize, totalTxDescSize, index;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	if (tdmEnable == MV_TRUE) {
+
+		/* Mark TDM I/F as disabled */
+		tdmEnable = MV_FALSE;
+
+		mvCommUnitPcmStop();
+
+		mvCommUnitMcdmaMcscAbort();
+
+		mvOsUDelay(10);
+		MV_REG_BIT_RESET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_MAI_MASK);
+
+		/* Disable TDM */
+		if (MV_COMMUNIT_IP_VER_ORIGIN == mvCommUnitIpVerGet(ctrlFamilyId))
+			MV_REG_BIT_RESET(FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+
+		/* Disable PCLK */
+		MV_REG_BIT_RESET(TDM_DATA_DELAY_AND_CLK_CTRL_REG, (TX_CLK_OUT_ENABLE_MASK | RX_CLK_OUT_ENABLE_MASK));
+
+		/* Reset CommUnit blocks to default settings */
+		MV_REG_BIT_RESET(0x18220, COMM_UNIT_SW_RST);
+		mvOsUDelay(1);
+		MV_REG_BIT_SET(0x18220, COMM_UNIT_SW_RST);
+		mvOsDelay(10);
+
+		/* Calculate total Rx/Tx buffer size */
+		buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels) + CPU_D_CACHE_LINE_SIZE;
+
+		/* Calculate total MCDMA Rx/Tx descriptors chain size */
+		totalRxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_RX_DESC);
+		totalTxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_TX_DESC);
+
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			/* Release Rx/Tx data buffers */
+			mvOsIoCachedFree(NULL, buffSize, rxBuffPhys[index], rxBuffVirt[index], 0);
+			mvOsIoCachedFree(NULL, buffSize, txBuffPhys[index], txBuffVirt[index], 0);
+
+			/* Release MCDMA Rx/Tx descriptors */
+			mvOsIoUncachedFree(NULL, totalRxDescSize, mcdmaRxDescPhys[index], mcdmaRxDescPtr[index], 0);
+			mvOsIoUncachedFree(NULL, totalTxDescSize, mcdmaTxDescPhys[index], mcdmaTxDescPtr[index], 0);
+		}
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+static MV_VOID mvCommUnitMcdmaMcscStart(MV_VOID)
+{
+	MV_U32 chan, rxDescPhysAddr, txDescPhysAddr;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	mvCommUnitDescChainBuild();
+
+	/* Set current Rx/Tx descriptors  */
+	for (chan = 0; chan < totalChannels; chan++) {
+		rxDescPhysAddr = mcdmaRxDescPhys[0] + (chan * sizeof(MV_TDM_MCDMA_RX_DESC));
+		txDescPhysAddr = mcdmaTxDescPhys[0] + (chan * sizeof(MV_TDM_MCDMA_TX_DESC));
+		MV_REG_WRITE(MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan), rxDescPhysAddr);
+		MV_REG_WRITE(MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan), txDescPhysAddr);
+	}
+
+	/* Restore MCDMA Rx/Tx control registers */
+	for (chan = 0; chan < totalChannels; chan++) {
+		/* Set RMCCx */
+		MV_REG_WRITE(MCDMA_RECEIVE_CONTROL_REG(chan), CONFIG_RMCCx);
+
+		/* Set TMCCx */
+		MV_REG_WRITE(MCDMA_TRANSMIT_CONTROL_REG(chan), CONFIG_TMCCx);
+	}
+
+	/* Set Rx/Tx periodical interrupts */
+	if (MV_COMMUNIT_IP_VER_ORIGIN == mvCommUnitIpVerGet(ctrlFamilyId))
+		MV_REG_WRITE(VOICE_PERIODICAL_INT_CONTROL_REG, CONFIG_VOICE_PERIODICAL_INT_CONTROL_WA);
+	else
+		MV_REG_WRITE(VOICE_PERIODICAL_INT_CONTROL_REG, CONFIG_VOICE_PERIODICAL_INT_CONTROL);
+
+	/* MCSC Global Tx Enable */
+	if (tdmEnable == MV_FALSE)
+		MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TXEN_MASK);
+
+	/* Enable MCSC-Tx & MCDMA-Rx */
+	for (chan = 0; chan < totalChannels; chan++) {
+		/* Enable Tx in TMCCx */
+		if (tdmEnable == MV_FALSE)
+			MV_REG_BIT_SET(MCSC_CHx_TRANSMIT_CONFIG_REG(chan), MTCRx_ET_MASK);
+
+		/* Enable Rx in: MCRDPx */
+		MV_REG_BIT_SET(MCDMA_RECEIVE_CONTROL_REG(chan), MCDMA_ERD_MASK);
+	}
+
+	/* MCSC Global Rx Enable */
+	if (tdmEnable == MV_FALSE)
+		MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_RXEN_MASK);
+
+	/* Enable MCSC-Rx & MCDMA-Tx */
+	for (chan = 0; chan < totalChannels; chan++) {
+		/* Enable Rx in RMCCx */
+		if (tdmEnable == MV_FALSE)
+			MV_REG_BIT_SET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ER_MASK);
+
+		/* Enable Tx in MCTDPx */
+		MV_REG_BIT_SET(MCDMA_TRANSMIT_CONTROL_REG(chan), MCDMA_TXD_MASK);
+	}
+
+	/* Disable Rx/Tx return to half */
+	MV_REG_BIT_RESET(FLEX_TDM_CONFIG_REG, (TDM_RR2HALF_MASK | TDM_TR2HALF_MASK));
+	/* Wait at least 1 frame */
+	mvOsUDelay(200);
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+MV_VOID mvCommUnitPcmStart(MV_VOID)
+{
+	MV_U32 maskReg;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	if (pcmEnable == MV_FALSE) {
+
+		/* Mark PCM I/F as enabled  */
+		pcmEnable = MV_TRUE;
+
+		mvCommUnitMcdmaMcscStart();
+
+		/* Clear TDM cause and mask registers */
+		MV_REG_WRITE(COMM_UNIT_TOP_MASK_REG, 0);
+		MV_REG_WRITE(TDM_MASK_REG, 0);
+		MV_REG_WRITE(COMM_UNIT_TOP_CAUSE_REG, 0);
+		MV_REG_WRITE(TDM_CAUSE_REG, 0);
+
+		/* Clear MCSC cause and mask registers(except InitDone bit) */
+		MV_REG_WRITE(MCSC_GLOBAL_INT_MASK_REG, 0);
+		MV_REG_WRITE(MCSC_EXTENDED_INT_MASK_REG, 0);
+		MV_REG_WRITE(MCSC_GLOBAL_INT_CAUSE_REG, MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK);
+		MV_REG_WRITE(MCSC_EXTENDED_INT_CAUSE_REG, 0);
+
+		/* Enable unit interrupts */
+		maskReg = MV_REG_READ(TDM_MASK_REG);
+		MV_REG_WRITE(TDM_MASK_REG, (maskReg | CONFIG_TDM_CAUSE));
+		MV_REG_WRITE(COMM_UNIT_TOP_MASK_REG, CONFIG_COMM_UNIT_TOP_MASK);
+
+		/* Enable TDM */
+		if (MV_COMMUNIT_IP_VER_REVISE_1 == mvCommUnitIpVerGet(ctrlFamilyId))
+			MV_REG_BIT_SET(FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+static MV_VOID mvCommUnitMcdmaMcscAbort(MV_VOID)
+{
+	MV_U32 chan;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Abort MCSC/MCDMA in case we got here from mvCommUnitRelease() */
+	if (tdmEnable == MV_FALSE) {
+
+#if 0
+		/* MCSC Rx Abort */
+		for (chan = 0; chan < totalChannels; chan++)
+			MV_REG_BIT_SET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ABORT_MASK);
+
+		for (chan = 0; chan < totalChannels; chan++) {
+			maxPoll = 0;
+			while ((maxPoll < MAX_POLL_USEC) &&
+				!(MV_REG_READ(MCSC_CHx_COMM_EXEC_STAT_REG(chan)) & MCSC_ABR_E_STAT_MASK)) {
+				mvOsUDelay(1);
+				maxPoll++;
+			}
+
+			if (maxPoll >= MAX_POLL_USEC) {
+				mvOsPrintf("%s: Error, MCSC Rx abort timeout(ch%d)\n", __func__, chan);
+				return;
+			}
+
+			MV_REG_BIT_RESET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ABORT_MASK);
+		}
+
+		/* MCDMA Tx Abort */
+		for (chan = 0; chan < totalChannels; chan++)
+			MV_REG_BIT_SET(MCDMA_TRANSMIT_CONTROL_REG(chan), MCDMA_AT_MASK);
+
+		for (chan = 0; chan < totalChannels; chan++) {
+			maxPoll = 0;
+			while ((maxPoll < MAX_POLL_USEC) &&
+				(MV_REG_READ(MCDMA_RECEIVE_CONTROL_REG(chan)) & MCDMA_ERD_MASK)) {
+				mvOsUDelay(1);
+				maxPoll++;
+			}
+
+			if (maxPoll >= MAX_POLL_USEC) {
+				mvOsPrintf("%s: Error, MCDMA Rx abort timeout(ch%d)\n", __func__, chan);
+				return;
+			}
+
+			maxPoll = 0;
+			while ((maxPoll < MAX_POLL_USEC) &&
+				(MV_REG_READ(MCDMA_TRANSMIT_CONTROL_REG(chan)) & MCDMA_AT_MASK)) {
+				mvOsUDelay(1);
+				maxPoll++;
+			}
+
+			if (maxPoll >= MAX_POLL_USEC) {
+				mvOsPrintf("%s: Error, MCDMA Tx abort timeout(ch%d)\n", __func__, chan);
+				return;
+			}
+		}
+#endif
+		/* Clear MCSC Rx/Tx channel enable */
+		for (chan = 0; chan < totalChannels; chan++) {
+			MV_REG_BIT_RESET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ER_MASK);
+			MV_REG_BIT_RESET(MCSC_CHx_TRANSMIT_CONFIG_REG(chan), MTCRx_ET_MASK);
+		}
+
+		/* MCSC Global Rx/Tx Disable */
+		MV_REG_BIT_RESET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_RXEN_MASK);
+		MV_REG_BIT_RESET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TXEN_MASK);
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+static MV_VOID mvCommUnitMcdmaStop(MV_VOID)
+{
+	MV_U32 index, chan, maxPoll, currTxDesc;
+	MV_U32 currRxDesc, nextTxBuff = 0, nextRxBuff = 0;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/***************************/
+	/*    Stop MCDMA - Rx/Tx   */
+	/***************************/
+	for (chan = 0; chan < totalChannels; chan++) {
+		currRxDesc = MV_REG_READ(MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan));
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			if (currRxDesc == (mcdmaRxDescPhys[index] + (chan*(sizeof(MV_TDM_MCDMA_RX_DESC))))) {
+				nextRxBuff = NEXT_BUFF(index);
+				break;
+			}
+		}
+
+		if (index == TOTAL_CHAINS) {
+			mvOsPrintf("%s: ERROR, couldn't Rx descriptor match for chan(%d)\n", __func__, chan);
+			break;
+		}
+
+		((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[nextRxBuff] + chan))->physNextDescPtr = 0;
+		((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[nextRxBuff] + chan))->cmdStatus = (LAST_BIT | OWNER);
+	}
+
+	for (chan = 0; chan < totalChannels; chan++) {
+		currTxDesc = MV_REG_READ(MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan));
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			if (currTxDesc == (mcdmaTxDescPhys[index] + (chan*(sizeof(MV_TDM_MCDMA_TX_DESC))))) {
+				nextTxBuff = NEXT_BUFF(index);
+				break;
+			}
+		}
+
+		if (index == TOTAL_CHAINS) {
+			mvOsPrintf("%s: ERROR, couldn't Tx descriptor match for chan(%d)\n", __func__, chan);
+			return;
+		}
+
+		((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[nextTxBuff] + chan))->physNextDescPtr = 0;
+		((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[nextTxBuff] + chan))->cmdStatus = (LAST_BIT | OWNER);
+	}
+
+	for (chan = 0; chan < totalChannels; chan++) {
+		maxPoll = 0;
+		while ((maxPoll < MAX_POLL_USEC) &&
+			(MV_REG_READ(MCDMA_TRANSMIT_CONTROL_REG(chan)) & MCDMA_TXD_MASK)) {
+			mvOsUDelay(1);
+			maxPoll++;
+		}
+
+		if (maxPoll >= MAX_POLL_USEC) {
+			mvOsPrintf("%s: Error, MCDMA TXD polling timeout(ch%d)\n", __func__, chan);
+			return;
+		}
+
+		maxPoll = 0;
+		while ((maxPoll < MAX_POLL_USEC) &&
+			(MV_REG_READ(MCDMA_RECEIVE_CONTROL_REG(chan)) & MCDMA_ERD_MASK)) {
+			mvOsUDelay(1);
+			maxPoll++;
+		}
+
+		if (maxPoll >= MAX_POLL_USEC) {
+			mvOsPrintf("%s: Error, MCDMA ERD polling timeout(ch%d)\n", __func__, chan);
+			return;
+		}
+	}
+
+	/* Disable Rx/Tx periodical interrupts */
+	MV_REG_WRITE(VOICE_PERIODICAL_INT_CONTROL_REG, 0xffffffff);
+
+	/* Enable Rx/Tx return to half */
+	MV_REG_BIT_SET(FLEX_TDM_CONFIG_REG, (TDM_RR2HALF_MASK | TDM_TR2HALF_MASK));
+	/* Wait at least 1 frame */
+	mvOsUDelay(200);
+
+	/* Manual reset to channel-balancing mechanism */
+	MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_MAI_MASK);
+	mvOsUDelay(1);
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+MV_VOID mvCommUnitPcmStop(MV_VOID)
+{
+	MV_U32 buffSize, index;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	if (pcmEnable == MV_TRUE) {
+		/* Mark PCM I/F as disabled  */
+		pcmEnable = MV_FALSE;
+
+		/* Clear TDM cause and mask registers */
+		MV_REG_WRITE(COMM_UNIT_TOP_MASK_REG, 0);
+		MV_REG_WRITE(TDM_MASK_REG, 0);
+		MV_REG_WRITE(COMM_UNIT_TOP_CAUSE_REG, 0);
+		MV_REG_WRITE(TDM_CAUSE_REG, 0);
+
+		/* Clear MCSC cause and mask registers(except InitDone bit) */
+		MV_REG_WRITE(MCSC_GLOBAL_INT_MASK_REG, 0);
+		MV_REG_WRITE(MCSC_EXTENDED_INT_MASK_REG, 0);
+		MV_REG_WRITE(MCSC_GLOBAL_INT_CAUSE_REG, MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK);
+		MV_REG_WRITE(MCSC_EXTENDED_INT_CAUSE_REG, 0);
+
+		mvCommUnitMcdmaStop();
+
+		/* Calculate total Rx/Tx buffer size */
+		buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels);
+
+		/* Clear Rx buffers */
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			memset(rxBuffVirt[index], 0, buffSize);
+
+			/* Flush+Inv buffers */
+			mvOsCacheFlushInv(NULL, txBuffVirt[index], buffSize);
+		}
+
+		/* Disable TDM */
+		if (MV_COMMUNIT_IP_VER_REVISE_1 == mvCommUnitIpVerGet(ctrlFamilyId))
+			MV_REG_BIT_RESET(FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+MV_STATUS mvCommUnitTx(MV_U8 *pTdmTxBuff)
+{
+	MV_U32 buffSize;
+	MV_U8 tmp;
+	MV_U32 index;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Calculate total Tx buffer size */
+	buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels);
+
+	if (MV_COMMUNIT_IP_VER_ORIGIN == mvCommUnitIpVerGet(ctrlFamilyId)) {
+		if (sampleSize > MV_PCM_FORMAT_1BYTE) {
+			TRC_REC("Linear mode(Tx): swapping bytes\n");
+			for (index = 0; index < buffSize; index += 2) {
+				tmp = pTdmTxBuff[index];
+				pTdmTxBuff[index] = pTdmTxBuff[index+1];
+				pTdmTxBuff[index+1] = tmp;
+			}
+			TRC_REC("Linear mode(Tx): swapping bytes...done.\n");
+		}
+	}
+
+	/* Flush+Invalidate the next Tx buffer */
+	mvOsCacheFlush(NULL, pTdmTxBuff, buffSize);
+	mvOsCacheInvalidate(NULL, pTdmTxBuff, buffSize);
+
+	MV_TRC_REC("<-%s\n", __func__);
+	return MV_OK;
+}
+
+MV_STATUS mvCommUnitRx(MV_U8 *pTdmRxBuff)
+{
+	MV_U32 buffSize;
+	MV_U8 tmp;
+	MV_U32 index;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Calculate total Rx buffer size */
+	buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels);
+
+	/* Invalidate current received buffer from cache */
+	mvOsCacheInvalidate(NULL, pTdmRxBuff, buffSize);
+
+	if (MV_COMMUNIT_IP_VER_ORIGIN == mvCommUnitIpVerGet(ctrlFamilyId)) {
+		if (sampleSize > MV_PCM_FORMAT_1BYTE) {
+			TRC_REC("  -> Linear mode(Rx): swapping bytes\n");
+			for (index = 0; index < buffSize; index += 2) {
+				tmp = pTdmRxBuff[index];
+				pTdmRxBuff[index] = pTdmRxBuff[index+1];
+				pTdmRxBuff[index+1] = tmp;
+			}
+			TRC_REC("  <- Linear mode(Rx): swapping bytes...done.\n");
+		}
+	}
+	MV_TRC_REC("<-%s\n", __func__);
+	return MV_OK;
+}
+
+/* Low level TDM interrupt service routine */
+MV_32 mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo)
+{
+	MV_U32 causeReg, maskReg, causeAndMask;
+	MV_U32 intAckBits = 0, currDesc;
+	MV_U8 index;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Read TDM cause & mask registers */
+	causeReg = MV_REG_READ(TDM_CAUSE_REG);
+	maskReg = MV_REG_READ(TDM_MASK_REG);
+
+	MV_TRC_REC("CAUSE(0x%x), MASK(0x%x)\n", causeReg, maskReg);
+
+	/* Refer only to unmasked bits */
+	causeAndMask = causeReg & maskReg;
+
+	/* Reset ISR params */
+	pTdmIntInfo->tdmRxBuff = NULL;
+	pTdmIntInfo->tdmTxBuff = NULL;
+	pTdmIntInfo->intType = MV_EMPTY_INT;
+
+#if 0
+	/* Handle SLIC interrupt */
+	slicInt = (causeAndMask & TDM_SLIC_INT);
+	if (slicInt) {
+		MV_TRC_REC("SLIC interrupt !!!\n");
+		pTdmIntInfo->intType |= MV_PHONE_INT;
+		for (cs = 0; cs < maxCs; cs++) {
+			if (slicInt & MV_BIT_MASK(cs + EXT_INT_SLIC0_OFFS)) {
+				pTdmIntInfo->cs = cs;
+				mvOsPrintf("");
+				intAckBits |= MV_BIT_MASK(cs + EXT_INT_SLIC0_OFFS);
+				break;
+			}
+
+		}
+		mvOsPrintf("pTdmIntInfo->cs = %d\n", pTdmIntInfo->cs);
+	}
+#endif
+	/* Return in case TDM is disabled */
+	if (tdmEnable == MV_FALSE) {
+		MV_TRC_REC("TDM is disabled - quit low level ISR\n");
+		MV_REG_WRITE(TDM_CAUSE_REG, ~intAckBits);
+		return 0;
+	}
+
+	/* Handle TDM Error/s */
+	if (causeAndMask & TDM_ERROR_INT) {
+		mvOsPrintf("TDM Error: TDM_CAUSE_REG = 0x%x\n", causeReg);
+		/*pTdmIntInfo->intType |= MV_ERROR_INT;*/
+		intAckBits |= (causeAndMask & TDM_ERROR_INT);
+	}
+
+	if (causeAndMask & (TDM_TX_INT | TDM_RX_INT)) {
+		/* MCDMA current Tx desc. pointer is unreliable, thus, checking Rx desc. pointer only */
+		currDesc = MV_REG_READ(MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(0));
+		MV_TRC_REC("currDesc = 0x%x\n", currDesc);
+
+		/* Handle Tx */
+		if (causeAndMask & TDM_TX_INT) {
+			for (index = 0; index < TOTAL_CHAINS; index++) {
+				if (currDesc == mcdmaRxDescPhys[index]) {
+					nextTxBuff = NEXT_BUFF(index);
+					break;
+				}
+			}
+			MV_TRC_REC("Tx interrupt(nextTxBuff=%d)!!!\n", nextTxBuff);
+			pTdmIntInfo->tdmTxBuff = txBuffVirt[nextTxBuff];
+			pTdmIntInfo->intType |= MV_TX_INT;
+			intAckBits |= TDM_TX_INT;
+		}
+
+		/* Handle Rx */
+		if (causeAndMask & TDM_RX_INT) {
+			for (index = 0; index < TOTAL_CHAINS; index++) {
+				if (currDesc == mcdmaRxDescPhys[index]) {
+					prevRxBuff = PREV_BUFF(index);
+					break;
+				}
+			}
+			MV_TRC_REC("Rx interrupt(prevRxBuff=%d)!!!\n", prevRxBuff);
+			pTdmIntInfo->tdmRxBuff = rxBuffVirt[prevRxBuff];
+			pTdmIntInfo->intType |= MV_RX_INT;
+			intAckBits |= TDM_RX_INT;
+		}
+	}
+
+	/* Clear TDM interrupts */
+	MV_REG_WRITE(TDM_CAUSE_REG, ~intAckBits);
+
+	TRC_REC("<-%s\n", __func__);
+	return 0;
+}
+
+static MV_VOID mvCommUnitDescChainBuild(MV_VOID)
+{
+	MV_U32 chan, index, buffSize;
+
+	TRC_REC("->%s\n", __func__);
+
+	/* Calculate single Rx/Tx buffer size */
+	buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff);
+
+	/* Initialize descriptors fields */
+	for (chan = 0; chan < totalChannels; chan++) {
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			/* Associate data buffers to descriptors physBuffPtr */
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->physBuffPtr =
+			    (MV_U32) (rxBuffPhys[index] + (chan * buffSize));
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->physBuffPtr =
+			    (MV_U32) (txBuffPhys[index] + (chan * buffSize));
+
+			/* Build cyclic descriptors chain for each channel */
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->physNextDescPtr =
+			    (MV_U32) (mcdmaRxDescPhys[((index + 1) % TOTAL_CHAINS)] +
+				      (chan * sizeof(MV_TDM_MCDMA_RX_DESC)));
+
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->physNextDescPtr =
+			    (MV_U32) (mcdmaTxDescPhys[((index + 1) % TOTAL_CHAINS)] +
+				      (chan * sizeof(MV_TDM_MCDMA_TX_DESC)));
+
+			/* Set Byte_Count/Buffer_Size Rx descriptor fields */
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->byteCnt = 0;
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->buffSize = buffSize;
+
+			/* Set Shadow_Byte_Count/Byte_Count Tx descriptor fields */
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->shadowByteCnt = buffSize;
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->byteCnt = buffSize;
+
+			/* Set Command/Status Rx/Tx descriptor fields */
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->cmdStatus =
+			    (CONFIG_MCDMA_DESC_CMD_STATUS);
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->cmdStatus =
+			    (CONFIG_MCDMA_DESC_CMD_STATUS);
+		}
+	}
+
+	TRC_REC("<-%s\n", __func__);
+	return;
+}
+
+MV_VOID mvCommUnitIntEnable(MV_U8 deviceId)
+{
+	/* MV_REG_BIT_SET(MV_GPP_IRQ_MASK_REG(0), BIT23); */
+}
+
+MV_VOID mvCommUnitIntDisable(MV_U8 deviceId)
+{
+	/* MV_REG_BIT_RESET(MV_GPP_IRQ_MASK_REG(0), BIT23); */
+}
+
+MV_VOID mvCommUnitShow(MV_VOID)
+{
+	MV_U32 index;
+
+	/* Dump data buffers & descriptors addresses */
+	for (index = 0; index < TOTAL_CHAINS; index++) {
+		mvOsPrintf("Rx Buff(%d): virt = 0x%x, phys = 0x%x\n", index, (MV_U32) rxBuffVirt[index],
+			   (MV_U32) rxBuffPhys[index]);
+		mvOsPrintf("Tx Buff(%d): virt = 0x%x, phys = 0x%x\n", index, (MV_U32) txBuffVirt[index],
+			   (MV_U32) txBuffPhys[index]);
+
+		mvOsPrintf("Rx Desc(%d): virt = 0x%x, phys = 0x%x\n", index,
+			   (MV_U32) mcdmaRxDescPtr[index], (MV_U32) mcdmaRxDescPhys[index]);
+
+		mvOsPrintf("Tx Desc(%d): virt = 0x%x, phys = 0x%x\n", index,
+			   (MV_U32) mcdmaTxDescPtr[index], (MV_U32) mcdmaTxDescPhys[index]);
+
+	}
+}
+
+MV_STATUS mvCommUnitResetSlic(MV_VOID)
+{
+	/* Enable SLIC reset */
+	MV_REG_BIT_RESET(TDM_CLK_AND_SYNC_CONTROL_REG, TDM_PROG_TDM_SLIC_RESET_MASK);
+
+	mvOsUDelay(60);
+
+	/* Release SLIC reset */
+	MV_REG_BIT_SET(TDM_CLK_AND_SYNC_CONTROL_REG, TDM_PROG_TDM_SLIC_RESET_MASK);
+
+	return MV_OK;
+}
diff --git a/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnit.h b/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnit.h
new file mode 100644
index 0000000..7fbe0d3
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnit.h
@@ -0,0 +1,194 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCommUnith
+#define __INCmvCommUnith
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "voiceband/commUnit/mvCommUnitRegs.h"
+#include "voiceband/mvSysTdmSpi.h"
+#include "voiceband/common/mvTdmComm.h"
+#include "mvSysTdmConfig.h"
+
+/* Defines */
+#define MV_TDMMC_TOTAL_CHANNELS			32
+#define MV_TDM_MAX_HALF_DPRAM_ENTRIES		128
+#define MV_TDM_MAX_SAMPLING_PERIOD		30	/* ms */
+#define MV_TDM_BASE_SAMPLING_PERIOD		10	/* ms */
+#define MV_TDM_TOTAL_CH_SAMPLES			80	/* samples */
+
+typedef enum {
+	MV_COMMUNIT_IP_VER_ORIGIN   = 0,
+	MV_COMMUNIT_IP_VER_REVISE_1,
+} MV_COMMUNIT_IP_VERSION_T;
+
+/* IRQ types */
+#define MV_EMPTY_INT			0
+#define MV_RX_INT			BIT0
+#define	MV_TX_INT			BIT1
+#define	MV_PHONE_INT			BIT2
+#define	MV_RX_ERROR_INT			BIT3
+#define	MV_TX_ERROR_INT			BIT4
+#define MV_DMA_ERROR_INT		BIT5
+#define MV_ERROR_INT			(MV_RX_ERROR_INT | MV_TX_ERROR_INT | MV_DMA_ERROR_INT)
+
+#define TDM_SLIC_INT		(EXT_INT_SLIC0_MASK | EXT_INT_SLIC1_MASK | EXT_INT_SLIC2_MASK | EXT_INT_SLIC3_MASK)
+#define TDM_TX_INT		 TX_VOICE_INT_PULSE_MASK
+#define TDM_RX_INT		 RX_VOICE_INT_PULSE_MASK
+#define TDM_ERROR_INT		(FLEX_TDM_RX_SYNC_LOSS_MASK | FLEX_TDM_TX_SYNC_LOSS_MASK | \
+				 COMM_UNIT_PAR_ERR_SUM_MASK | TDM_RX_PAR_ERR_SUM_MASK | TDM_TX_PAR_ERR_SUM_MASK | \
+				 MCSC_PAR_ERR_SUM_MASK | MCDMA_PAR_ERR_SUM_MASK)
+
+/* MCDMA Descriptor Command/Status Bits */
+#define	LAST_BIT	BIT16
+#define	FIRST_BIT	BIT17
+#define	EOPI		BIT21
+#define	ENABLE_INT	BIT23
+#define	AUTO_MODE	BIT30
+#define	OWNER		BIT31
+
+/* MCDMA */
+#define CONFIG_MCDMA_DESC_CMD_STATUS	(FIRST_BIT | AUTO_MODE | OWNER)
+#define CONFIG_RMCCx			(MCDMA_RBSZ_16BYTE | MCDMA_BLMR_MASK)
+#define CONFIG_TMCCx			(MCDMA_FSIZE_1BLK | MCDMA_TBSZ_16BYTE | MCDMA_BLMT_MASK)
+
+/* MCSC */
+#define CONFIG_MRCRx			(MRCRx_RRVD_MASK | MRCRx_MODE_MASK)
+#define CONFIG_MTCRx			(MTCRx_TRVD_MASK | MTCRx_MODE_MASK)
+#define CONFIG_LINEAR_BYTE_SWAP		(MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_MASK | \
+					 MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_MASK)
+
+/* TDM */
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_TDM_CLK_AND_SYNC_CONTROL	(TDM_TX_CLK_OUT_ENABLE_MASK | TDM_RX_CLK_OUT_ENABLE_MASK | \
+					 TDM_REFCLK_DIVIDER_BYPASS_MASK)
+#else
+#define CONFIG_TDM_CLK_AND_SYNC_CONTROL	(TDM_REFCLK_DIVIDER_BYPASS_MASK | TDM_OUT_CLK_SRC_CTRL_AFTER_DIV)
+#endif				/* MV_TDM_USE_EXTERNAL_PCLK_SOURCE */
+
+#define CONFIG_VOICE_PERIODICAL_INT_CONTROL (((MV_TDM_TOTAL_CH_SAMPLES) << RX_VOICE_INT_CNT_REF_OFFS) | \
+					     ((MV_TDM_TOTAL_CH_SAMPLES) << TX_VOICE_INT_CNT_REF_OFFS) | \
+					     (1 << RX_FIRST_DELAY_REF_OFFS) | (4 << TX_FIRST_DELAY_REF_OFFS))
+#define CONFIG_VOICE_PERIODICAL_INT_CONTROL_WA (((MV_TDM_TOTAL_CH_SAMPLES - 1) << RX_VOICE_INT_CNT_REF_OFFS) | \
+					     ((MV_TDM_TOTAL_CH_SAMPLES - 1) << TX_VOICE_INT_CNT_REF_OFFS) | \
+					     (1 << RX_FIRST_DELAY_REF_OFFS) | (4 << TX_FIRST_DELAY_REF_OFFS))
+#define CONFIG_TDM_CAUSE    		    (TDM_RX_INT | TDM_TX_INT /*| TDM_ERROR_INT*/)
+#define CONFIG_COMM_UNIT_TOP_MASK	    (TDM_SUM_INT_MASK | MCSC_SUM_INT_MASK)
+#define CONFIG_FLEX_TDM_CONFIG		    (TDM_SE_MASK | TDM_COMMON_RX_TX_MASK | TSD_NO_DELAY | RSD_NO_DELAY)
+#define	CONFIG_TDM_DATA_DELAY_AND_CLK_CTRL		(TX_CLK_OUT_ENABLE_MASK | RX_CLK_OUT_ENABLE_MASK)
+#define CONFIG_TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT	(TX_SYNC_DELAY_OUT_MINUS | RX_SYNC_DELAY_OUT_MINUS)
+#define CONFIG_TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN	(TX_SYNC_DELAY_IN_MINUS | RX_SYNC_DELAY_IN_MINUS)
+
+/* Structures */
+typedef struct {
+	MV_U32 cmdStatus;
+	MV_U16 byteCnt;
+	MV_U16 buffSize;
+	MV_U32 physBuffPtr;
+	MV_U32 physNextDescPtr;
+} MV_TDM_MCDMA_RX_DESC;
+
+typedef struct {
+	MV_U32 cmdStatus;
+	MV_U16 shadowByteCnt;
+	MV_U16 byteCnt;
+	MV_U32 physBuffPtr;
+	MV_U32 physNextDescPtr;
+} MV_TDM_MCDMA_TX_DESC;
+
+typedef struct {
+	MV_U32 mask:8;
+	MV_U32 ch:8;
+	MV_U32 mgs:2;
+	MV_U32 byte:1;
+	MV_U32 strb:2;
+	MV_U32 elpb:1;
+	MV_U32 tbs:1;
+	MV_U32 rpt:2;
+	MV_U32 last:1;
+	MV_U32 ftint:1;
+	MV_U32 reserved31_27:5;
+} MV_TDM_DPRAM_ENTRY;
+
+/* CommUnit APIs */
+	MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *pTdmParams, MV_TDM_HAL_DATA *halData);
+	MV_STATUS mvCommUnitWinInit(MV_UNIT_WIN_INFO *pAddrWinMap);
+	MV_32 mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo);
+	MV_VOID mvCommUnitPcmStart(MV_VOID);
+	MV_VOID mvCommUnitPcmStop(MV_VOID);
+	MV_STATUS mvCommUnitTx(MV_U8 *pTdmTxBuff);
+	MV_STATUS mvCommUnitRx(MV_U8 *pTdmRxBuff);
+	MV_VOID mvCommUnitShow(MV_VOID);
+	MV_VOID mvCommUnitRelease(MV_VOID);
+	MV_VOID mvCommUnitIntEnable(MV_U8 deviceId);
+	MV_VOID mvCommUnitIntDisable(MV_U8 deviceId);
+	MV_STATUS mvCommUnitResetSlic(MV_VOID);
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* __INCmvCommUnith */
diff --git a/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnitAddrDec.c b/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnitAddrDec.c
new file mode 100644
index 0000000..4604a50
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnitAddrDec.c
@@ -0,0 +1,339 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "voiceband/commUnit/mvCommUnitRegs.h"
+
+static MV_TARGET commUnitAddrDecPrioTable[] = {
+	SDRAM_CS0,
+	SDRAM_CS1,
+	SDRAM_CS2,
+	SDRAM_CS3,
+	PEX0_MEM,
+	PEX0_IO,
+	TBL_TERM
+};
+
+static MV_STATUS mvCommUnitWinRead(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin);
+static MV_STATUS mvCommUnitWinWrite(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin);
+static INLINE MV_VOID mvCommUnitWinEnable(MV_U32 winNum, MV_BOOL enable);
+static MV_STATUS commUnitWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin);
+
+/*******************************************************************************
+* mvCommUnitWinInit - Initialize CommUnit address decode windows
+*
+* DESCRIPTION:
+*               This function initialize CommUnit window decode unit. It set the
+*               default address decode
+*               windows of the unit.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if setting fail.
+*******************************************************************************/
+MV_STATUS mvCommUnitWinInit(MV_UNIT_WIN_INFO *pAddrWinMap)
+{
+	MV_U32 winNum;
+	MV_U32 winPrioIndex = 0;
+	MV_UNIT_WIN_INFO *addrDecWin;
+
+	/* Clear access for all windows */
+	MV_REG_WRITE(COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG, 0);
+
+	/* Disable all windows */
+	for (winNum = 0; winNum < COMM_UNIT_MBUS_MAX_WIN; winNum++)
+		mvCommUnitWinEnable(winNum, MV_FALSE);
+
+	for (winNum = 0; ((commUnitAddrDecPrioTable[winPrioIndex] != TBL_TERM) && (winNum < COMM_UNIT_MBUS_MAX_WIN));) {
+		addrDecWin = &pAddrWinMap[commUnitAddrDecPrioTable[winPrioIndex]];
+
+		if (addrDecWin->enable == MV_TRUE) {
+			if (MV_OK != mvCommUnitWinWrite(winNum, addrDecWin)) {
+				mvOsPrintf("mvCommUnitWinInit: failed setting window(%d)\n", winNum);
+				return MV_ERROR;
+			}
+			winNum++;
+		}
+		winPrioIndex++;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCommUnitWinWrite - Set CommUnit target address window
+*
+* DESCRIPTION:
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
+*       address window, also known as address decode window.
+*       After setting this target window, the CommUnit will be able to access the
+*       target within the address window.
+*
+* INPUT:
+*       winNum      - CommUnit to target address decode window number.
+*       pDecWin     - CommUnit target window data structure.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if address window overlaps with other address decode windows.
+*       MV_BAD_PARAM if base address is invalid parameter or target is
+*       unknown.
+*
+*******************************************************************************/
+static MV_STATUS mvCommUnitWinWrite(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
+{
+	MV_U32 ctrlReg = 0, sizeReg = 0;
+	MV_U32 size;
+
+	/* Parameter checking   */
+	if (winNum >= COMM_UNIT_MBUS_MAX_WIN) {
+		mvOsPrintf("mvCommUnitWinWrite: ERR. Invalid win num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the requested window overlaps with current windows         */
+	if (MV_TRUE == commUnitWinOverlapDetect(winNum, &pDecWin->addrWin)) {
+		mvOsPrintf("mvCommUnitWinWrite: ERR. Window %d overlap\n", winNum);
+		return MV_ERROR;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pDecWin->addrWin.baseLow, pDecWin->addrWin.size)) {
+		mvOsPrintf("mvCommUnitWinWrite: Error setting CommUnit window %d"
+			   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
+			   winNum, pDecWin->addrWin.baseLow, pDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	size = (pDecWin->addrWin.size / MV_COMM_UNIT_WIN_SIZE_ALIGN) - 1;
+
+	/* for the safe side we disable the window before writing the new
+	   values */
+	mvCommUnitWinEnable(winNum, MV_FALSE);
+
+	ctrlReg |= ((pDecWin->attrib << COMM_UNIT_WIN_ATTRIB_OFFS) & COMM_UNIT_WIN_ATTRIB_MASK);
+	ctrlReg |= ((pDecWin->targetId << COMM_UNIT_WIN_TARGET_OFFS) & COMM_UNIT_WIN_TARGET_MASK);
+	ctrlReg |= (pDecWin->addrWin.baseLow & COMM_UNIT_WIN_BASE_MASK);
+
+	/* Update Size value  */
+	sizeReg |= ((size << COMM_UNIT_WIN_SIZE_OFFS) & COMM_UNIT_WIN_SIZE_MASK);
+
+	/* Write to address size and control registers  */
+	MV_REG_WRITE(COMM_UNIT_WIN_SIZE_REG(winNum), sizeReg);
+	MV_REG_WRITE(COMM_UNIT_WIN_CTRL_REG(winNum), ctrlReg);
+
+	/* Enable address decode target window  */
+	if (pDecWin->enable == MV_TRUE)
+		mvCommUnitWinEnable(winNum, MV_TRUE);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCommUnitWinRead - Read peripheral target address window.
+*
+* DESCRIPTION:
+*               Read CommUnit peripheral target address window.
+*
+* INPUT:
+*       winNum - CommUnit to target address decode window number.
+*
+* OUTPUT:
+*       pDecWin - CommUnit target window data structure.
+*
+* RETURN:
+*       MV_ERROR if register parameters are invalid.
+*
+*******************************************************************************/
+MV_STATUS mvCommUnitWinRead(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
+{
+
+	MV_U32 ctrlReg, sizeReg, enReg;
+	MV_U32 size;
+
+	/* Parameter checking   */
+	if (winNum >= COMM_UNIT_MBUS_MAX_WIN) {
+		mvOsPrintf("mvCommUnitWinRead: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	sizeReg = MV_REG_READ(COMM_UNIT_WIN_SIZE_REG(winNum));
+	ctrlReg = MV_REG_READ(COMM_UNIT_WIN_CTRL_REG(winNum));
+	enReg = MV_REG_READ(COMM_UNIT_WIN_ENABLE_REG(winNum));
+
+	/* Check if window is enabled   */
+	if (enReg & COMM_UNIT_WIN_ENABLE_MASK) {
+		pDecWin->enable = MV_TRUE;
+
+		/* Extract window parameters from registers */
+		pDecWin->targetId = (ctrlReg & COMM_UNIT_WIN_TARGET_MASK) >> COMM_UNIT_WIN_TARGET_OFFS;
+		pDecWin->attrib = (ctrlReg & COMM_UNIT_WIN_ATTRIB_MASK) >> COMM_UNIT_WIN_ATTRIB_OFFS;
+		pDecWin->addrWin.baseLow = (ctrlReg & COMM_UNIT_WIN_BASE_MASK);
+		pDecWin->addrWin.baseHigh = 0;
+
+		size = (sizeReg & COMM_UNIT_WIN_SIZE_MASK) >> COMM_UNIT_WIN_SIZE_OFFS;
+		pDecWin->addrWin.size = (size + 1) * MV_COMM_UNIT_WIN_SIZE_ALIGN;
+	} else {
+		pDecWin->enable = MV_FALSE;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCommUnitWinEnable - Enable/disable a CommUnit to target address window
+*
+* DESCRIPTION:
+*       This function enable/disable a CommUnit to target address window.
+*       According to parameter 'enable' the routine will enable the
+*       window, thus enabling CommUnit accesses.
+*       Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - CommUnit to target address decode window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if decode window number was wrong or enabled window overlaps.
+*
+*******************************************************************************/
+static INLINE MV_VOID mvCommUnitWinEnable(MV_U32 winNum, MV_BOOL enable)
+{
+	MV_U32 enReg = 0, accProtWin = 0;
+
+	enReg = MV_REG_READ(COMM_UNIT_WIN_ENABLE_REG(winNum));
+	accProtWin = MV_REG_READ(COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG);
+
+	if (enable == MV_TRUE) {
+		MV_REG_WRITE(COMM_UNIT_WIN_ENABLE_REG(winNum), (enReg | COMM_UNIT_WIN_ENABLE_MASK));
+		MV_REG_WRITE(COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG, (accProtWin | COMM_UNIT_WIN_PROTECT_MASK(winNum)));
+
+	} else {
+		MV_REG_WRITE(COMM_UNIT_WIN_ENABLE_REG(winNum), 0 /*(enReg & ((MV_U32)~COMM_UNIT_WIN_ENABLE_MASK)) */);
+		MV_REG_WRITE(COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG,
+			     (accProtWin & ((MV_U32) ~COMM_UNIT_WIN_PROTECT_MASK(winNum))));
+	}
+}
+
+/*******************************************************************************
+* commUnitWinOverlapDetect - Detect CommUnit address windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviour is expected in case CommUnit address decode
+*       windows overlaps.
+*       This function detects CommUnit address decode windows overlapping of a
+*       specified window. The function does not check the window itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       winNum      - address decode window number.
+*       pDecWin     - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data
+*       from registers.
+*
+*******************************************************************************/
+static MV_STATUS commUnitWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 winNumIndex;
+	MV_UNIT_WIN_INFO addrDecWin;
+
+	for (winNumIndex = 0; winNumIndex < COMM_UNIT_MBUS_MAX_WIN; winNumIndex++) {
+		/* Do not check window itself       */
+		if (winNumIndex == winNum)
+			continue;
+
+		/* Get window parameters    */
+		if (MV_OK != mvCommUnitWinRead(winNumIndex, &addrDecWin)) {
+			mvOsPrintf("%s: ERR. TargetWinGet failed\n", __func__);
+			return MV_ERROR;
+		}
+
+		/* Do not check disabled windows    */
+		if (addrDecWin.enable == MV_FALSE)
+			continue;
+
+		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
+			return MV_TRUE;
+	}
+
+	return MV_FALSE;
+}
diff --git a/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnitRegs.h b/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnitRegs.h
new file mode 100644
index 0000000..acfdd9d
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/commUnit/mvCommUnitRegs.h
@@ -0,0 +1,462 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCommUnitRegsh
+#define __INCmvCommUnitRegsh
+
+#include "mvSysTdmConfig.h"
+
+/****************************************************************/
+/*	Time Division Multiplexing Interrupt Controller		*/
+/****************************************************************/
+#define COMM_UNIT_TOP_CAUSE_REG			(MV_COMM_UNIT_REGS_BASE + 0x8C00)
+#define TDM_CAUSE_REG				(MV_COMM_UNIT_REGS_BASE + 0x8C40)
+#define COMM_UNIT_TOP_MASK_REG			(MV_COMM_UNIT_REGS_BASE + 0x8C80)
+#define VOICE_PERIODICAL_INT_CONTROL_REG	(MV_COMM_UNIT_REGS_BASE + 0x8C90)
+#define TDM_MASK_REG				(MV_COMM_UNIT_REGS_BASE + 0x8CC0)
+
+/* COMM_UNIT_TOP_CAUSE_REG bits */
+#define TDM_SUM_INT_OFFS			6
+#define TDM_SUM_INT_MASK			(1 << TDM_SUM_INT_OFFS)
+#define MCSC_SUM_INT_OFFS			28
+#define MCSC_SUM_INT_MASK			(1 << MCSC_SUM_INT_OFFS)
+
+/* TDM_CAUSE_REG bits */
+#define FLEX_TDM_RX_INT_OFFS			2
+#define FLEX_TDM_RX_INT_MASK			(1 << FLEXTDM_RX_INT_OFFS)
+#define FLEX_TDM_RX_SYNC_LOSS_OFFS		3
+#define FLEX_TDM_RX_SYNC_LOSS_MASK		(1 << FLEX_TDM_RX_SYNC_LOSS_OFFS)
+#define FLEX_TDM_TX_INT_OFFS			6
+#define FLEX_TDM_TX_INT_MASK			(1 << FLEXTDM_TX_INT_OFFS)
+#define FLEX_TDM_TX_SYNC_LOSS_OFFS		7
+#define FLEX_TDM_TX_SYNC_LOSS_MASK		(1 << FLEX_TDM_TX_SYNC_LOSS_OFFS)
+#define RX_VOICE_INT_PULSE_OFFS			8
+#define RX_VOICE_INT_PULSE_MASK			(1 << RX_VOICE_INT_PULSE_OFFS)
+#define TX_VOICE_INT_PULSE_OFFS			9
+#define TX_VOICE_INT_PULSE_MASK			(1 << TX_VOICE_INT_PULSE_OFFS)
+#define EXT_INT_SLIC0_OFFS			10
+#define EXT_INT_SLIC0_MASK			(1 << EXT_INT_SLIC0_OFFS)
+#define EXT_INT_SLIC1_OFFS			11
+#define EXT_INT_SLIC1_MASK			(1 << EXT_INT_SLIC1_OFFS)
+#define EXT_INT_SLIC2_OFFS			12
+#define EXT_INT_SLIC2_MASK			(1 << EXT_INT_SLIC2_OFFS)
+#define EXT_INT_SLIC3_OFFS			13
+#define EXT_INT_SLIC3_MASK			(1 << EXT_INT_SLIC3_OFFS)
+#define EXT_INT_SLIC4_OFFS			14
+#define EXT_INT_SLIC4_MASK			(1 << EXT_INT_SLIC4_OFFS)
+#define EXT_INT_SLIC5_OFFS			15
+#define EXT_INT_SLIC5_MASK			(1 << EXT_INT_SLIC5_OFFS)
+#define EXT_INT_SLIC6_OFFS			16
+#define EXT_INT_SLIC6_MASK			(1 << EXT_INT_SLIC6_OFFS)
+#define EXT_INT_SLIC7_OFFS			17
+#define EXT_INT_SLIC7_MASK			(1 << EXT_INT_SLIC7_OFFS)
+#define COMM_UNIT_PAR_ERR_SUM_OFFS		18
+#define COMM_UNIT_PAR_ERR_SUM_MASK		(1 << COMM_UNIT_PAR_ERR_SUM_OFFS)
+#define TDM_RX_PAR_ERR_SUM_OFFS			19
+#define TDM_RX_PAR_ERR_SUM_MASK			(1 << TDM_RX_PAR_ERR_SUM_OFFS)
+#define TDM_TX_PAR_ERR_SUM_OFFS			20
+#define TDM_TX_PAR_ERR_SUM_MASK			(1 << TDM_TX_PAR_ERR_SUM_OFFS)
+#define MCSC_PAR_ERR_SUM_OFFS			21
+#define MCSC_PAR_ERR_SUM_MASK			(1 << MCSC_PAR_ERR_SUM_OFFS)
+#define MCDMA_PAR_ERR_SUM_OFFS			22
+#define MCDMA_PAR_ERR_SUM_MASK			(1 << MCDMA_PAR_ERR_SUM_OFFS)
+
+/*  VOICE_PERIODICAL_INT_CONTROL_REG bits  */
+#define RX_VOICE_INT_CNT_REF_OFFS		0
+#define RX_VOICE_INT_CNT_REF_MASK		(0xff << RX_VOICE_INT_CNT_REF_OFFS)
+#define TX_VOICE_INT_CNT_REF_OFFS		8
+#define TX_VOICE_INT_CNT_REF_MASK		(0xff << TX_VOICE_INT_CNT_REF_OFFS)
+#define RX_FIRST_DELAY_REF_OFFS			16
+#define RX_FIRST_DELAY_REF_MASK			(0xff << RX_FIRST_DELAY_REF_OFFS)
+#define TX_FIRST_DELAY_REF_OFFS			24
+#define TX_FIRST_DELAY_REF_MASK			(0xff << TX_FIRST_DELAY_REF_OFFS)
+
+/************************************************/
+/*	Multi-Channel Serial Controller(MCSC)  	*/
+/************************************************/
+#define MCSC_CHx_COMM_EXEC_STAT_REG(ch)		(MV_COMM_UNIT_REGS_BASE + (ch<<2))
+#define MCSC_CHx_RECEIVE_CONFIG_REG(ch)		((MV_COMM_UNIT_REGS_BASE + 0x400) + (ch<<2))
+#define MCSC_CHx_TRANSMIT_CONFIG_REG(ch)	((MV_COMM_UNIT_REGS_BASE + 0x1800) + (ch<<2))
+#define MCSC_GLOBAL_CONFIG_REG			(MV_COMM_UNIT_REGS_BASE + 0x2800)
+#define MCSC_GLOBAL_INT_CAUSE_REG		(MV_COMM_UNIT_REGS_BASE + 0x2804)
+#define MCSC_EXTENDED_INT_CAUSE_REG		(MV_COMM_UNIT_REGS_BASE + 0x2808)
+#define MCSC_GLOBAL_INT_MASK_REG		(MV_COMM_UNIT_REGS_BASE + 0x280C)
+#define MCSC_EXTENDED_INT_MASK_REG		(MV_COMM_UNIT_REGS_BASE + 0x2810)
+#define MCSC_TX_CHANNEL_BALANCING_MASK_REG	(MV_COMM_UNIT_REGS_BASE + 0x284C)
+#define MCSC_RX_CHANNEL_BALANCING_MASK_REG	(MV_COMM_UNIT_REGS_BASE + 0x2850)
+#define MCSC_GLOBAL_CONFIG_EXTENDED_REG		(MV_COMM_UNIT_REGS_BASE + 0x2890)
+
+/* MCSC_CHx_COMM_EXEC_STAT_REG bits */
+#define MCSC_ABR_E_STAT_OFFS			25
+#define MCSC_ABR_E_STAT_MASK			(1 << MCSC_ABR_E_STAT_OFFS)
+#define MCSC_EH_E_STAT_OFFS			26
+#define MCSC_EH_E_STAT_MASK			(1 << MCSC_EH_E_STAT_OFFS)
+
+/* MCSC_RECEIVE_CONFIG_REG(MRCRx) bits */
+#define MRCRx_ABORT_OFFS			21
+#define MRCRx_ABORT_MASK			(1 << MRCRx_ABORT_OFFS)
+#define MRCRx_ENTER_HUNT_OFFS			22
+#define MRCRx_ENTER_HUNT_MASK			(1 << MRCRx_ENTER_HUNT_OFFS)
+#define MRCRx_ER_OFFS				27
+#define MRCRx_ER_MASK				(1 << MRCRx_ER_OFFS)
+#define MRCRx_RRVD_OFFS				30
+#define MRCRx_RRVD_MASK				(1 << MRCRx_RRVD_OFFS)
+#define MRCRx_MODE_OFFS				31
+#define MRCRx_MODE_MASK				(1 << MRCRx_MODE_OFFS)
+
+/* MCSC_TRANSMIT_CONFIG_REG(MTCRx) bits */
+#define MTCRx_ET_OFFS				27
+#define MTCRx_ET_MASK				(1 << MTCRx_ET_OFFS)
+#define MTCRx_TRVD_OFFS				30
+#define MTCRx_TRVD_MASK				(1 << MTCRx_TRVD_OFFS)
+#define MTCRx_MODE_OFFS				31
+#define MTCRx_MODE_MASK				(1 << MTCRx_MODE_OFFS)
+
+/* MCSC_GLOBAL_CONFIG_REG bits */
+#define MCSC_GLOBAL_CONFIG_RCBD_OFFS		19
+#define MCSC_GLOBAL_CONFIG_RCBD_MASK		(1 << MCSC_GLOBAL_CONFIG_RCBD_OFFS)
+#define MCSC_GLOBAL_CONFIG_TCBD_OFFS		20
+#define MCSC_GLOBAL_CONFIG_TCBD_MASK		(1 << MCSC_GLOBAL_CONFIG_TCBD_OFFS)
+#define MCSC_GLOBAL_CONFIG_MAI_OFFS		21
+#define MCSC_GLOBAL_CONFIG_MAI_MASK		(1 << MCSC_GLOBAL_CONFIG_MAI_OFFS)
+#define MCSC_GLOBAL_CONFIG_LMD_OFFS		22
+#define MCSC_GLOBAL_CONFIG_LMD_MASK		(1 << MCSC_GLOBAL_CONFIG_LMD_OFFS)
+#define MCSC_GLOBAL_CONFIG_ARBM_OFFS		29
+#define MCSC_GLOBAL_CONFIG_ARBM_MASK		(1 << MCSC_GLOBAL_CONFIG_ARBM_OFFS)
+#define MCSC_GLOBAL_CONFIG_RXEN_OFFS		30
+#define MCSC_GLOBAL_CONFIG_RXEN_MASK		(1 << MCSC_GLOBAL_CONFIG_RXEN_OFFS)
+#define MCSC_GLOBAL_CONFIG_TXEN_OFFS		31
+#define MCSC_GLOBAL_CONFIG_TXEN_MASK		(1 << MCSC_GLOBAL_CONFIG_TXEN_OFFS)
+
+/* MCSC_GLOBAL_INT_CAUSE_REG */
+#define  MCSC_GLOBAL_INT_CAUSE_RXOR_OFFS	0
+#define  MCSC_GLOBAL_INT_CAUSE_RXOR_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_RXOR_OFFS)
+#define  MCSC_GLOBAL_INT_CAUSE_TXUR_OFFS	8
+#define  MCSC_GLOBAL_INT_CAUSE_TXUR_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_TXUR_OFFS)
+#define  MCSC_GLOBAL_INT_CAUSE_TXOR_OFFS	16
+#define  MCSC_GLOBAL_INT_CAUSE_TXOR_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_TXOR_OFFS)
+#define  MCSC_GLOBAL_INT_CAUSE_RXBOR_OFFS	24
+#define  MCSC_GLOBAL_INT_CAUSE_RXBOR_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_RXBOR_OFFS)
+#define  MCSC_GLOBAL_INT_CAUSE_INIT_DONE_OFFS	25
+#define  MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_INIT_DONE_OFFS)
+#define  MCSC_GLOBAL_INT_CAUSE_IQOR_OFFS	26
+#define  MCSC_GLOBAL_INT_CAUSE_IQOR_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_IQOR_OFFS)
+#define  MCSC_GLOBAL_INT_CAUSE_IQNE_OFFS	27
+#define  MCSC_GLOBAL_INT_CAUSE_IQNE_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_IQNE_OFFS)
+#define  MCSC_GLOBAL_INT_CAUSE_MDIL_OFFS	28
+#define  MCSC_GLOBAL_INT_CAUSE_MDIL_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_MDIL_OFFS)
+#define  MCSC_GLOBAL_INT_CAUSE_MGIS_OFFS	30
+#define  MCSC_GLOBAL_INT_CAUSE_MGIS_MASK	(1 << MCSC_GLOBAL_INT_CAUSE_MGIS_OFFS)
+
+/* MCSC_GLOBAL_CONFIG_EXTENDED_REG bits */
+#define  MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_OFFS	2
+#define  MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_MASK	(1 << MCSC_GLOBAL_CONFIG_LINEAR_TX_SWAP_OFFS)
+#define  MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_OFFS	3
+#define  MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_MASK	(1 << MCSC_GLOBAL_CONFIG_LINEAR_RX_SWAP_OFFS)
+
+/************************************************/
+/*	Multi-Channel DMA(MCDMA)       		*/
+/************************************************/
+#define MCDMA_RECEIVE_CONTROL_REG(ch)		((MV_COMM_UNIT_REGS_BASE + 0x3000) + (ch<<2))
+#define MCDMA_RECEIVE_FIFO_MGMT_LL_REG(ch)	((MV_COMM_UNIT_REGS_BASE + 0x3C00) + (ch<<2))
+#define MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(ch)	((MV_COMM_UNIT_REGS_BASE + 0x4000) + (ch<<2))
+#define MCDMA_GLOBAL_CONTROL_REG		(MV_COMM_UNIT_REGS_BASE + 0x4400)
+#define RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG	(MV_COMM_UNIT_REGS_BASE + 0x4408)
+#define MCDMA_TRANSMIT_CONTROL_REG(ch)		((MV_COMM_UNIT_REGS_BASE + 0x5000) + (ch<<2))
+#define MCDMA_TRANSMIT_FIFO_MGMT_LL_REG(ch)	((MV_COMM_UNIT_REGS_BASE + 0x5C00) + (ch<<2))
+#define MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(ch)	((MV_COMM_UNIT_REGS_BASE + 0x7000) + (ch<<2))
+#define TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG	(MV_COMM_UNIT_REGS_BASE + 0x7408)
+
+/* MCDMA_RECEIVE_CONTROL_REG bits */
+#define MCDMA_RBSZ_OFFS				0
+#define MCDMA_RBSZ_MASK				(0x3 << MCDMA_RBSZ_OFFS)
+#define MCDMA_RBSZ_8BYTE			0
+#define MCDMA_RBSZ_16BYTE			0x1
+#define MCDMA_RBSZ_32BYTE			0x2
+#define MCDMA_RBSZ_64BYTE			0x3
+
+#define MCDMA_BLMR_OFFS				2
+#define MCDMA_BLMR_MASK				(1 << MCDMA_BLMR_OFFS)
+#define MCDMA_ERD_OFFS				6
+#define MCDMA_ERD_MASK				(1 << MCDMA_ERD_OFFS)
+
+/* MCDMA_GLOBAL_CONTROL_REG bits */
+#define MCDMA_RID_OFFS				1
+#define MCDMA_RID_MASK				(1 << MCDMA_RID_OFFS)
+
+/* RX_SERVICE_QUEUE_ARBITER_WEIGHT_REG bits */
+#define MCDMA_RSQW_OFFS				24
+#define MCDMA_RSQW_MASK				(0x1f << MCDMA_RSQW_OFFS)
+
+/* TX_SERVICE_QUEUE_ARBITER_WEIGHT_REG bits */
+#define MCDMA_TSQW_OFFS				24
+#define MCDMA_TSQW_MASK				(0x1f << MCDMA_TSQW_OFFS)
+
+/* MCDMA_TRANSMIT_CONTROL_REG bits */
+#define MCDMA_FSIZE_OFFS			0
+#define MCDMA_FSIZE_MASK			(0xff << MCDMA_FSIZE_OFFS)
+#define MCDMA_FSIZE_1BLK			0x1
+#define MCDMA_TBSZ_OFFS				8
+#define MCDMA_TBSZ_MASK				(0x3 << MCDMA_TBSZ_OFFS)
+#define MCDMA_TBSZ_8BYTE			(0x0 << MCDMA_TBSZ_OFFS)
+#define MCDMA_TBSZ_16BYTE			(0x1 << MCDMA_TBSZ_OFFS)
+#define MCDMA_TBSZ_32BYTE			(0x2 << MCDMA_TBSZ_OFFS)
+
+#define MCDMA_BLMT_OFFS				10
+#define MCDMA_BLMT_MASK				(1 << MCDMA_BLMT_OFFS)
+#define MCDMA_NDUR_OFFS				12
+#define MCDMA_NDUR_MASK				(1 << MCDMA_NDUR_OFFS)
+#define MCDMA_TPC_OFFS				13
+#define MCDMA_TPC_MASK				(1 << MCDMA_TPC_OFFS)
+#define MCDMA_URPM_OFFS				14
+#define MCDMA_URPM_MASK				(1 << MCDMA_URPM_OFFS)
+#define MCDMA_STD_OFFS				15
+#define MCDMA_STD_MASK				(1 << MCDMA_STD_OFFS)
+#define MCDMA_AT_OFFS				16
+#define MCDMA_AT_MASK				(1 << MCDMA_AT_OFFS)
+#define MCDMA_TXD_OFFS				17
+#define MCDMA_TXD_MASK				(1 << MCDMA_TXD_OFFS)
+
+/************************************************/
+/*	Time Division Multiplexing(TDM)	  	*/
+/************************************************/
+#define FLEX_TDM_TDPR_REG(entry)		((MV_COMM_UNIT_REGS_BASE + 0x8000) + (entry<<2))
+#define FLEX_TDM_RDPR_REG(entry)		((MV_COMM_UNIT_REGS_BASE + 0x8400) + (entry<<2))
+#define FLEX_TDM_TRANSMIT_READ_PTR_REG		(MV_COMM_UNIT_REGS_BASE + 0x8800)
+#define FLEX_TDM_RECEIVE_READ_PTR_REG		(MV_COMM_UNIT_REGS_BASE + 0x8804)
+#define FLEX_TDM_CONFIG_REG			(MV_COMM_UNIT_REGS_BASE + 0x8808)
+#define TDM_CLK_AND_SYNC_CONTROL_REG		(MV_COMM_UNIT_REGS_BASE + 0x881C)
+#define TDM_CLK_DIVIDER_CONTROL_REG		(MV_COMM_UNIT_REGS_BASE + 0x8820)
+#define TDM_RESV_CLK_DIVIDER_CONTROL_REG	(MV_COMM_UNIT_REGS_BASE + 0x8824)
+#define TDM_OUTPUT_SYNC_BIT_COUNT_REG		(MV_COMM_UNIT_REGS_BASE + 0x8C8C)
+#define TDM_DATA_DELAY_AND_CLK_CTRL_REG		(MV_COMM_UNIT_REGS_BASE + 0x8CD0)
+#define TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG	(MV_COMM_UNIT_REGS_BASE + 0x8CD4)
+#define TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG	(MV_COMM_UNIT_REGS_BASE + 0x8CD8)
+
+/* TDM_CLK_AND_SYNC_CONTROL_REG bits */
+#define TDM_TX_FSYNC_OUT_ENABLE_OFFS		0
+#define TDM_TX_FSYNC_OUT_ENABLE_MASK		(1 << TDM_TX_FSYNC_OUT_ENABLE_OFFS)
+#define TDM_RX_FSYNC_OUT_ENABLE_OFFS		1
+#define TDM_RX_FSYNC_OUT_ENABLE_MASK		(1 << TDM_RX_FSYNC_OUT_ENABLE_OFFS)
+#define TDM_TX_CLK_OUT_ENABLE_OFFS		2
+#define TDM_TX_CLK_OUT_ENABLE_MASK		(1 << TDM_TX_CLK_OUT_ENABLE_OFFS)
+#define TDM_RX_CLK_OUT_ENABLE_OFFS		3
+#define TDM_RX_CLK_OUT_ENABLE_MASK		(1 << TDM_RX_CLK_OUT_ENABLE_OFFS)
+#define TDM_TX_REFCLK_DIVIDER_OFFS		4
+#define TDM_TX_REFCLK_DIVIDER_MASK		(0xff << TDM_TX_REFCLK_DIVIDER_OFFS)
+#define TDM_TX_REFCLK_DIVIDER_2MHZ		BIT7
+#define TDM_TX_REFCLK_DIVIDER_4MHZ		BIT8
+#define TDM_TX_REFCLK_DIVIDER_8MHZ		BIT9
+#define TDM_RX_REFCLK_DIVIDER_OFFS		12
+#define TDM_RX_REFCLK_DIVIDER_MASK		(0xff << TDM_RX_REFCLK_DIVIDER_OFFS)
+#define TDM_RX_REFCLK_DIVIDER_2MHZ		BIT15
+#define TDM_RX_REFCLK_DIVIDER_4MHZ		BIT16
+#define TDM_RX_REFCLK_DIVIDER_8MHZ		BIT17
+#define TDM_FSYNC_INVERT_OFFS			19
+#define TDM_FSYNC_INVERT_DISABLE		(0 << TDM_FSYNC_INVERT_OFFS)
+#define TDM_FSYNC_INVERT_ENABLE			(1 << TDM_FSYNC_INVERT_OFFS)
+#define TDM_REFCLK_DIVIDER_BYPASS_OFFS		20
+#define TDM_REFCLK_DIVIDER_BYPASS_MASK		(3 << TDM_REFCLK_DIVIDER_BYPASS_OFFS)
+#define TDM_OUT_CLK_SRC_CTRL_OFFS		24
+#define TDM_OUT_CLK_SRC_CTRL_BEFORE_DIV		(0 << TDM_OUT_CLK_SRC_CTRL_OFFS)
+#define TDM_OUT_CLK_SRC_CTRL_AFTER_DIV		(1 << TDM_OUT_CLK_SRC_CTRL_OFFS)
+#define TDM_PROG_TDM_SLIC_RESET_OFFS		31
+#define TDM_PROG_TDM_SLIC_RESET_MASK		(1 << TDM_PROG_TDM_SLIC_RESET_OFFS)
+
+/* TDM_RX_CLK_DIVIDER_CONTROL_REG bits */
+#define TDM_RX_FIXED_DIV_ENABLE_OFFS		31
+#define TDM_RX_FIXED_DIV_ENABLE_MASK		(1 << TDM_RX_FIXED_DIV_ENABLE_OFFS)
+
+/* TDM_TX_CLK_DIVIDER_CONTROL_REG bits */
+#define TDM_TX_FIXED_DIV_ENABLE_OFFS		31
+#define TDM_TX_FIXED_DIV_ENABLE_MASK		(1 << TDM_TX_FIXED_DIV_ENABLE_OFFS)
+
+/* FLEX_TDM_CONFIG_REG bits */
+#define TDM_RR2HALF_OFFS			15
+#define TDM_RR2HALF_MASK			(1 << TDM_RR2HALF_OFFS)
+#define TDM_TR2HALF_OFFS			16
+#define TDM_TR2HALF_MASK			(1 << TDM_TR2HALF_OFFS)
+#define TDM_SE_OFFS				20
+#define TDM_SE_MASK				(1 << TDM_SE_OFFS)
+#define TDM_COMMON_RX_TX_OFFS			23
+#define TDM_COMMON_RX_TX_MASK			(1 << TDM_COMMON_RX_TX_OFFS)
+#define TSD_OFFS				25
+#define TSD_MASK				(0x3 << TSD_OFFS)
+#define TSD_NO_DELAY				(0 << TSD_OFFS)
+#define TSD_1BIT_DELAY				(1 << TSD_OFFS)
+#define TSD_2BIT_DELAY				(2 << TSD_OFFS)
+#define TSD_3BIT_DELAY				(3 << TSD_OFFS)
+#define RSD_OFFS				27
+#define RSD_MASK				(0x3 << RSD_OFFS)
+#define RSD_NO_DELAY				(0 << RSD_OFFS)
+#define RSD_1BIT_DELAY				(1 << RSD_OFFS)
+#define RSD_2BIT_DELAY				(2 << RSD_OFFS)
+#define RSD_3BIT_DELAY				(3 << RSD_OFFS)
+#define TDM_TEN_OFFS				31
+#define TDM_TEN_MASK				(1 << TDM_TEN_OFFS)
+
+/* TDM_OUTPUT_SYNC_BIT_COUNT_REG bits */
+#define TDM_SYNC_BIT_TX_OFFS			0
+#define TDM_SYNC_BIT_TX_MASK			(0xffff << TDM_SYNC_BIT_TX_OFFS)
+#define TDM_SYNC_BIT_RX_OFFS			16
+#define TDM_SYNC_BIT_RX_MASK			(0xffff << TDM_SYNC_BIT_RX_OFFS)
+
+/* TDM_DATA_DELAY_AND_CLK_CTRL_REG bits */
+#define TX_CLK_OUT_ENABLE_OFFS			0
+#define TX_CLK_OUT_ENABLE_MASK			(1 << TX_CLK_OUT_ENABLE_OFFS)
+#define RX_CLK_OUT_ENABLE_OFFS			1
+#define RX_CLK_OUT_ENABLE_MASK			(1 << RX_CLK_OUT_ENABLE_OFFS)
+#define FIXED_POINT_RX_SYNC_OFFS		2
+#define FIXED_POINT_RX_SYNC_MASK		(1 << FIXED_POINT_RX_SYNC_OFFS)
+#define TX_DELAY_HOTBIT_OFFS			4
+#define TX_NO_DELAY				(0 << TX_DELAY_HOTBIT_OFFS)
+#define TX_1BIT_DELAY				(1 << TX_DELAY_HOTBIT_OFFS)
+#define TX_2BIT_DELAY				(2 << TX_DELAY_HOTBIT_OFFS)
+#define TX_3BIT_DELAY				(4 << TX_DELAY_HOTBIT_OFFS)
+#define TX_4BIT_DELAY				(8 << TX_DELAY_HOTBIT_OFFS)
+#define RX_DELAY_HOTBIT_OFFS			8
+#define RX_NO_DELAY				(0 << RX_DELAY_HOTBIT_OFFS)
+#define RX_1BIT_DELAY				(1 << RX_DELAY_HOTBIT_OFFS)
+#define RX_2BIT_DELAY				(2 << RX_DELAY_HOTBIT_OFFS)
+#define RX_3BIT_DELAY				(4 << RX_DELAY_HOTBIT_OFFS)
+#define RX_4BIT_DELAY				(8 << RX_DELAY_HOTBIT_OFFS)
+
+/* TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG bits */
+#define TX_SYNC_DELAY_OUT_OFFS			0
+#define TX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS	14
+#define TX_SYNC_DELAY_OUT_PLUS			(0 << TX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS)
+#define TX_SYNC_DELAY_OUT_MINUS			(1 << TX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS)
+#define TX_SYNC_DELAY_OUT_RESTART_CALC_OFFS	15
+#define TX_SYNC_DELAY_OUT_RESTART_CALC_MASK	(1 << TX_SYNC_DELAY_OUT_RESTART_CALC_OFFS)
+#define RX_SYNC_DELAY_OUT_OFFS			16
+#define RX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS	30
+#define RX_SYNC_DELAY_OUT_PLUS			(0 << RX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS)
+#define RX_SYNC_DELAY_OUT_MINUS			(1 << RX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS)
+#define RX_SYNC_DELAY_OUT_RESTART_CALC_OFFS	31
+#define RX_SYNC_DELAY_OUT_RESTART_CALC_MASK	(1 << RX_SYNC_DELAY_OUT_RESTART_CALC_OFFS)
+
+/* TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG bits */
+#define TX_SYNC_DELAY_IN_OFFS			0
+#define TX_SYNC_DELAY_IN_PLUS_MINUS_OFFS	14
+#define TX_SYNC_DELAY_IN_PLUS			(0 << TX_SYNC_DELAY_IN_PLUS_MINUS_OFFS)
+#define TX_SYNC_DELAY_IN_MINUS			(1 << TX_SYNC_DELAY_IN_PLUS_MINUS_OFFS)
+#define TX_SYNC_DELAY_IN_RESTART_CALC_OFFS	15
+#define TX_SYNC_DELAY_IN_RESTART_CALC_MASK	(1 << TX_SYNC_DELAY_IN_RESTART_CALC_OFFS)
+#define RX_SYNC_DELAY_IN_OFFS			16
+#define RX_SYNC_DELAY_IN_PLUS_MINUS_OFFS	30
+#define RX_SYNC_DELAY_IN_PLUS			(0 << RX_SYNC_DELAY_IN_PLUS_MINUS_OFFS)
+#define RX_SYNC_DELAY_IN_MINUS			(1 << RX_SYNC_DELAY_IN_PLUS_MINUS_OFFS)
+#define RX_SYNC_DELAY_IN_RESTART_CALC_OFFS	31
+#define RX_SYNC_DELAY_IN_RESTART_CALC_MASK	(1 << RX_SYNC_DELAY_IN_RESTART_CALC_OFFS)
+
+/************************************************/
+/*	Shared Bus to Crossbar Bridge		*/
+/************************************************/
+#define COMM_UNIT_MBUS_MAX_WIN			12
+
+#define COMM_UNIT_WIN_CTRL_REG(win)		((MV_COMM_UNIT_REGS_BASE + 0x8A00) + (win<<3))
+#define COMM_UNIT_WIN_SIZE_REG(win)		((MV_COMM_UNIT_REGS_BASE + 0x8A04) + (win<<3))
+#define COMM_UNIT_WIN_ENABLE_REG(win)		((MV_COMM_UNIT_REGS_BASE + 0x8B04) + (win<<2))
+#define COMM_UNIT_OVERRIDE_WIN_CONTROL_REG	(MV_COMM_UNIT_REGS_BASE + 0x8A7C)
+#define TIME_OUT_COUNTER_REG			(MV_COMM_UNIT_REGS_BASE + 0x8ADC)
+#define COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG	(MV_COMM_UNIT_REGS_BASE + 0x8B00)
+
+/* COMM_UNIT_WIN_CTRL_REG bits */
+#define COMM_UNIT_WIN_TARGET_OFFS		0
+#define COMM_UNIT_WIN_TARGET_MASK		(0xf << COMM_UNIT_WIN_TARGET_OFFS)
+#define COMM_UNIT_WIN_ATTRIB_OFFS		8
+#define COMM_UNIT_WIN_ATTRIB_MASK		(0xff << COMM_UNIT_WIN_ATTRIB_OFFS)
+#define COMM_UNIT_WIN_BASE_OFFS			16
+#define COMM_UNIT_WIN_BASE_MASK			(0xffff << COMM_UNIT_WIN_BASE_OFFS)
+
+/* COMM_UNIT_WIN_SIZE_REG bits */
+#define COMM_UNIT_WIN_SIZE_OFFS			16
+#define COMM_UNIT_WIN_SIZE_MASK			(0xffff << COMM_UNIT_WIN_SIZE_OFFS)
+
+/* COMM_UNIT_WIN_ENABLE_REG bits */
+#define COMM_UNIT_WIN_ENABLE_OFFS		0
+#define COMM_UNIT_WIN_ENABLE_MASK		(0xff << COMM_UNIT_WIN_CX_ENABLE_OFFS)
+#define COMM_UNIT_WIN_CX_ENABLE_OFFS		0
+#define COMM_UNIT_WIN_CX_ENABLE_MASK		(0x1 << COMM_UNIT_WIN_CX_ENABLE_OFFS)
+#define COMM_UNIT_WIN_MCDMA_ENABLE_OFFS		3
+#define COMM_UNIT_WIN_MCDMA_ENABLE_MASK		(0x1 << COMM_UNIT_WIN_MCDMA_ENABLE_OFFS)
+#define COMM_UNIT_WIN_MCSC_ENABLE_OFFS		4
+#define COMM_UNIT_WIN_MCSC_ENABLE_MASK		(0x1 << COMM_UNIT_WIN_MCSC_ENABLE_OFFS)
+#define COMM_UNIT_WIN_TDM_ENABLE_OFFS		5
+#define COMM_UNIT_WIN_TDM_ENABLE_MASK		(0x1 << COMM_UNIT_WIN_TDM_ENABLE_OFFS)
+#define COMM_UNIT_WIN_CX_REGFILE_ENABLE_OFFS	7
+#define COMM_UNIT_WIN_CX_REGFILE_ENABLE_MASK	(0x1 << COMM_UNIT_WIN_CX_REGFILE_ENABLE_OFFS)
+
+/* TIME_OUT_COUNTER_REG bits */
+#define	TIME_OUT_THRESHOLD_COUNT_OFFS		16
+#define	TIME_OUT_THRESHOLD_COUNT_MASK		(0xffff << TIME_OUT_THRESHOLD_COUNT_OFFS)
+
+/* COMM_UNIT_WINDOWS_ACCESS_PROTECT_REG bits */
+#define COMM_UNIT_WIN_PROTECT_OFFS(win)		(win << 1)
+#define COMM_UNIT_WIN_PROTECT_MASK(win)		(0x3 << COMM_UNIT_WIN_PROTECT_OFFS(win))
+
+#define MV_COMM_UNIT_WIN_SIZE_ALIGN	_64K
+
+#endif /*__INCmvCommUnitRegsh*/
+
diff --git a/drivers/telephony/mvebu_phone/voiceband/common/mvTdmComm.h b/drivers/telephony/mvebu_phone/voiceband/common/mvTdmComm.h
new file mode 100644
index 0000000..bb232aa
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/common/mvTdmComm.h
@@ -0,0 +1,99 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvTdmComm
+#define __INCmvTdmComm
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+	MV_U8 *tdmRxBuff;
+	MV_U8 *tdmTxBuff;
+	MV_U32 intType;
+	MV_U8 cs;
+	MV_U8 data;
+} MV_TDM_INT_INFO;
+
+typedef struct {
+	MV_PCM_FORMAT pcmFormat;
+	MV_U16 pcmSlot[32];
+	MV_U8 samplingPeriod;
+	MV_U16 totalChannels;
+} MV_TDM_PARAMS;
+
+typedef struct {
+	MV_U8 spiMode;
+	MV_U8 maxCs;
+	MV_U32 familyId;
+	MV_U16 model;
+	MV_U16 ctrlRev;
+	MV_FRAME_TS frameTs;
+} MV_TDM_HAL_DATA;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __INCmvTdmComm */
diff --git a/drivers/telephony/mvebu_phone/voiceband/mvSysTdmSpi.h b/drivers/telephony/mvebu_phone/voiceband/mvSysTdmSpi.h
new file mode 100644
index 0000000..4b0787c
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/mvSysTdmSpi.h
@@ -0,0 +1,93 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __MV_SYS_TDM_SPI_H__
+#define __MV_SYS_TDM_SPI_H__
+
+#include "mvOs.h"
+
+/* Enumerators */
+typedef enum {
+	MV_NARROW_BAND = 0,
+	MV_WIDE_BAND,
+} MV_BAND_MODE;
+
+typedef enum {
+	MV_PCM_FORMAT_1BYTE = 1,
+	MV_PCM_FORMAT_2BYTES = 2,
+	MV_PCM_FORMAT_4BYTES = 4
+} MV_PCM_FORMAT;
+
+typedef enum {
+	MV_FRAME_32TS = 32,
+	MV_FRAME_64TS = 64,
+	MV_FRAME_128TS = 128
+} MV_FRAME_TS;
+
+/* APIs */
+MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8 *cmdBuff, MV_U8 cmdSize, MV_U8 *dataBuff, MV_U8 dataSize, MV_U32 spiType);
+MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8 *cmdBuff, MV_U8 cmdSize, MV_U8 *dataBuff, MV_U8 dataSize, MV_U32 spiType);
+MV_VOID mvSysTdmIntEnable(MV_U8 deviceId);
+MV_VOID mvSysTdmIntDisable(MV_U8 deviceId);
+
+#endif /* __MV_SYS_TDM_SPI_H__ */
diff --git a/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdm.c b/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdm.c
new file mode 100644
index 0000000..3a86757
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdm.c
@@ -0,0 +1,1118 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "voiceband/tdm/mvTdm.h"
+
+/* defines */
+#define INT_SAMPLE			2
+#define BUFF_IS_FULL			1
+#define BUFF_IS_EMPTY			0
+#define FIRST_INT			1
+#define TOTAL_BUFFERS			2
+#define MV_TDM_NEXT_BUFFER(buf)		((buf + 1) % TOTAL_BUFFERS)
+#define MV_TDM_PREV_BUFFER(buf, step) 	((TOTAL_BUFFERS + buf - step) % TOTAL_BUFFERS)
+#define MV_TDM_CS			0
+#define BUFF_INVALID			-1
+
+/* static APIs */
+static MV_STATUS mvTdmChInit(MV_U8 ch);
+static MV_STATUS mvTdmChRemove(MV_U8 ch);
+static MV_VOID mvTdmReset(MV_VOID);
+static MV_VOID mvTdmDaisyChainModeSet(MV_VOID);
+static MV_VOID mvTdmShowProperties(MV_VOID);
+/* Tx */
+static INLINE MV_STATUS mvTdmChTxLow(MV_U8 ch);
+/* Rx */
+static INLINE MV_STATUS mvTdmChRxLow(MV_U8 ch);
+
+/* TDM channel info structure */
+typedef struct _mv_tdm_ch_info {
+	MV_U8 ch;
+	MV_U8 *rxBuffVirt[TOTAL_BUFFERS], *txBuffVirt[TOTAL_BUFFERS];
+	MV_ULONG rxBuffPhys[TOTAL_BUFFERS], txBuffPhys[TOTAL_BUFFERS];
+	MV_U8 rxBuffFull[TOTAL_BUFFERS], txBuffFull[TOTAL_BUFFERS];
+	MV_U8 rxCurrBuff, txCurrBuff;
+	MV_U8 rxFirst;
+} MV_TDM_CH_INFO;
+
+/* globals */
+static MV_U8 *rxAggrBuffVirt, *txAggrBuffVirt;
+static MV_ULONG rxAggrBuffPhys, txAggrBuffPhys;
+static MV_U8 rxInt, txInt;
+static MV_16 rxFull, txEmpty;
+static MV_U8 tdmEnable;
+static MV_U8 spiMode;
+static MV_U8 factor;
+static MV_PCM_FORMAT pcmFormat;
+static MV_BAND_MODE tdmBandMode;
+static MV_TDM_CH_INFO *tdmChInfo[MV_TDM2C_TOTAL_CHANNELS] = { NULL, NULL };
+static volatile MV_U8 chanStopCount;
+
+static MV_U8 intLock;
+static MV_U32 intRxCount;
+static MV_U32 intTxCount;
+static MV_U32 intRx0Count;
+static MV_U32 intTx0Count;
+static MV_U32 intRx1Count;
+static MV_U32 intTx1Count;
+static MV_U32 intRx0Miss;
+static MV_U32 intTx0Miss;
+static MV_U32 intRx1Miss;
+static MV_U32 intTx1Miss;
+static MV_U32 pcmRestartCount;
+
+MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
+{
+	MV_U8 ch;
+	MV_U32 pcmCtrlReg, nbDelay = 0, wbDelay = 0;
+	MV_U32 chDelay[4] = { 0, 0, 0, 0 };
+
+	MV_TRC_REC("->%s\n", __func__);
+	mvTdmShowProperties();
+
+	/* Init globals */
+	rxInt = txInt = 0;
+	rxFull = txEmpty = BUFF_INVALID;
+	tdmEnable = 0, intLock = 0;
+	spiMode = halData->spiMode;
+	pcmFormat = tdmParams->pcmFormat;
+	intRxCount = 0, intTxCount = 0;
+	intRx0Count = 0, intTx0Count = 0;
+	intRx1Count = 0, intTx1Count = 0;
+	intRx0Miss = 0, intTx0Miss = 0;
+	intRx1Miss = 0, intTx1Miss = 0;
+	pcmRestartCount = 0;
+
+	if (tdmParams->samplingPeriod > MV_TDM_MAX_SAMPLING_PERIOD)
+		factor = 1;	/* use base sample period(10ms) */
+	else
+		factor = (tdmParams->samplingPeriod / MV_TDM_BASE_SAMPLING_PERIOD);
+
+	/* Extract pcm format & band mode */
+	if (pcmFormat == MV_PCM_FORMAT_4BYTES) {
+		pcmFormat = MV_PCM_FORMAT_2BYTES;
+		tdmBandMode = MV_WIDE_BAND;
+	} else {
+		tdmBandMode = MV_NARROW_BAND;
+	}
+
+	/* Allocate aggregated buffers for data transport */
+	MV_TRC_REC("allocate %d bytes for aggregated buffer\n", MV_TDM_AGGR_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+	rxAggrBuffVirt = (MV_U8 *) mvOsIoCachedMalloc(NULL, MV_TDM_AGGR_BUFF_SIZE(pcmFormat, tdmBandMode, factor),
+						      &rxAggrBuffPhys, NULL);
+	txAggrBuffVirt = (MV_U8 *) mvOsIoCachedMalloc(NULL, MV_TDM_AGGR_BUFF_SIZE(pcmFormat, tdmBandMode, factor),
+						      &txAggrBuffPhys, NULL);
+	if (!rxAggrBuffVirt || !txAggrBuffVirt) {
+		mvOsPrintf("%s: Error malloc failed\n", __func__);
+		return MV_NO_RESOURCE;
+	}
+
+	/* Clear buffers */
+	memset(rxAggrBuffVirt, 0, MV_TDM_AGGR_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+	memset(txAggrBuffVirt, 0, MV_TDM_AGGR_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+
+	/* Calculate CH(0/1) Delay Control for narrow/wideband modes */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		nbDelay = ((tdmParams->pcmSlot[ch] * PCM_SLOT_PCLK) + 1);
+		wbDelay = (nbDelay + ((halData->frameTs / 2) * PCM_SLOT_PCLK)); /* Offset required by ZARLINK VE880 SLIC */
+		chDelay[ch] = ((nbDelay << CH_RX_DELAY_OFFS) | (nbDelay << CH_TX_DELAY_OFFS));
+		chDelay[(ch + 2)] = ((wbDelay << CH_RX_DELAY_OFFS) | (wbDelay << CH_TX_DELAY_OFFS));
+	}
+
+	/* Config TDM */
+	MV_REG_BIT_RESET(TDM_SPI_MUX_REG, BIT0);	/* enable TDM/SPI interface */
+	MV_REG_BIT_SET(TDM_MISC_REG, BIT0);		/* sw reset to TDM for 5181L-A1 & up */
+	MV_REG_WRITE(INT_RESET_SELECT_REG, CLEAR_ON_ZERO);	/* int cause is not clear on read */
+	MV_REG_WRITE(INT_EVENT_MASK_REG, 0x3ffff);	/* all interrupt bits latched in status */
+	MV_REG_WRITE(INT_STATUS_MASK_REG, 0);	/* disable interrupts */
+	MV_REG_WRITE(INT_STATUS_REG, 0);	/* clear int status register */
+
+	/* Bypass clock divider */
+	MV_REG_WRITE(PCM_CLK_RATE_DIV_REG, PCM_DIV_PASS);	/* PCM PCLK freq */
+
+	MV_REG_WRITE(DUMMY_RX_WRITE_DATA_REG, 0);	/* Padding on Rx completion */
+	MV_REG_BYTE_WRITE(SPI_GLOBAL_CTRL_REG, MV_REG_READ(SPI_GLOBAL_CTRL_REG) | SPI_GLOBAL_ENABLE);
+	MV_REG_BYTE_WRITE(SPI_CLK_PRESCALAR_REG, SPI_CLK_2MHZ);	/* SPI SCLK freq */
+	MV_REG_WRITE(FRAME_TIMESLOT_REG, (MV_U32)halData->frameTs); /* Number of timeslots (PCLK) */
+
+	if (tdmBandMode == MV_NARROW_BAND) {
+		pcmCtrlReg = (CONFIG_PCM_CRTL | (((MV_U8)pcmFormat - 1) << PCM_SAMPLE_SIZE_OFFS));
+#ifdef CONFIG_OF
+		if (use_pclk_external)
+			pcmCtrlReg |= MASTER_PCLK_EXTERNAL;
+#endif
+		MV_REG_WRITE(PCM_CTRL_REG, pcmCtrlReg);	/* PCM configuration */
+		MV_REG_WRITE(CH_DELAY_CTRL_REG(0), chDelay[0]);	/* CH0 delay control register */
+		MV_REG_WRITE(CH_DELAY_CTRL_REG(1), chDelay[1]);	/* CH1 delay control register */
+	} else {		/* MV_WIDE_BAND */
+
+		pcmCtrlReg = (CONFIG_WB_PCM_CRTL | (((MV_U8)pcmFormat - 1) << PCM_SAMPLE_SIZE_OFFS));
+#ifdef CONFIG_OF
+		if (use_pclk_external)
+			pcmCtrlReg |= MASTER_PCLK_EXTERNAL;
+#endif
+		MV_REG_WRITE(PCM_CTRL_REG, pcmCtrlReg);	/* PCM configuration - WB support */
+		MV_REG_WRITE(CH_DELAY_CTRL_REG(0), chDelay[0]);	/* CH0 delay control register */
+		MV_REG_WRITE(CH_DELAY_CTRL_REG(1), chDelay[1]);	/* CH1 delay control register */
+		MV_REG_WRITE(CH_WB_DELAY_CTRL_REG(0), chDelay[2]);	/* CH0 WB delay control register */
+		MV_REG_WRITE(CH_WB_DELAY_CTRL_REG(1), chDelay[3]);	/* CH1 WB delay control register */
+	}
+
+	/* Issue reset to codec(s) */
+	MV_TRC_REC("reseting voice unit(s)\n");
+	MV_REG_WRITE(MISC_CTRL_REG, 0);
+	mvOsDelay(1);
+	MV_REG_WRITE(MISC_CTRL_REG, 1);
+
+	if (spiMode) {
+		/* Configure TDM to work in daisy chain mode */
+		mvTdmDaisyChainModeSet();
+	}
+
+	/* Initialize all HW units */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		if (mvTdmChInit(ch) != MV_OK) {
+			mvOsPrintf("mvTdmChInit(%d) failed !\n", ch);
+			return MV_ERROR;
+		}
+	}
+
+	/* Enable SLIC/DAA interrupt detection(before pcm is active) */
+	MV_REG_WRITE(INT_STATUS_MASK_REG, (MV_REG_READ(INT_STATUS_MASK_REG) | TDM_INT_SLIC));
+
+	MV_TRC_REC("<-%s\n", __func__);
+	return MV_OK;
+}
+
+static MV_STATUS mvTdmChInit(MV_U8 ch)
+{
+	MV_TDM_CH_INFO *chInfo;
+	MV_U32 buff;
+
+	MV_TRC_REC("->%s ch%d\n", __func__, ch);
+	printk ("Rabeeh - mvTdmChInit %d\n",ch);
+	if (ch >= MV_TDM2C_TOTAL_CHANNELS) {
+		mvOsPrintf("%s: error, channel(%d) exceeds maximum(%d)\n", __func__, ch, MV_TDM2C_TOTAL_CHANNELS);
+		return MV_BAD_PARAM;
+	}
+
+	tdmChInfo[ch] = chInfo = (MV_TDM_CH_INFO *) mvOsMalloc(sizeof(MV_TDM_CH_INFO));
+	if (!chInfo) {
+		mvOsPrintf("%s: error malloc failed\n", __func__);
+		return MV_NO_RESOURCE;
+	}
+
+	chInfo->ch = ch;
+
+	/* Per channel TDM init */
+	MV_REG_WRITE(CH_ENABLE_REG(ch), CH_DISABLE);	/* disable channel (enable in pcm start) */
+	MV_REG_WRITE(CH_SAMPLE_REG(ch), CONFIG_CH_SAMPLE(tdmBandMode, factor));	/* set total samples and int sample */
+
+	for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+		/* Buffers must be 32B aligned */
+		chInfo->rxBuffVirt[buff] =
+		    (MV_U8 *) mvOsIoUncachedMalloc(NULL, MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor),
+						   &(chInfo->rxBuffPhys[buff]), NULL);
+		chInfo->rxBuffFull[buff] = BUFF_IS_EMPTY;
+
+		chInfo->txBuffVirt[buff] =
+		    (MV_U8 *) mvOsIoUncachedMalloc(NULL, MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor),
+						   &(chInfo->txBuffPhys[buff]), NULL);
+		chInfo->txBuffFull[buff] = BUFF_IS_FULL;
+
+		memset(chInfo->txBuffVirt[buff], 0, MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+
+		if (((MV_ULONG) chInfo->rxBuffVirt[buff] | chInfo->rxBuffPhys[buff] |
+		     (MV_ULONG) chInfo->txBuffVirt[buff] | chInfo->txBuffPhys[buff]) & 0x1f) {
+			mvOsPrintf("%s: error, unaligned buffer allocation\n", __func__);
+		}
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+	return MV_OK;
+}
+
+MV_VOID mvTdmRelease(MV_VOID)
+{
+	MV_U8 ch;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Free Rx/Tx aggregated buffers */
+	mvOsIoCachedFree(NULL, MV_TDM_AGGR_BUFF_SIZE(pcmFormat, tdmBandMode, factor), rxAggrBuffPhys,
+			 rxAggrBuffVirt, 0);
+	mvOsIoCachedFree(NULL, MV_TDM_AGGR_BUFF_SIZE(pcmFormat, tdmBandMode, factor), txAggrBuffPhys,
+			 txAggrBuffVirt, 0);
+
+	/* Release HW channel resources */
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++)
+		mvTdmChRemove(ch);
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+static MV_STATUS mvTdmChRemove(MV_U8 ch)
+{
+	MV_TDM_CH_INFO *chInfo;
+	MV_U8 buff;
+
+	MV_TRC_REC("->%s ch%d\n", __func__, ch);
+
+	if (ch >= MV_TDM2C_TOTAL_CHANNELS) {
+		mvOsPrintf("%s: error, channel(%d) exceeds maximum(%d)\n", __func__, ch, MV_TDM2C_TOTAL_CHANNELS);
+		return MV_BAD_PARAM;
+	}
+
+	chInfo = tdmChInfo[ch];
+
+	for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+		mvOsIoUncachedFree(NULL, MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor), chInfo->rxBuffPhys[buff],
+				   chInfo->rxBuffVirt[buff], 0);
+		mvOsIoUncachedFree(NULL, MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor), chInfo->txBuffPhys[buff],
+				   chInfo->txBuffVirt[buff], 0);
+	}
+
+	mvOsFree(chInfo);
+
+	MV_TRC_REC("<-%s ch%d\n", __func__, ch);
+	return MV_OK;
+}
+
+static MV_VOID mvTdmReset(MV_VOID)
+{
+	MV_TDM_CH_INFO *chInfo;
+	MV_U8 buff, ch;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Reset globals */
+	rxInt = txInt = 0;
+	rxFull = txEmpty = BUFF_INVALID;
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		printk ("TDM channel %d, tdmChInfo is at %p\n",ch,tdmChInfo);
+		chInfo = tdmChInfo[ch];
+		printk ("chInfo is at %p\n",chInfo);
+		chInfo->rxFirst = FIRST_INT;
+		chInfo->txCurrBuff = chInfo->rxCurrBuff = 0;
+		for (buff = 0; buff < TOTAL_BUFFERS; buff++) {
+			chInfo->rxBuffFull[buff] = BUFF_IS_EMPTY;
+			chInfo->txBuffFull[buff] = BUFF_IS_FULL;
+
+		}
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+	return;
+}
+
+MV_VOID mvTdmPcmStart(MV_VOID)
+{
+	MV_TDM_CH_INFO *chInfo;
+	MV_U8 ch;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	tdmEnable = 1;		/* TDM is enabled  */
+	intLock = 0;
+	chanStopCount = 0;
+	mvTdmReset();
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		chInfo = tdmChInfo[ch];
+
+		/* Set Tx buff */
+		MV_REG_WRITE(CH_TX_ADDR_REG(ch), chInfo->txBuffPhys[chInfo->txCurrBuff]);
+		MV_REG_BYTE_WRITE(CH_BUFF_OWN_REG(ch) + TX_OWN_BYTE_OFFS, OWN_BY_HW);
+
+		/* Set Rx buff */
+		MV_REG_WRITE(CH_RX_ADDR_REG(ch), chInfo->rxBuffPhys[chInfo->rxCurrBuff]);
+		MV_REG_BYTE_WRITE(CH_BUFF_OWN_REG(ch) + RX_OWN_BYTE_OFFS, OWN_BY_HW);
+
+	}
+
+	/* Enable Tx */
+	MV_REG_BYTE_WRITE(CH_ENABLE_REG(0) + TX_ENABLE_BYTE_OFFS, CH_ENABLE);
+	MV_REG_BYTE_WRITE(CH_ENABLE_REG(1) + TX_ENABLE_BYTE_OFFS, CH_ENABLE);
+
+	/* Enable Rx */
+	MV_REG_BYTE_WRITE(CH_ENABLE_REG(0) + RX_ENABLE_BYTE_OFFS, CH_ENABLE);
+	MV_REG_BYTE_WRITE(CH_ENABLE_REG(1) + RX_ENABLE_BYTE_OFFS, CH_ENABLE);
+
+	/* Enable Tx interrupts */
+	MV_REG_WRITE(INT_STATUS_REG, MV_REG_READ(INT_STATUS_REG) & (~(TDM_INT_TX(0) | TDM_INT_TX(1))));
+	MV_REG_WRITE(INT_STATUS_MASK_REG, (MV_REG_READ(INT_STATUS_MASK_REG) | TDM_INT_TX(0) | TDM_INT_TX(1)));
+
+	/* Enable Rx interrupts */
+	MV_REG_WRITE(INT_STATUS_REG, (MV_REG_READ(INT_STATUS_REG) & (~(TDM_INT_RX(0) | TDM_INT_RX(1)))));
+	MV_REG_WRITE(INT_STATUS_MASK_REG, (MV_REG_READ(INT_STATUS_MASK_REG) | TDM_INT_RX(0) | TDM_INT_RX(1)));
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+MV_VOID mvTdmPcmStop(MV_VOID)
+{
+	MV_TRC_REC("->%s\n", __func__);
+
+	tdmEnable = 0;
+	mvTdmReset();
+
+	/* Mask all interrpts except SLIC/DAA */
+	/*MV_REG_WRITE(INT_STATUS_MASK_REG, (MV_U32)TDM_INT_SLIC);*/
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+MV_STATUS mvTdmTx(MV_U8 *tdmTxBuff)
+{
+	MV_TDM_CH_INFO *chInfo;
+	MV_U8 ch;
+	MV_U8 *pTdmTxBuff;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Sanity check */
+	if (tdmTxBuff != txAggrBuffVirt) {
+		mvOsPrintf("%s: Error, invalid Tx buffer !!!\n", __func__);
+		return MV_ERROR;
+	}
+
+	if (!tdmEnable) {
+		mvOsPrintf("%s: Error, no active Tx channels are available\n", __func__);
+		return MV_ERROR;
+	}
+
+	if (txEmpty == BUFF_INVALID) {
+		MV_TRC_REC("%s: Tx not ready\n", __func__);
+		return MV_NOT_READY;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		chInfo = tdmChInfo[ch];
+		MV_TRC_REC("ch%d: fill buf %d with %d bytes\n", ch, txEmpty,
+			   MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+		chInfo->txBuffFull[txEmpty] = BUFF_IS_FULL;
+		pTdmTxBuff = tdmTxBuff + (ch * MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+		/* Copy data from voice engine buffer to DMA */
+		mvOsMemcpy(chInfo->txBuffVirt[txEmpty], pTdmTxBuff,
+			   MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+	}
+
+	txEmpty = BUFF_INVALID;
+
+	MV_TRC_REC("<-%s\n", __func__);
+	return MV_OK;
+}
+
+MV_STATUS mvTdmRx(MV_U8 *tdmRxBuff)
+{
+	MV_TDM_CH_INFO *chInfo;
+	MV_U8 ch;
+	MV_U8 *pTdmRxBuff;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Sanity check */
+	if (tdmRxBuff != rxAggrBuffVirt) {
+		mvOsPrintf("%s: invalid Rx buffer !!!\n", __func__);
+		return MV_ERROR;
+	}
+
+	if (!tdmEnable) {
+		mvOsPrintf("%s: Error, no active Rx channels are available\n", __func__);
+		return MV_ERROR;
+	}
+
+	if (rxFull == BUFF_INVALID) {
+		MV_TRC_REC("%s: Rx not ready\n", __func__);
+		return MV_NOT_READY;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+		chInfo = tdmChInfo[ch];
+		chInfo->rxBuffFull[rxFull] = BUFF_IS_EMPTY;
+		MV_TRC_REC("%s get Rx buffer(%d) for channel(%d)\n", __func__, rxFull, ch);
+		pTdmRxBuff = tdmRxBuff + (ch * MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+		/* Copy data from DMA to voice engine buffer */
+		mvOsMemcpy(pTdmRxBuff, chInfo->rxBuffVirt[rxFull], MV_TDM_CH_BUFF_SIZE(pcmFormat, tdmBandMode, factor));
+	}
+
+	rxFull = BUFF_INVALID;
+	MV_TRC_REC("<-%s\n", __func__);
+	return MV_OK;
+}
+
+MV_32 mvPcmStopIntMiss(void)
+{
+	MV_U32 statusReg, maskReg, statusStopInt, statusMask = 0, intMask = 0, ret = 0;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	statusReg = MV_REG_READ(INT_STATUS_REG);
+	maskReg = MV_REG_READ(INT_STATUS_MASK_REG);
+
+	/* Refer only to unmasked bits */
+	statusStopInt = statusReg & maskReg;
+
+	if (statusStopInt & TX_UNDERFLOW_BIT(1)) {
+		statusMask |= TX_UNDERFLOW_BIT(1);
+		intMask |= TDM_INT_TX(1);
+	}
+
+	if (statusStopInt & TX_UNDERFLOW_BIT(0)) {
+		statusMask |= TX_UNDERFLOW_BIT(0);
+		intMask |= TDM_INT_TX(0);
+	}
+
+	if (statusStopInt & RX_OVERFLOW_BIT(1)) {
+		statusMask |= RX_OVERFLOW_BIT(1);
+		intMask |= TDM_INT_RX(1);
+	}
+
+	if (statusStopInt & RX_OVERFLOW_BIT(0)) {
+		statusMask |= TX_UNDERFLOW_BIT(0);
+		intMask |= TDM_INT_RX(0);
+	}
+
+	if (intMask != 0) {
+		MV_TRC_REC("Stop Interrupt missing found STATUS=%x, MASK=%x\n", statusReg, maskReg);
+		MV_REG_WRITE(INT_STATUS_REG, ~(statusMask));
+		MV_REG_WRITE(INT_STATUS_MASK_REG,
+					     MV_REG_READ(INT_STATUS_MASK_REG) & (~(intMask)));
+		ret = 1;
+	}
+	MV_TRC_REC("<-%s\n", __func__);
+	return ret;
+}
+
+/* Low level TDM interrupt service routine */
+MV_32 mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
+{
+	MV_U32 statusReg, maskReg, statusAndMask;
+	MV_32 ret = 0;
+	MV_32 intTxMiss = -1;
+	MV_32 intRxMiss = -1;
+	MV_U8 ch;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Read Status & mask registers */
+	statusReg = MV_REG_READ(INT_STATUS_REG);
+	maskReg = MV_REG_READ(INT_STATUS_MASK_REG);
+	MV_TRC_REC("CAUSE(0x%x), MASK(0x%x)\n", statusReg, maskReg);
+
+	/* Refer only to unmasked bits */
+	statusAndMask = statusReg & maskReg;
+
+	/* Reset params */
+	tdmIntInfo->tdmRxBuff = NULL;
+	tdmIntInfo->tdmTxBuff = NULL;
+	tdmIntInfo->intType = MV_EMPTY_INT;
+	tdmIntInfo->cs = MV_TDM_CS;
+
+	/* Handle SLIC/DAA int */
+	if (statusAndMask & SLIC_INT_BIT) {
+		MV_TRC_REC("Phone interrupt !!!\n");
+		tdmIntInfo->intType |= MV_PHONE_INT;
+	}
+#if 0
+	/* Return in case TDM is disabled */
+	if (!tdmEnable) {
+		MV_TRC_REC("TDM is disabled - quit low level ISR\n");
+		MV_REG_WRITE(INT_STATUS_REG, ~statusReg);
+		return;
+	}
+#endif
+	if (statusAndMask & DMA_ABORT_BIT) {
+		mvOsPrintf("DMA data abort. Address: 0x%08x, Info: 0x%08x\n",
+			   MV_REG_READ(DMA_ABORT_ADDR_REG), MV_REG_READ(DMA_ABORT_INFO_REG));
+		tdmIntInfo->intType |= MV_DMA_ERROR_INT;
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		/* Give next buff to TDM and set curr buff as empty */
+		if ((statusAndMask & TX_BIT(ch)) && tdmEnable && !intLock) {
+			MV_TRC_REC("Tx interrupt(ch%d) !!!\n", ch);
+
+			intTxCount++;
+			if (ch == 0) {
+				intTx0Count++;
+				if (intTx0Count <= intTx1Count) {
+					intTxMiss = 0;
+					intTx0Miss++;
+				}
+			} else {
+				intTx1Count++;
+				if (intTx1Count < intTx0Count) {
+					intTxMiss = 1;
+					intTx1Miss++;
+				}
+			}
+
+			/* MV_OK -> Tx is done for both channels */
+			if (mvTdmChTxLow(ch) == MV_OK) {
+				MV_TRC_REC("Assign Tx aggregate buffer for further processing\n");
+				tdmIntInfo->tdmTxBuff = txAggrBuffVirt;
+				tdmIntInfo->intType |= MV_TX_INT;
+			}
+		}
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		if ((statusAndMask & RX_BIT(ch)) && tdmEnable && !intLock) {
+			MV_TRC_REC("Rx interrupt(ch%d) !!!\n", ch);
+
+			intRxCount++;
+			if (ch == 0) {
+				intRx0Count++;
+				if (intRx0Count <= intRx1Count) {
+					intRxMiss = 0;
+					intRx0Miss++;
+				}
+			} else {
+				intRx1Count++;
+				if (intRx1Count < intRx0Count) {
+					intRxMiss = 1;
+					intRx1Miss++;
+				}
+			}
+
+			/* MV_OK -> Rx is done for both channels */
+			if (mvTdmChRxLow(ch) == MV_OK) {
+				MV_TRC_REC("Assign Rx aggregate buffer for further processing\n");
+				tdmIntInfo->tdmRxBuff = rxAggrBuffVirt;
+				tdmIntInfo->intType |= MV_RX_INT;
+			}
+		}
+	}
+
+	for (ch = 0; ch < MV_TDM2C_TOTAL_CHANNELS; ch++) {
+
+		if (statusAndMask & TX_UNDERFLOW_BIT(ch)) {
+
+			MV_TRC_REC("Tx underflow(ch%d) - checking for root cause...\n", ch);
+			if (tdmEnable) {
+				MV_TRC_REC("Tx underflow ERROR\n");
+				tdmIntInfo->intType |= MV_TX_ERROR_INT;
+				if (!(statusAndMask & TX_BIT(ch))) {
+					ret = -1;
+					/* MV_OK -> Tx is done for both channels */
+					if (mvTdmChTxLow(ch) == MV_OK) {
+						MV_TRC_REC("Assign Tx aggregate buffer for further processing\n");
+						tdmIntInfo->tdmTxBuff = txAggrBuffVirt;
+						tdmIntInfo->intType |= MV_TX_INT;
+					}
+				}
+			} else {
+				MV_TRC_REC("Expected Tx underflow(not an error)\n");
+				tdmIntInfo->intType |= MV_CHAN_STOP_INT;
+				tdmIntInfo->data = ++chanStopCount; /* Update number of channels already stopped */
+				MV_REG_WRITE(INT_STATUS_MASK_REG,
+					MV_REG_READ(INT_STATUS_MASK_REG) & (~(TDM_INT_TX(ch))));
+			}
+		}
+
+
+		if (statusAndMask & RX_OVERFLOW_BIT(ch)) {
+			MV_TRC_REC("Rx overflow(ch%d) - checking for root cause...\n", ch);
+			if (tdmEnable) {
+				MV_TRC_REC("Rx overflow ERROR\n");
+				tdmIntInfo->intType |= MV_RX_ERROR_INT;
+				if (!(statusAndMask & RX_BIT(ch))) {
+					ret = -1;
+					/* MV_OK -> Rx is done for both channels */
+					if (mvTdmChRxLow(ch) == MV_OK) {
+						MV_TRC_REC("Assign Rx aggregate buffer for further processing\n");
+						tdmIntInfo->tdmRxBuff = rxAggrBuffVirt;
+						tdmIntInfo->intType |= MV_RX_INT;
+					}
+				}
+			} else {
+				MV_TRC_REC("Expected Rx overflow(not an error)\n");
+				tdmIntInfo->intType |= MV_CHAN_STOP_INT;
+				tdmIntInfo->data = ++chanStopCount; /* Update number of channels already stopped */
+				MV_REG_WRITE(INT_STATUS_MASK_REG,
+					     MV_REG_READ(INT_STATUS_MASK_REG) & (~(TDM_INT_RX(ch))));
+			}
+		}
+	}
+
+	/* clear TDM interrupts */
+	MV_REG_WRITE(INT_STATUS_REG, ~statusReg);
+
+	/* Check if interrupt was missed -> restart */
+	if  (intTxMiss != -1)  {
+		MV_TRC_REC("Missing Tx Interrupt Detected ch%d!!!\n", intTxMiss);
+		if (intTxMiss)
+			intTx1Count = intTx0Count;
+		else
+			intTx0Count  = (intTx1Count + 1);
+		ret = -1;
+	}
+
+	if  (intRxMiss != -1)  {
+		MV_TRC_REC("Missing Rx Interrupt Detected ch%d!!!\n", intRxMiss);
+		if (intRxMiss)
+			intRx1Count = intRx0Count;
+		else
+			intRx0Count  = (intRx1Count + 1);
+		ret = -1;
+	}
+
+	if (ret == -1) {
+		intLock = 1;
+		pcmRestartCount++;
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+	return ret;
+}
+
+static INLINE MV_STATUS mvTdmChTxLow(MV_U8 ch)
+{
+	MV_U32 max_poll = 0;
+	MV_TDM_CH_INFO *chInfo = tdmChInfo[ch];
+
+	MV_TRC_REC("->%s ch%d\n", __func__, ch);
+
+	/* count tx interrupts */
+	txInt++;
+	MV_TRC_REC("txInt(%d)\n", txInt);
+
+	if (chInfo->txBuffFull[chInfo->txCurrBuff] == BUFF_IS_FULL)
+		MV_TRC_REC("curr buff full for hw [MMP ok]\n");
+	else
+		MV_TRC_REC("curr buf is empty [MMP miss write]\n");
+
+	/* Change buffers */
+	chInfo->txCurrBuff = MV_TDM_NEXT_BUFFER(chInfo->txCurrBuff);
+
+	/* Mark next buff to be transmitted by HW as empty. Give it to the HW
+	   for next frame. The app need to write the data before HW takes it.  */
+	chInfo->txBuffFull[chInfo->txCurrBuff] = BUFF_IS_EMPTY;
+	MV_TRC_REC("->%s clear buf(%d) for channel(%d)\n", __func__, chInfo->txCurrBuff, ch);
+
+	/* Poll on SW ownership (single check) */
+	MV_TRC_REC("start poll for SW ownership\n");
+	while (((MV_REG_BYTE_READ(CH_BUFF_OWN_REG(chInfo->ch) + TX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW)
+	       && (max_poll < 2000)) {
+		mvOsUDelay(1);
+		max_poll++;
+	}
+	if (max_poll == 2000) {
+		MV_TRC_REC("poll timeout (~2ms)\n");
+		return MV_TIMEOUT;
+	} else {
+		MV_TRC_REC("tx-low poll stop ok\n");
+	}
+	MV_TRC_REC("ch%d, start tx buff %d\n", ch, chInfo->txCurrBuff);
+
+	/*Set TX buff address (must be 32 byte aligned) */
+	MV_REG_WRITE(CH_TX_ADDR_REG(chInfo->ch), chInfo->txBuffPhys[chInfo->txCurrBuff]);
+
+	/* Set HW ownership */
+	MV_REG_BYTE_WRITE(CH_BUFF_OWN_REG(chInfo->ch) + TX_OWN_BYTE_OFFS, OWN_BY_HW);
+
+	/* Enable Tx */
+	MV_REG_BYTE_WRITE(CH_ENABLE_REG(chInfo->ch) + TX_ENABLE_BYTE_OFFS, CH_ENABLE);
+
+	MV_TRC_REC("<-%s\n", __func__);
+
+	/* Did we get the required amount of irqs for Tx wakeup ? */
+	if (txInt < MV_TDM_INT_COUNTER) {
+		return MV_NOT_READY;
+	} else {
+		txInt = 0;
+		txEmpty = chInfo->txCurrBuff;
+		return MV_OK;
+	}
+}
+
+static INLINE MV_STATUS mvTdmChRxLow(MV_U8 ch)
+{
+	MV_U32 max_poll = 0;
+	MV_TDM_CH_INFO *chInfo = tdmChInfo[ch];
+
+	MV_TRC_REC("->%s ch%d\n", __func__, ch);
+
+	if (chInfo->rxFirst)
+		chInfo->rxFirst = !FIRST_INT;
+	else
+		rxInt++;
+
+	MV_TRC_REC("rxInt(%d)\n", rxInt);
+
+	if (chInfo->rxBuffFull[chInfo->rxCurrBuff] == BUFF_IS_EMPTY)
+		MV_TRC_REC("curr buff empty for hw [MMP ok]\n");
+	else
+		MV_TRC_REC("curr buf is full [MMP miss read]\n");
+
+	/* Mark last buff that was received by HW as full. Give next buff to HW for */
+	/* next frame. The app need to read the data before next irq */
+	chInfo->rxBuffFull[chInfo->rxCurrBuff] = BUFF_IS_FULL;
+
+	/* Change buffers */
+	chInfo->rxCurrBuff = MV_TDM_NEXT_BUFFER(chInfo->rxCurrBuff);
+
+	/* Poll on SW ownership (single check) */
+	MV_TRC_REC("start poll for ownership\n");
+	while (((MV_REG_BYTE_READ(CH_BUFF_OWN_REG(chInfo->ch) + RX_OWN_BYTE_OFFS) & OWNER_MASK) == OWN_BY_HW)
+	       && (max_poll < 2000)) {
+		mvOsUDelay(1);
+		max_poll++;
+	}
+	if (max_poll == 2000) {
+		MV_TRC_REC("poll timeout (~2ms)\n");
+		return MV_TIMEOUT;
+	} else {
+		MV_TRC_REC("poll stop ok\n");
+	}
+	MV_TRC_REC("%s ch%d, start rx buff %d\n", __func__, ch, chInfo->rxCurrBuff);
+
+	/* Set RX buff address (must be 32 byte aligned) */
+	MV_REG_WRITE(CH_RX_ADDR_REG(chInfo->ch), chInfo->rxBuffPhys[chInfo->rxCurrBuff]);
+
+	/* Set HW ownership */
+	MV_REG_BYTE_WRITE(CH_BUFF_OWN_REG(chInfo->ch) + RX_OWN_BYTE_OFFS, OWN_BY_HW);
+
+	/* Enable Rx */
+	MV_REG_BYTE_WRITE(CH_ENABLE_REG(chInfo->ch) + RX_ENABLE_BYTE_OFFS, CH_ENABLE);
+
+	MV_TRC_REC("<-%s\n", __func__);
+
+	/* Did we get the required amount of irqs for Rx wakeup ? */
+	if (rxInt < MV_TDM_INT_COUNTER) {
+		return MV_NOT_READY;
+	} else {
+		rxInt = 0;
+		rxFull = MV_TDM_PREV_BUFFER(chInfo->rxCurrBuff, 2);
+		MV_TRC_REC("buff %d is FULL for ch0\n", rxFull);
+		MV_TRC_REC("buff %d is FULL for ch1\n", rxFull);
+		return MV_OK;
+	}
+}
+
+/****************************
+**        SPI Stuff        **
+****************************/
+
+static MV_VOID mvTdmSetCurrentUnit(MV_32 cs)
+{
+	if (!spiMode) {
+		if (!cs)
+			MV_REG_WRITE(PCM_CTRL_REG, (MV_REG_READ(PCM_CTRL_REG) & ~CS_CTRL));
+		else
+			MV_REG_WRITE(PCM_CTRL_REG, (MV_REG_READ(PCM_CTRL_REG) | CS_CTRL));
+	} else
+		MV_REG_WRITE(PCM_CTRL_REG, (MV_REG_READ(PCM_CTRL_REG) & ~CS_CTRL));
+}
+
+static MV_VOID mvTdmDaisyChainModeSet(MV_VOID)
+{
+	mvOsPrintf("Setting Daisy Chain Mode\n");
+	while ((MV_REG_READ(SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+		continue;
+	MV_REG_WRITE(SPI_CODEC_CMD_LO_REG, (0x80 << 8) | 0);
+	MV_REG_WRITE(SPI_CODEC_CTRL_REG, TRANSFER_BYTES(2) | ENDIANESS_MSB_MODE | WR_MODE | CLK_SPEED_LO_DIV);
+	MV_REG_WRITE(SPI_CTRL_REG, MV_REG_READ(SPI_CTRL_REG) | SPI_ACTIVE);
+	/* Poll for ready indication */
+	while ((MV_REG_READ(SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+		continue;
+}
+
+MV_STATUS mvTdmSpiWrite(MV_U8 *cmdBuff, MV_U8 cmdSize, MV_U8 *dataBuff, MV_U8 dataSize, MV_U8 cs)
+{
+	MV_U32 i, val1 = 0, val2 = 0, cmd;
+
+	/*MV_TRC_REC("%s: cs = %d val1 = 0x%x val2 = 0x%x\n",__func__,cs, val1, val2); */
+
+	/* Poll for ready indication */
+	while ((MV_REG_READ(SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+		continue;
+
+	if (cmdSize > 0)
+		val1 = (MV_U32) (cmdBuff[0] & 0xff);
+
+	if (cmdSize > 1)
+		val1 |= (MV_U32) (cmdBuff[1] << 8);
+
+	if (cmdSize > 2)
+		val2 = (MV_U32) (cmdBuff[2] & 0xff);
+
+	mvTdmSetCurrentUnit(cs);
+
+	/* Prepare codec control parameters for command transmission */
+	cmd = TRANSFER_BYTES(cmdSize) | ENDIANESS_MSB_MODE | WR_MODE | CLK_SPEED_LO_DIV;
+
+	MV_REG_WRITE(SPI_CODEC_CMD_LO_REG, val1);
+	MV_REG_WRITE(SPI_CODEC_CMD_HI_REG, val2);
+	MV_REG_WRITE(SPI_CODEC_CTRL_REG, cmd);
+
+	/* Activate */
+	MV_REG_WRITE(SPI_CTRL_REG, MV_REG_READ(SPI_CTRL_REG) | SPI_ACTIVE);
+
+	/* Poll for ready indication */
+	while ((MV_REG_READ(SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+		continue;
+
+	/* Update the command to 1 data byte transfer */
+	cmd = TRANSFER_BYTES(1) | ENDIANESS_MSB_MODE | WR_MODE | CLK_SPEED_LO_DIV;
+
+	for (i = 0; i < dataSize; i++) {
+		val1 = dataBuff[i];
+
+		mvTdmSetCurrentUnit(cs);
+
+		MV_REG_WRITE(SPI_CODEC_CMD_LO_REG, val1);
+		MV_REG_WRITE(SPI_CODEC_CTRL_REG, cmd);
+
+		/* Activate */
+		MV_REG_WRITE(SPI_CTRL_REG, MV_REG_READ(SPI_CTRL_REG) | SPI_ACTIVE);
+
+		/* Poll for ready indication */
+		while ((MV_REG_READ(SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+			continue;
+	}
+
+	return MV_OK;
+}
+
+MV_STATUS mvTdmSpiRead(MV_U8 *cmdBuff, MV_U8 cmdSize, MV_U8 *dataBuff, MV_U8 dataSize, MV_U8 cs)
+{
+	MV_U32 val1 = 0, val2 = 0, cmd;
+	MV_U32 data;
+
+	/*MV_TRC_REC("%s: cs = %d val1 = 0x%x val2 = 0x%x\n",__func__,cs, val1, val2); */
+
+	if (dataSize > 2) {
+		mvOsPrintf("%s: Error, exceeded max read size(%d)\n", __func__, dataSize);
+		return MV_ERROR;
+	}
+
+	/* Poll for ready indication */
+	while ((MV_REG_READ(SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+		continue;
+
+	val1 = (MV_U32) (cmdBuff[0] & 0xff);
+
+	if (cmdSize > 1)
+		val1 |= (MV_U32) (cmdBuff[1] << 8);
+
+	if (cmdSize > 2)
+		val2 = (MV_U32) (cmdBuff[2] & 0xff);
+
+	if (cmdSize > 3)
+		val2 = (MV_U32) (cmdBuff[3] << 8);
+
+	mvTdmSetCurrentUnit(cs);
+
+	/* Prepare codec control parameters for command transmission */
+	if (dataSize == 1)
+		cmd = TRANSFER_BYTES(cmdSize) | ENDIANESS_MSB_MODE | RD_MODE | READ_1_BYTE | CLK_SPEED_LO_DIV;
+	else
+		cmd = TRANSFER_BYTES(cmdSize) | ENDIANESS_MSB_MODE | RD_MODE | READ_2_BYTE | CLK_SPEED_LO_DIV;
+
+	MV_REG_WRITE(SPI_CODEC_CMD_LO_REG, val1);
+	MV_REG_WRITE(SPI_CODEC_CMD_HI_REG, val2);
+	MV_REG_WRITE(SPI_CODEC_CTRL_REG, cmd);
+
+	/* Activate */
+	MV_REG_WRITE(SPI_CTRL_REG, MV_REG_READ(SPI_CTRL_REG) | SPI_ACTIVE);
+
+	/* Poll for ready indication */
+	while ((MV_REG_READ(SPI_CTRL_REG) & SPI_STAT_MASK) == SPI_ACTIVE)
+		continue;
+
+	/* Read the data received from codec */
+	data = MV_REG_READ(SPI_CODEC_READ_DATA_REG);
+	dataBuff[dataSize - 1] = (data & 0xff);
+
+	if (dataSize == 2)
+		dataBuff[0] = ((data & 0xff00) >> 8);
+
+	return MV_OK;
+}
+
+/******************
+** Debug Display **
+******************/
+MV_VOID mvOsRegDump(MV_U32 reg)
+{
+	mvOsPrintf("0x%05x: %08x\n", reg, MV_REG_READ(reg));
+}
+
+MV_VOID mvTdmRegsDump(MV_VOID)
+{
+	MV_U8 i;
+	MV_TDM_CH_INFO *chInfo;
+
+	mvOsPrintf("TDM Control:\n");
+	mvOsRegDump(TDM_SPI_MUX_REG);
+	mvOsRegDump(INT_RESET_SELECT_REG);
+	mvOsRegDump(INT_STATUS_MASK_REG);
+	mvOsRegDump(INT_STATUS_REG);
+	mvOsRegDump(INT_EVENT_MASK_REG);
+	mvOsRegDump(PCM_CTRL_REG);
+	mvOsRegDump(TIMESLOT_CTRL_REG);
+	mvOsRegDump(PCM_CLK_RATE_DIV_REG);
+	mvOsRegDump(FRAME_TIMESLOT_REG);
+	mvOsRegDump(DUMMY_RX_WRITE_DATA_REG);
+	mvOsRegDump(MISC_CTRL_REG);
+	mvOsPrintf("TDM Channel Control:\n");
+	for (i = 0; i < MV_TDM2C_TOTAL_CHANNELS; i++) {
+		mvOsRegDump(CH_DELAY_CTRL_REG(i));
+		mvOsRegDump(CH_SAMPLE_REG(i));
+		mvOsRegDump(CH_DBG_REG(i));
+		mvOsRegDump(CH_TX_CUR_ADDR_REG(i));
+		mvOsRegDump(CH_RX_CUR_ADDR_REG(i));
+		mvOsRegDump(CH_ENABLE_REG(i));
+		mvOsRegDump(CH_BUFF_OWN_REG(i));
+		mvOsRegDump(CH_TX_ADDR_REG(i));
+		mvOsRegDump(CH_RX_ADDR_REG(i));
+	}
+	mvOsPrintf("TDM interrupts:\n");
+	mvOsRegDump(INT_EVENT_MASK_REG);
+	mvOsRegDump(INT_STATUS_MASK_REG);
+	mvOsRegDump(INT_STATUS_REG);
+	for (i = 0; i < MV_TDM2C_TOTAL_CHANNELS; i++) {
+		mvOsPrintf("ch%d info:\n", i);
+		chInfo = tdmChInfo[i];
+		mvOsPrintf("RX buffs:\n");
+		mvOsPrintf("buff0: virt=%p phys=%p\n", chInfo->rxBuffVirt[0], (MV_U32 *) (chInfo->rxBuffPhys[0]));
+		mvOsPrintf("buff1: virt=%p phys=%p\n", chInfo->rxBuffVirt[1], (MV_U32 *) (chInfo->rxBuffPhys[1]));
+		mvOsPrintf("TX buffs:\n");
+		mvOsPrintf("buff0: virt=%p phys=%p\n", chInfo->txBuffVirt[0], (MV_U32 *) (chInfo->txBuffPhys[0]));
+		mvOsPrintf("buff1: virt=%p phys=%p\n", chInfo->txBuffVirt[1], (MV_U32 *) (chInfo->txBuffPhys[1]));
+	}
+}
+
+static MV_VOID mvTdmShowProperties(MV_VOID)
+{
+	mvOsPrintf("TDM dual channel device rev 0x%x\n", MV_REG_READ(TDM_REV_REG));
+}
+
+MV_U8 currRxSampleGet(MV_U8 ch)
+{
+	return (MV_REG_BYTE_READ(CH_DBG_REG(ch) + 1));
+}
+
+MV_U8 currTxSampleGet(MV_U8 ch)
+{
+	return (MV_REG_BYTE_READ(CH_DBG_REG(ch) + 3));
+}
+
+MV_VOID mvTdmIntEnable(MV_VOID)
+{
+	MV_REG_WRITE(INT_STATUS_MASK_REG, (MV_REG_READ(INT_STATUS_MASK_REG) | TDM_INT_SLIC));
+}
+
+MV_VOID mvTdmIntDisable(MV_VOID)
+{
+	MV_U32 val = ~TDM_INT_SLIC;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	MV_REG_WRITE(INT_STATUS_MASK_REG, (MV_REG_READ(INT_STATUS_MASK_REG) & val));
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+MV_VOID mvTdmPcmIfReset(MV_VOID)
+{
+	MV_TRC_REC("->%s\n", __func__);
+
+	MV_REG_BIT_RESET(PCM_CTRL_REG, BIT0);
+
+	/* Wait a bit - might be fine tuned */
+	mvOsDelay(5);
+
+	MV_REG_BIT_SET(TDM_SPI_MUX_REG, BIT0);	/* Disable TDM/SPI interface */
+
+	MV_REG_WRITE(TDM_MISC_REG, 0);		/* SW PCM reset */
+
+	/* Wait a bit more - might be fine tuned */
+	mvOsDelay(100);
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+#ifdef MV_TDM_EXT_STATS
+MV_VOID mvTdmExtStatsGet(MV_TDM_EXTENDED_STATS *tdmExtStats)
+{
+	tdmExtStats->intRxCount = intRxCount;
+	tdmExtStats->intTxCount = intTxCount;
+	tdmExtStats->intRx0Count = intRx0Count;
+	tdmExtStats->intTx0Count = intTx0Count;
+	tdmExtStats->intRx1Count = intRx1Count;
+	tdmExtStats->intTx1Count = intTx1Count;
+	tdmExtStats->intRx0Miss = intRx0Miss;
+	tdmExtStats->intTx0Miss = intTx0Miss;
+	tdmExtStats->intRx1Miss = intRx1Miss;
+	tdmExtStats->intTx1Miss = intTx1Miss;
+	tdmExtStats->pcmRestartCount = pcmRestartCount;
+
+	return;
+}
+#endif
diff --git a/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdm.h b/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdm.h
new file mode 100644
index 0000000..4cd9d7c
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdm.h
@@ -0,0 +1,185 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvTdmh
+#define __INCmvTdmh
+
+#include "voiceband/tdm/mvTdmRegs.h"
+#include "voiceband/mvSysTdmSpi.h"
+#include "voiceband/common/mvTdmComm.h"
+#include "mvSysTdmConfig.h"
+
+/* Defines */
+#define SAMPLES_BUFF_SIZE(bandMode, factor)  \
+	 ((bandMode == MV_NARROW_BAND) ? (factor * 80) : (factor * 160))
+
+#define MV_TDM_CH_BUFF_SIZE(pcmFormat, bandMode, factor) \
+	(pcmFormat == MV_PCM_FORMAT_2BYTES ? (2 * SAMPLES_BUFF_SIZE(bandMode, factor)) : \
+						  SAMPLES_BUFF_SIZE(bandMode, factor))
+
+#define MV_TDM_AGGR_BUFF_SIZE(pcmFormat, bandMode, factor)	(2 * MV_TDM_CH_BUFF_SIZE(pcmFormat, bandMode, factor))
+#define MV_TDM2C_TOTAL_CHANNELS			2
+#define MV_TDM_INT_COUNTER				2
+#define MV_TDM_MAX_SAMPLING_PERIOD		30	/* ms */
+#define MV_TDM_BASE_SAMPLING_PERIOD		10	/* ms */
+#define MV_TDM_TOTAL_CH_SAMPLES			80	/* samples */
+
+/* TDM IRQ types */
+#define MV_EMPTY_INT		0
+#define MV_RX_INT			BIT0
+#define	MV_TX_INT			BIT1
+#define	MV_PHONE_INT 		BIT2
+#define	MV_RX_ERROR_INT 	BIT3
+#define	MV_TX_ERROR_INT 	BIT4
+#define MV_DMA_ERROR_INT	BIT5
+#define MV_CHAN_STOP_INT	BIT6
+#define MV_ERROR_INT		(MV_RX_ERROR_INT | MV_TX_ERROR_INT | MV_DMA_ERROR_INT)
+
+/* PCM SLOT configuration */
+
+#define PCM_SLOT_PCLK	8
+
+#define TDM_INT_SLIC	(DMA_ABORT_BIT|SLIC_INT_BIT)
+#define TDM_INT_TX(ch)	(TX_UNDERFLOW_BIT(ch)|TX_BIT(ch)|TX_IDLE_BIT(ch))
+#define TDM_INT_RX(ch)	(RX_OVERFLOW_BIT(ch)|RX_BIT(ch)|RX_IDLE_BIT(ch))
+
+/* TDM Registers Configuration */
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_PCM_CRTL (MASTER_PCLK_EXTERNAL | MASTER_FS_TDM | DATA_POLAR_NEG | \
+			 FS_POLAR_NEG | INVERT_FS_HI | FS_TYPE_SHORT	 | \
+			 CH_DELAY_ENABLE 		 		 | \
+			 CH_QUALITY_DISABLE | QUALITY_POLARITY_NEG	 | \
+			 QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE 	 | \
+			 WIDEBAND_OFF | PERF_GBUS_TWO_ACCESS)
+
+#else
+#define CONFIG_PCM_CRTL (MASTER_PCLK_TDM | MASTER_FS_TDM | DATA_POLAR_NEG | \
+			 FS_POLAR_NEG | INVERT_FS_HI | FS_TYPE_SHORT	 | \
+			 CH_DELAY_ENABLE 				 | \
+			 CH_QUALITY_DISABLE | QUALITY_POLARITY_NEG	 | \
+			 QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE 	 | \
+			 WIDEBAND_OFF | PERF_GBUS_TWO_ACCESS)
+#endif
+
+#if defined(MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+#define CONFIG_WB_PCM_CRTL (MASTER_PCLK_EXTERNAL | MASTER_FS_TDM | DATA_POLAR_NEG | \
+			    FS_POLAR_NEG | INVERT_FS_HI | FS_TYPE_SHORT	 | \
+			    CH_DELAY_ENABLE 				 | \
+			    CH_QUALITY_DISABLE | QUALITY_POLARITY_NEG	 | \
+			    QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE 	 | \
+			    WIDEBAND_ON | PERF_GBUS_TWO_ACCESS)
+#else
+#define CONFIG_WB_PCM_CRTL (MASTER_PCLK_TDM | MASTER_FS_TDM | DATA_POLAR_NEG | \
+			    FS_POLAR_NEG | INVERT_FS_HI | FS_TYPE_SHORT	 | \
+			    CH_DELAY_ENABLE 				 | \
+			    CH_QUALITY_DISABLE | QUALITY_POLARITY_NEG	 | \
+			    QUALITY_TYPE_TIME_SLOT | CS_CTRL_DONT_CARE 	 | \
+			    WIDEBAND_ON | PERF_GBUS_TWO_ACCESS)
+#endif
+
+#define CONFIG_CH_SAMPLE(bandMode, factor) ((SAMPLES_BUFF_SIZE(bandMode, factor)<<TOTAL_CNT_OFFS) |\
+									 (INT_SAMPLE<<INT_CNT_OFFS))
+
+/* Enumerators */
+
+/* Structures */
+#ifdef MV_TDM_EXT_STATS
+typedef struct {
+	MV_U32 intRxCount;
+	MV_U32 intTxCount;
+	MV_U32 intRx0Count;
+	MV_U32 intTx0Count;
+	MV_U32 intRx1Count;
+	MV_U32 intTx1Count;
+	MV_U32 intRx0Miss;
+	MV_U32 intTx0Miss;
+	MV_U32 intRx1Miss;
+	MV_U32 intTx1Miss;
+	MV_U32 pcmRestartCount;
+} MV_TDM_EXTENDED_STATS;
+#endif
+
+/* APIs */
+MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData);
+MV_STATUS mvTdmWinInit(MV_UNIT_WIN_INFO *addrWinMap);
+MV_VOID mvTdmRelease(MV_VOID);
+MV_32 mvPcmStopIntMiss(void);
+MV_32 mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo);
+MV_VOID mvTdmPcmStart(MV_VOID);
+MV_VOID mvTdmPcmStop(MV_VOID);
+MV_STATUS mvTdmTx(MV_U8 *tdmTxBuff);
+MV_STATUS mvTdmRx(MV_U8 *tdmRxBuff);
+MV_VOID mvTdmRegsDump(MV_VOID);
+MV_STATUS mvTdmSpiRead(MV_U8 *cmdBuff, MV_U8 cmdSize, MV_U8 *dataBuff, MV_U8 dataSize, MV_U8 cs);
+MV_STATUS mvTdmSpiWrite(MV_U8 *cmdBuff, MV_U8 cmdSize, MV_U8 *dataBuff, MV_U8 dataSize, MV_U8 cs);
+MV_U8 currRxSampleGet(MV_U8 ch);
+MV_U8 currTxSampleGet(MV_U8 ch);
+MV_VOID mvTdmIntEnable(MV_VOID);
+MV_VOID mvTdmIntDisable(MV_VOID);
+MV_VOID mvTdmPcmIfReset(MV_VOID);
+#ifdef MV_TDM_EXT_STATS
+MV_VOID mvTdmExtStatsGet(MV_TDM_EXTENDED_STATS *tdmExtStats);
+#endif
+
+#endif /* __INCmvTdmh */
diff --git a/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdmAddrDec.c b/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdmAddrDec.c
new file mode 100644
index 0000000..bb3d6e2
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdmAddrDec.c
@@ -0,0 +1,331 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "voiceband/tdm/mvTdmRegs.h"
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+static MV_TARGET tdmAddrDecPrioTable[] = {
+	SDRAM_CS0,
+	SDRAM_CS1,
+	SDRAM_CS2,
+	SDRAM_CS3,
+	PEX0_MEM,
+	PEX0_IO,
+	TBL_TERM
+};
+
+static MV_STATUS mvTdmWinRead(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin);
+static MV_STATUS mvTdmWinWrite(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin);
+static INLINE MV_VOID mvTdmWinEnable(int winNum, MV_BOOL enable);
+static MV_STATUS tdmWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin);
+
+/*******************************************************************************
+* mvTdmWinInit - Initialize TDM address decode windows
+*
+* DESCRIPTION:
+*               This function initialize TDM window decode unit. It set the
+*               default address decode
+*               windows of the unit.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if setting fail.
+*******************************************************************************/
+MV_STATUS mvTdmWinInit(MV_UNIT_WIN_INFO *addrWinMap)
+{
+	MV_U32 winNum;
+	MV_U32 winPrioIndex = 0;
+	MV_UNIT_WIN_INFO *addrDecWin;
+
+	/*Disable all windows */
+	for (winNum = 0; winNum < TDM_MBUS_MAX_WIN; winNum++)
+		mvTdmWinEnable(winNum, MV_FALSE);
+
+	for (winNum = 0; ((tdmAddrDecPrioTable[winPrioIndex] != TBL_TERM) && (winNum < TDM_MBUS_MAX_WIN));) {
+		addrDecWin = &addrWinMap[tdmAddrDecPrioTable[winPrioIndex]];
+
+		if (addrDecWin->enable == MV_TRUE) {
+			if (MV_OK != mvTdmWinWrite(winNum, addrDecWin)) {
+				mvOsPrintf("mvTdmWinWrite: failed setting window(%d)\n", winNum);
+				return MV_ERROR;
+			}
+			winNum++;
+		}
+		winPrioIndex++;
+	}
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvTdmWinWrite - Set TDM target address window
+*
+* DESCRIPTION:
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI_MEM0)
+*       address window, also known as address decode window.
+*       After setting this target window, the TDM will be able to access the
+*       target within the address window.
+*
+* INPUT:
+*       winNum      - TDM to target address decode window number.
+*       pDecWin     - TDM target window data structure.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if address window overlapps with other address decode windows.
+*       MV_BAD_PARAM if base address is invalid parameter or target is
+*       unknown.
+*
+*******************************************************************************/
+static MV_STATUS mvTdmWinWrite(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
+{
+	MV_U32 ctrlReg = 0, baseReg = 0;
+	MV_U32 size;
+
+	/* Parameter checking   */
+	if (winNum >= TDM_MBUS_MAX_WIN) {
+		mvOsPrintf("mvTdmWinWrite: ERR. Invalid win num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the requested window overlapps with current windows         */
+	if (MV_TRUE == tdmWinOverlapDetect(winNum, &pDecWin->addrWin)) {
+		mvOsPrintf("mvTdmWinWrite: ERR. Window %d overlap\n", winNum);
+		return MV_ERROR;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pDecWin->addrWin.baseLow, pDecWin->addrWin.size)) {
+		mvOsPrintf("mvTdmWinWrite: Error setting TDM window %d"
+			   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
+			   winNum, pDecWin->addrWin.baseLow, (MV_U32)pDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	size = (pDecWin->addrWin.size / MV_TDM_WIN_SIZE_ALIGN) - 1;
+
+	/* for the safe side we disable the window before writing the new
+	   values */
+	mvTdmWinEnable(winNum, MV_FALSE);
+
+	ctrlReg |= ((pDecWin->attrib << TDM_WIN_ATTRIB_OFFS) & TDM_WIN_ATTRIB_MASK);
+	ctrlReg |= ((pDecWin->targetId << TDM_WIN_TARGET_OFFS) & TDM_WIN_TARGET_MASK);
+	ctrlReg |= ((size << TDM_WIN_SIZE_OFFS) & TDM_WIN_SIZE_MASK);
+
+	/* Update Base value  */
+	baseReg = (pDecWin->addrWin.baseLow & TDM_BASE_MASK);
+
+	/* Write to address base and control registers  */
+	MV_REG_WRITE(TDM_WIN_BASE_REG(winNum), baseReg);
+	MV_REG_WRITE(TDM_WIN_CTRL_REG(winNum), ctrlReg);
+
+	/* Enable address decode target window  */
+	if (pDecWin->enable == MV_TRUE)
+		mvTdmWinEnable(winNum, MV_TRUE);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvTdmWinRead - Read peripheral target address window.
+*
+* DESCRIPTION:
+*               Read TDM peripheral target address window.
+*
+* INPUT:
+*       winNum - TDM to target address decode window number.
+*
+* OUTPUT:
+*       pDecWin - TDM target window data structure.
+*
+* RETURN:
+*       MV_ERROR if register parameters are invalid.
+*
+*******************************************************************************/
+static MV_STATUS mvTdmWinRead(MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
+{
+
+	MV_U32 ctrlReg, baseReg;
+	MV_U32 size;
+
+	/* Parameter checking   */
+	if (winNum >= TDM_MBUS_MAX_WIN) {
+		mvOsPrintf("mvTdmWinRead: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	baseReg = MV_REG_READ(TDM_WIN_BASE_REG(winNum));
+	ctrlReg = MV_REG_READ(TDM_WIN_CTRL_REG(winNum));
+
+	/* Check if window is enabled   */
+	if (ctrlReg & TDM_WIN_ENABLE_MASK) {
+		pDecWin->enable = MV_TRUE;
+
+		/* Extract window parameters from registers */
+		pDecWin->targetId = (ctrlReg & TDM_WIN_TARGET_MASK) >> TDM_WIN_TARGET_OFFS;
+		pDecWin->attrib = (ctrlReg & TDM_WIN_ATTRIB_MASK) >> TDM_WIN_ATTRIB_OFFS;
+
+		size = (ctrlReg & TDM_WIN_SIZE_MASK) >> TDM_WIN_SIZE_OFFS;
+		pDecWin->addrWin.size = (size + 1) * MV_TDM_WIN_SIZE_ALIGN;
+		pDecWin->addrWin.baseLow = (baseReg & TDM_BASE_MASK);
+		pDecWin->addrWin.baseHigh = 0;
+	} else {
+		pDecWin->enable = MV_FALSE;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvTdmWinEnable - Enable/disable a TDM to target address window
+*
+* DESCRIPTION:
+*       This function enable/disable a TDM to target address window.
+*       According to parameter 'enable' the routine will enable the
+*       window, thus enabling TDM accesses.
+*       Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - TDM to target address decode window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if decode window number was wrong or enabled window overlapps.
+*
+*******************************************************************************/
+static INLINE MV_VOID mvTdmWinEnable(int winNum, MV_BOOL enable)
+{
+	if (enable == MV_TRUE)
+		MV_REG_BIT_SET(TDM_WIN_CTRL_REG(winNum), TDM_WIN_ENABLE_MASK);
+	else
+		MV_REG_BIT_RESET(TDM_WIN_CTRL_REG(winNum), TDM_WIN_ENABLE_MASK);
+}
+
+/*******************************************************************************
+* tdmWinOverlapDetect - Detect TDM address windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviour is expected in case TDM address decode
+*       windows overlapps.
+*       This function detects TDM address decode windows overlapping of a
+*       specified window. The function does not check the window itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       winNum      - address decode window number.
+*       pDecWin     - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data
+*       from registers.
+*
+*******************************************************************************/
+static MV_STATUS tdmWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 winNumIndex;
+	MV_UNIT_WIN_INFO addrDecWin;
+
+	for (winNumIndex = 0; winNumIndex < TDM_MBUS_MAX_WIN; winNumIndex++) {
+		/* Do not check window itself       */
+		if (winNumIndex == winNum)
+			continue;
+
+		/* Get window parameters    */
+		if (MV_OK != mvTdmWinRead(winNumIndex, &addrDecWin)) {
+			mvOsPrintf("%s: ERR. TargetWinGet failed\n", __func__);
+			return MV_ERROR;
+		}
+
+		/* Do not check disabled windows    */
+		if (addrDecWin.enable == MV_FALSE)
+			continue;
+
+		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
+			return MV_TRUE;
+	}
+
+	return MV_FALSE;
+}
diff --git a/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdmRegs.h b/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdmRegs.h
new file mode 100644
index 0000000..a5558e6
--- /dev/null
+++ b/drivers/telephony/mvebu_phone/voiceband/tdm/mvTdmRegs.h
@@ -0,0 +1,307 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvTdmRegsh
+#define __INCmvTdmRegsh
+
+#include "mvSysTdmConfig.h"
+
+/************************************************/
+/*        TDM to Mbus Bridge Register Map       */
+/************************************************/
+#define TDM_SPI_MUX_REG		(MV_TDM_REGS_BASE + 0x4000)
+#define TDM_MBUS_CONFIG_REG	(MV_TDM_REGS_BASE + 0x4010)
+#define TDM_MISC_REG		(MV_TDM_REGS_BASE + 0x4070)
+#define TDM_CLK_DIV_REG		(MV_TDM_REGS_BASE + 0x4074)
+
+/*****************************************/
+/*        TDM Control Register Map       */
+/*****************************************/
+#define PCM_CTRL_REG		 MV_TDM_REGS_BASE
+#define TIMESLOT_CTRL_REG	(MV_TDM_REGS_BASE + 0x4)
+#define FRAME_TIMESLOT_REG	(MV_TDM_REGS_BASE + 0x38)
+#define PCM_CLK_RATE_DIV_REG	(MV_TDM_REGS_BASE + 0x3c)
+#define INT_EVENT_MASK_REG	(MV_TDM_REGS_BASE + 0x40)
+/*#define INT_EVENT_REG         0xb0044*/
+#define INT_STATUS_MASK_REG	(MV_TDM_REGS_BASE + 0x48)
+#define INT_RESET_SELECT_REG	(MV_TDM_REGS_BASE + 0x4c)
+#define INT_STATUS_REG		(MV_TDM_REGS_BASE + 0x50)
+#define DUMMY_RX_WRITE_DATA_REG (MV_TDM_REGS_BASE + 0x54)
+#define MISC_CTRL_REG		(MV_TDM_REGS_BASE + 0x58)
+#define TESTBUS_MUX_SELECT_REG	(MV_TDM_REGS_BASE + 0x5c)
+#define CUR_TIMESLOT_REG	(MV_TDM_REGS_BASE + 0x70)
+#define TDM_REV_REG		(MV_TDM_REGS_BASE + 0x74)
+#define DMA_ABORT_ADDR_REG	(MV_TDM_REGS_BASE + 0x80)
+#define DMA_ABORT_INFO_REG	(MV_TDM_REGS_BASE + 0x84)
+
+#define CH_WB_DELAY_CTRL_REG(ch) ((MV_TDM_REGS_BASE + 0x88) | ((ch)<<2))
+#define CH_DELAY_CTRL_REG(ch)	((MV_TDM_REGS_BASE + 0x8) | ((ch)<<2))
+#define CH_SAMPLE_REG(ch)	((MV_TDM_REGS_BASE + 0x30) | ((ch)<<2))
+#define CH_DBG_REG(ch)		((MV_TDM_REGS_BASE + 0x78) | ((ch)<<2))
+#define CH_TX_CUR_ADDR_REG(ch)	((MV_TDM_REGS_BASE + 0x60) | ((ch)<<3))
+#define CH_RX_CUR_ADDR_REG(ch)	((MV_TDM_REGS_BASE + 0x64) | ((ch)<<3))
+#define CH_ENABLE_REG(ch)	((MV_TDM_REGS_BASE) | (((ch)+1)<<4))
+#define CH_BUFF_OWN_REG(ch)	((MV_TDM_REGS_BASE + 0x4) | (((ch)+1)<<4))
+#define CH_TX_ADDR_REG(ch)	((MV_TDM_REGS_BASE + 0x8) | (((ch)+1)<<4))
+#define CH_RX_ADDR_REG(ch)	((MV_TDM_REGS_BASE + 0xc) | (((ch)+1)<<4))
+
+/* PCM_CLK_RATE_DIV_REG bits */
+#define PCM_256KHZ	1
+#define PCM_512KHZ	(1<<1)
+#define PCM_1024KHZ	(1<<2)
+#define PCM_2048KHZ	(1<<3)
+#define PCM_4096KHZ	(1<<4)
+#define PCM_8192KHZ	(1<<5)
+#define PCM_DIV_PASS	(1<<6)
+
+/* FRAME_TIMESLOT_REG bits */
+#define TIMESLOTS4_256KHZ	(1<<2)
+#define TIMESLOTS8_512KHZ	(1<<3)
+#define TIMESLOTS16_1024KHZ	(1<<4)
+#define TIMESLOTS32_2048KHZ	(1<<5)
+#define TIMESLOTS64_4096KHZ	(1<<6)
+#define TIMESLOTS128_8192KHZ	(1<<7)
+
+/* PCM_CTRL_REG bits */
+#define MASTER_PCLK_OFFS	0
+#define MASTER_PCLK_TDM		(0<<MASTER_PCLK_OFFS)
+#define MASTER_PCLK_EXTERNAL	(1<<MASTER_PCLK_OFFS)
+#define MASTER_FS_OFFS		1
+#define MASTER_FS_TDM		(0<<MASTER_FS_OFFS)
+#define MASTER_FS_EXTERNAL	(1<<MASTER_FS_OFFS)
+#define DATA_POLAR_OFFS		2
+#define DATA_POLAR_NEG		(0<<DATA_POLAR_OFFS)
+#define DATA_POLAR_POS		(1<<DATA_POLAR_OFFS)
+#define FS_POLAR_OFFS		3
+#define FS_POLAR_NEG		(0<<FS_POLAR_OFFS)
+#define FS_POLAR_POS		(1<<FS_POLAR_OFFS)
+#define INVERT_FS_OFFS		4
+#define INVERT_FS_HI		(0<<INVERT_FS_OFFS)
+#define INVERT_FS_LO		(1<<INVERT_FS_OFFS)
+#define FS_TYPE_OFFS		5
+#define FS_TYPE_SHORT		(0<<FS_TYPE_OFFS)
+#define FS_TYPE_LONG		(1<<FS_TYPE_OFFS)
+#define PCM_SAMPLE_SIZE_OFFS	6
+#define PCM_SAMPLE_SIZE_1	(0<<PCM_SAMPLE_SIZE_OFFS)
+#define PCM_SAMPLE_SIZE_2	(1<<PCM_SAMPLE_SIZE_OFFS)
+#define CH_DELAY_OFFS		8
+#define CH_DELAY_DISABLE	(0<<CH_DELAY_OFFS)
+#define CH_DELAY_ENABLE		(3<<CH_DELAY_OFFS)
+#define CH_QUALITY_OFFS		10
+#define CH_QUALITY_DISABLE	(0<<CH_QUALITY_OFFS)
+#define CH_QUALITY_ENABLE	(3<<CH_QUALITY_OFFS)
+#define QUALITY_POLARITY_OFFS	12
+#define QUALITY_POLARITY_NEG	(0<<QUALITY_POLARITY_OFFS)
+#define QUALITY_POLARITY_POS	(1<<QUALITY_POLARITY_OFFS)
+#define QUALITY_TYPE_OFFS	13
+#define QUALITY_TYPE_TIME_SLOT	(0<<QUALITY_TYPE_OFFS)
+#define QUALITY_TYPE_MSB	(3<<QUALITY_TYPE_OFFS)
+#define CS_CTRL_OFFS		15
+#define CS_CTRL_DONT_CARE	(0<<CS_CTRL_OFFS)
+#define CS_CTRL			(1<<CS_CTRL_OFFS)
+#define CS_CTRL_0		(0<<CS_CTRL_OFFS)
+#define CS_CTRL_1		(1<<CS_CTRL_OFFS)
+#define WIDEBAND_OFFS		16
+#define WIDEBAND_OFF		(0<<WIDEBAND_OFFS)
+#define WIDEBAND_ON		(3<<WIDEBAND_OFFS)
+#define PERF_GBUS_OFFS		31
+#define PERF_GBUS_ONE_ACCESS	(0<<PERF_GBUS_OFFS)
+#define PERF_GBUS_TWO_ACCESS	(1<<PERF_GBUS_OFFS)
+
+/* TIMESLOT_CTRL_REG bits */
+#define CH0_RX_SLOT_OFFS	0
+#define CH0_TX_SLOT_OFFS	8
+#define CH1_RX_SLOT_OFFS	16
+#define CH1_TX_SLOT_OFFS	24
+
+/* CH_SAMPLE_REG bits */
+#define TOTAL_CNT_OFFS		0
+#define TOTAL_CNT_MASK		(0xff<<TOTAL_CNT_OFFS)
+#define INT_CNT_OFFS		8
+#define INT_CNT_MASK		(0xff<<INT_CNT_OFFS)
+
+/* CH_BUFF_OWN_REG bits */
+#define RX_OWN_BYTE_OFFS	0
+#define TX_OWN_BYTE_OFFS	1
+#define OWNER_MASK		1
+#define OWN_BY_SW		0
+#define OWN_BY_HW		1
+
+/* CH_ENABLE_REG bits */
+#define RX_ENABLE_BYTE_OFFS	0
+#define TX_ENABLE_BYTE_OFFS	1
+#define CH_ENABLE		1
+#define CH_DISABLE		0
+
+/* INT_STATUS_REG bits */
+#define RX_OVERFLOW_BIT(ch)	(1<<(0+(ch)*2))
+#define TX_UNDERFLOW_BIT(ch)	(1<<(1+((ch)*2)))
+#define RX_BIT(ch)		(1<<(4+((ch)*2)))
+#define TX_BIT(ch)		(1<<(5+((ch)*2)))
+#define RX_IDLE_BIT(ch)		(1<<(8+((ch)*2)))
+#define TX_IDLE_BIT(ch)		(1<<(9+((ch)*2)))
+#define RX_FIFO_FULL(ch)	(1<<(12+((ch)*2)))
+#define TX_FIFO_EMPTY(ch)	(1<<(13+((ch)*2)))
+#define DMA_ABORT_BIT		(1<<16)
+#define SLIC_INT_BIT		(1<<17)
+
+/* TDU_INTR_SET_RESET bits */
+#define CLEAR_MODE_OFFS		0
+#define CLEAR_ON_READ		(1<<CLEAR_MODE_OFFS)
+#define CLEAR_ON_ZERO		(0<<CLEAR_MODE_OFFS)
+
+/* CH_DELAY_CTRL_REG bits */
+#define CH_RX_DELAY_OFFS	0
+#define CH_RX_DELAY_MASK	(0x3ff<<CH_RX_DELAY_OFFS)
+#define CH_TX_DELAY_OFFS	16
+#define CH_TX_DELAY_MASK	(0x3ff<<CH_RX_DELAY_OFFS)
+
+
+/*********************************/
+/*        SPI Register Map       */
+/*********************************/
+#define SPI_CLK_PRESCALAR_REG	(MV_TDM_REGS_BASE + 0x3100)
+#define SPI_GLOBAL_CTRL_REG	(MV_TDM_REGS_BASE + 0x3104)
+#define SPI_CTRL_REG		(MV_TDM_REGS_BASE + 0x3108)
+#define SPI_MICRO_WIRE_CTRL_REG	(MV_TDM_REGS_BASE + 0x310c)
+#define SPI_TWSI_CTRL_REG	(MV_TDM_REGS_BASE + 0x3110)
+#define SPI_MV_STATUS_REG	(MV_TDM_REGS_BASE + 0x311c)
+#define SPI_INT_MASK_REG	(MV_TDM_REGS_BASE + 0x3120)
+#define SPI_DATA_REG		(MV_TDM_REGS_BASE + 0x3124)
+#define SPI_ADDR_REG		(MV_TDM_REGS_BASE + 0x3128)
+#define SPI_CODEC_CMD_LO_REG	(MV_TDM_REGS_BASE + 0x3130)
+#define SPI_CODEC_CMD_HI_REG	(MV_TDM_REGS_BASE + 0x3134)
+#define SPI_CODEC_CTRL_REG	(MV_TDM_REGS_BASE + 0x3138)
+#define SPI_CODEC_READ_DATA_REG	(MV_TDM_REGS_BASE + 0x313c)
+
+/* SPI CLK_PRESCALAR_REG bits */
+#define SPI_CLK_2MHZ	0x2A64  /* refers to tclk = 200MHz */
+#define SPI_CLK_4MHZ	0x2A32  /* refers to tclk = 200MHz */
+#define SPI_CLK_8MHZ	0x2A19  /* refers to tclk = 200MHz */
+
+/* SPI_CTRL_REG bits */
+#define SPI_STAT_OFFS	10
+#define SPI_STAT_MASK	(1<<SPI_STAT_OFFS)
+#ifndef CONFIG_OF
+#define SPI_READY	(0<<SPI_STAT_OFFS)
+#endif
+#define SPI_ACTIVE	(1<<SPI_STAT_OFFS)
+
+/* SPI_GLOBAL_CTRL_REG bits */
+#define SPI_GLOBAL_ENABLE_OFFS	0
+#define SPI_GLOBAL_ENABLE_MASK	(1<<SPI_GLOBAL_ENABLE_OFFS)
+#define SPI_GLOBAL_DISABLE	(0<<SPI_GLOBAL_ENABLE_OFFS)
+#define SPI_GLOBAL_ENABLE	(1<<SPI_GLOBAL_ENABLE_OFFS)
+
+/* SPI_CODEC_CTRL_REG bits */
+#define TRANSFER_BYTES_OFFS	0
+#define TRANSFER_BYTES(count)	((count-1)<<TRANSFER_BYTES_OFFS)
+#define ENDIANESS_MODE_OFFS	2
+#define ENDIANESS_MSB_MODE	(0<<ENDIANESS_MODE_OFFS)
+#define ENDIANESS_LSB_MODE	(1<<ENDIANESS_MODE_OFFS)
+#define RD_WR_MODE_OFFS		3
+#define WR_MODE			(0<<RD_WR_MODE_OFFS)
+#define RD_MODE			(1<<RD_WR_MODE_OFFS)
+#define READ_BYTES_OFFS		4
+#define READ_1_BYTE		(0<<READ_BYTES_OFFS)
+#define READ_2_BYTE		(1<<READ_BYTES_OFFS)
+#define CLK_SPEED_OFFS		5
+#define CLK_SPEED_LO_DIV	(0<<CLK_SPEED_OFFS)
+#define CLK_SPEED_HI_DIV	(1<<CLK_SPEED_OFFS)
+#define CS_HI_CNT_VAL_RD_OFFS	6
+#define CS_HI_CNT_VAL_RD_MASK	(0xff3<<CS_HI_CNT_VAL_RD_OFFS)
+
+/*********************************/
+/*        TDM Address Decoding   */
+/*********************************/
+
+#define TDM_MBUS_MAX_WIN	4
+#ifdef CONFIG_OF
+#define TDM_WIN_CTRL_REG(win)	(0x4030 + (win<<4))
+#define TDM_WIN_BASE_REG(win)	(0x4034 + (win<<4))
+#else
+#define TDM_WIN_CTRL_REG(win)	((MV_TDM_REGS_BASE + 0x4030) + (win<<4))
+#define TDM_WIN_BASE_REG(win)	((MV_TDM_REGS_BASE + 0x4034) + (win<<4))
+#endif
+
+/* TDM_WIN_CTRL_REG bits */
+#define TDM_WIN_ENABLE_OFFS	0
+#define TDM_WIN_ENABLE_MASK	(1<<TDM_WIN_ENABLE_OFFS)
+#define TDM_WIN_ENABLE		1
+#define TDM_WIN_TARGET_OFFS	4
+#define TDM_WIN_TARGET_MASK	(0xf<<TDM_WIN_TARGET_OFFS)
+#define TDM_WIN_ATTRIB_OFFS	8
+#define TDM_WIN_ATTRIB_MASK	(0xff<<TDM_WIN_ATTRIB_OFFS)
+#define TDM_WIN_SIZE_OFFS	16
+#define TDM_WIN_SIZE_MASK	(0xffff<<TDM_WIN_SIZE_OFFS)
+
+/* TDM_WIN_BASE_REG bits */
+#define TDM_BASE_OFFS		16
+#define TDM_BASE_MASK		(0xffff<<TDM_BASE_OFFS)
+
+#define MV_TDM_WIN_SIZE_ALIGN	_64K
+
+
+#endif /*__INCmvTdmRegsh*/
+
